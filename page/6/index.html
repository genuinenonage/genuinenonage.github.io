<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/genuinenonage/genuinenonage.github.io.git/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/genuinenonage/genuinenonage.github.io.git/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/genuinenonage/genuinenonage.github.io.git/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/genuinenonage/genuinenonage.github.io.git/images/logo.svg" color="#222">

<link rel="stylesheet" href="/genuinenonage/genuinenonage.github.io.git/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"github.com","root":"/genuinenonage/genuinenonage.github.io.git/","images":"/genuinenonage/genuinenonage.github.io.git/images","scheme":"Pisces","darkmode":true,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/genuinenonage/genuinenonage.github.io.git/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/genuinenonage/genuinenonage.github.io.git/js/config.js"></script>

    <meta name="description" content="菜鸡">
<meta property="og:type" content="website">
<meta property="og:title" content="genuine nonage">
<meta property="og:url" content="https://github.com/genuinenonage/genuinenonage.github.io.git/page/6/index.html">
<meta property="og:site_name" content="genuine nonage">
<meta property="og:description" content="菜鸡">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="QB">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://github.com/genuinenonage/genuinenonage.github.io.git/page/6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>genuine nonage</title>
  






  <noscript>
    <link rel="stylesheet" href="/genuinenonage/genuinenonage.github.io.git/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/genuinenonage/genuinenonage.github.io.git/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">genuine nonage</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/genuinenonage/genuinenonage.github.io.git/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/genuinenonage/genuinenonage.github.io.git/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/genuinenonage/genuinenonage.github.io.git/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/genuinenonage/genuinenonage.github.io.git/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QB</p>
  <div class="site-description" itemprop="description">菜鸡</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/genuinenonage/genuinenonage.github.io.git/archives/">
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/genuinenonage/genuinenonage.github.io.git/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/genuinenonage/genuinenonage.github.io.git/tags/">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/genuinenonage/genuinenonage.github.io.git/2020/09/21/java/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/genuinenonage/genuinenonage.github.io.git/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/genuinenonage/genuinenonage.github.io.git/2020/09/21/java/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">Java8的新特性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-21 07:31:00" itemprop="dateCreated datePublished" datetime="2020-09-21T07:31:00+08:00">2020-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-08 15:51:01" itemprop="dateModified" datetime="2021-02-08T15:51:01+08:00">2021-02-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>新增了非常多的特性，主要有：</p>
<ul>
<li><strong>Lambad表达式</strong>：Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li>
<li><strong>方法引用</strong>：可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合，使语言的构造更紧凑简洁，减少冗余代码。</li>
<li><strong>默认方法</strong>：默认方法就是一个在接口里面有了一个实现的方法。</li>
<li><strong>StreamAPI</strong>：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li>
<li><strong>DateTimeAPI</strong>：加强对日期与时间的处理。</li>
<li><strong>Optional类</strong>：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li><strong>Nashorn，JavaScript引擎</strong>：Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li>
</ul>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p>
<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>
<ol>
<li><p>接收2个int型整数,返回他们的和<br>(int x, int y) -&gt; x + y  </p>
</li>
<li><p>接受2个参数(数字),并返回他们的差值<br>(x, y) -&gt; x – y  </p>
</li>
<li><p>接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)<br>(String s) -&gt; System.out.print(s)</p>
<pre><code> public class Java8Tester &#123;
    public static void main(String args[])&#123;
       Java8Tester tester = new Java8Tester();
         
       // 类型声明
       MathOperation addition = (int a, int b) -&gt; a + b;
         
       // 不用类型声明
       MathOperation subtraction = (a, b) -&gt; a - b;
         
       // 大括号中的返回语句
       MathOperation multiplication = (int a, int b) -&gt; &#123; return a * b; &#125;;
         
       // 没有大括号及返回语句
       MathOperation division = (int a, int b) -&gt; a / b;
         
       System.out.println(&quot;10 + 5 = &quot; + tester.operate(10, 5, addition));
       System.out.println(&quot;10 - 5 = &quot; + tester.operate(10, 5, subtraction));
       System.out.println(&quot;10 x 5 = &quot; + tester.operate(10, 5, multiplication));
       System.out.println(&quot;10 / 5 = &quot; + tester.operate(10, 5, division));
         
       // 不用括号
       GreetingService greetService1 = message -&gt;
       System.out.println(&quot;Hello &quot; + message);
         
       // 用括号
       GreetingService greetService2 = (message) -&gt;
       System.out.println(&quot;Hello &quot; + message);
         
       greetService1.sayMessage(&quot;Runoob&quot;);
       greetService2.sayMessage(&quot;Google&quot;);
    &#125;
     
    interface MathOperation &#123;
       int operation(int a, int b);
    &#125;
     
    interface GreetingService &#123;
       void sayMessage(String message);
    &#125;
     
    private int operate(int a, int b, MathOperation mathOperation)&#123;
       return mathOperation.operation(a, b);
    &#125;
 &#125;
</code></pre>
</li>
</ol>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用通过方法的名字来指向一个方法。</p>
<p>方法引用使用一对冒号 :: 。</p>
<ul>
<li><p>构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new</p>
<ul>
<li>实例如下：<br>final Car car = Car.create( Car::new );<br>final List&lt; Car &gt; cars = Arrays.asList( car );</li>
</ul>
</li>
<li><p>静态方法引用：它的语法是Class::static_method</p>
<ul>
<li>实例如下：<br>cars.forEach( Car::collide );</li>
</ul>
</li>
<li><p>特定类的任意对象的方法引用：它的语法是Class::method</p>
<ul>
<li>实例如下：<br>cars.forEach( Car::repair );</li>
</ul>
</li>
<li><p>特定对象的方法引用：它的语法是instance::method</p>
<ul>
<li><p>实例如下：<br>final Car police = Car.create( Car::new );<br>cars.forEach( police::follow );</p>
<pre><code>  public class Java8Tester &#123;
     public static void main(String args[])&#123;
        List names = new ArrayList();
          
        names.add(&quot;Google&quot;);
        names.add(&quot;Runoob&quot;);
        names.add(&quot;Taobao&quot;);
        names.add(&quot;Baidu&quot;);
        names.add(&quot;Sina&quot;);
          
        names.forEach(System.out::println);
     &#125;
  &#125;
  实例中我们将 System.out::println 方法作为静态方法来引用。
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>
<p>函数式接口可以被隐式转换为 lambda 表达式。</p>
<pre><code>@FunctionalInterface
interface GreetingService 
&#123;
    void sayMessage(String message);
&#125;
</code></pre>
<p>使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：</p>
<pre><code>GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message);
</code></pre>
<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>新增了接口的默认方法。</p>
<p>接口可以有实现方法，不需要实现类去实现其方法。</p>
<p>只需在方法名前面加个 default 关键字即可实现默认方法。</p>
<h4 id="静态默认方法"><a href="#静态默认方法" class="headerlink" title="静态默认方法"></a>静态默认方法</h4><p>Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。</p>
<pre><code>public interface Vehicle &#123;
   default void print()&#123;
      System.out.println(&quot;我是一辆车!&quot;);
   &#125;
    // 静态方法
   static void blowHorn()&#123;
      System.out.println(&quot;按喇叭!!!&quot;);
   &#125;
&#125;
</code></pre>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p>
<p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p>
<h4 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h4><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作。</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
<li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>
</ul>
<h4 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h4><p>在 Java 8 中, 集合接口有两个方法来生成流：</p>
<ul>
<li>stream()  为集合创建串行流。</li>
<li>parallelStream()  为集合创建并行流。</li>
</ul>
<h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><ul>
<li>一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</li>
<li>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。 </li>
<li>Optional 类的引入很好的解决空指针异常。</li>
</ul>
<h3 id="日期时间API"><a href="#日期时间API" class="headerlink" title="日期时间API"></a>日期时间API</h3><p>通过发布新的Date-Time API  加强对日期与时间的处理。 </p>
<p>旧版日期时间API问题：</p>
<ul>
<li>非线程安全：java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</li>
<li>设计很差：Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字。</li>
<li>时区处理麻烦：日期类并不提供国际化，没有时区支持。</li>
</ul>
<p>Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：</p>
<ul>
<li>Local(本地) − 简化了日期时间的处理，没有时区的问题。</li>
<li>Zoned(时区) − 通过制定的时区处理日期时间。</li>
</ul>
<h4 id="本地化日期时间API"><a href="#本地化日期时间API" class="headerlink" title="本地化日期时间API"></a>本地化日期时间API</h4><p>LocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况。</p>
<h4 id="时区的时间日期API"><a href="#时区的时间日期API" class="headerlink" title="时区的时间日期API"></a>时区的时间日期API</h4><p>需要考虑到时区，就可以使用时区的日期时间API。</p>
<pre><code>public void testZonedDateTime()&#123;
    
  // 获取当前时间日期
  ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);
  System.out.println(&quot;date1: &quot; + date1);
    
  ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);
  System.out.println(&quot;ZoneId: &quot; + id);
    
  ZoneId currentZone = ZoneId.systemDefault();
  System.out.println(&quot;当期时区: &quot; + currentZone);
</code></pre>
<p>   }</p>
<h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>在Java 8中，Base64编码已经成为Java类库的标准。</p>
<p>Java 8 内置了 Base64 编码的编码器和解码器。</p>
<p>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p>
<ul>
<li>基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。</li>
<li>URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。</li>
<li>MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。</li>
</ul>
<h4 id="内嵌类"><a href="#内嵌类" class="headerlink" title="内嵌类"></a>内嵌类</h4><ol>
<li>static class Base64.Decoder  该类实现一个解码器用于，使用 Base64 编码来解码字节数据。</li>
<li>static class Base64.Encoder  该类实现一个编码器，使用 Base64 编码来编码字节数据。</li>
</ol>
<p>有多个get方法使用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/genuinenonage/genuinenonage.github.io.git/2020/09/21/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%89%8B%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/genuinenonage/genuinenonage.github.io.git/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/genuinenonage/genuinenonage.github.io.git/2020/09/21/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%89%8B%E6%9E%B6/" class="post-title-link" itemprop="url">什么是脚手架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-09-21 06:43:00 / 修改时间：06:50:35" itemprop="dateCreated datePublished" datetime="2020-09-21T06:43:00+08:00">2020-09-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="在我看来："><a href="#在我看来：" class="headerlink" title="在我看来："></a>在我看来：</h3><p>脚手架就是搭建的能直接从事业务开发的项目框架。比如整合并配置完成了：AOP/Swagger/Mybatis/Druid/通用工具类等。</p>
<h3 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h3><p>指的是两种技术：</p>
<ol>
<li>与某些MVC 框架中的数据库访问相关的代码生成技术</li>
<li>由各种工具支持的项目生成技术</li>
</ol>
<p>脚手架是一种由一些 model–view–controller 框架支持的技术，程序员可以在其中指定应用程序数据库的使用方式。该编译器或框架使用说明书中，与预先定义的代码模板在一起，产生最终代码的应用程序可以使用它来创建，读取，更新和删除数据库条目，有效治疗模板作为“ 支架 ”上建立更强大的应用程序。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/genuinenonage/genuinenonage.github.io.git/2020/09/18/spring/SpringMVC%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/genuinenonage/genuinenonage.github.io.git/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/genuinenonage/genuinenonage.github.io.git/2020/09/18/spring/SpringMVC%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/" class="post-title-link" itemprop="url">SpringMVC框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-18 18:33:00" itemprop="dateCreated datePublished" datetime="2020-09-18T18:33:00+08:00">2020-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-08 15:34:08" itemprop="dateModified" datetime="2021-02-08T15:34:08+08:00">2021-02-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SpringMVC框架"><a href="#SpringMVC框架" class="headerlink" title="SpringMVC框架"></a>SpringMVC框架</h1><p>springmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。</p>
<p>springmvc是一个基于mvc的web框架。</p>
<h3 id="什么是mvc"><a href="#什么是mvc" class="headerlink" title="什么是mvc"></a>什么是mvc</h3><p>mvc是一个设计模式。</p>
<h4 id="mvc在b-s系统下的应用"><a href="#mvc在b-s系统下的应用" class="headerlink" title="mvc在b/s系统下的应用"></a>mvc在b/s系统下的应用</h4><p><img src="https://i.loli.net/2020/09/18/L4xKMIndoywCD1q.jpg" alt="mvc在bs系统下的应用.jpg"></p>
<h4 id="springmvc的框架"><a href="#springmvc的框架" class="headerlink" title="springmvc的框架"></a>springmvc的框架</h4><p><img src="https://i.loli.net/2020/09/21/cETUaj26e9LoM5O.png" alt="springmvc框架1.PNG"><br><img src="https://i.loli.net/2020/09/21/BLzTq9XCuEKQdpP.jpg" alt="springmvc框架2.jpg"></p>
<p>组件：</p>
<ol>
<li>前端控制器 Dispatcherservlet：作用接受请求，响应结果，相当于转发器(非常重要)。</li>
<li>处理器映射器 HandlerMapping：根据请求的url查找Handler</li>
<li>处理器适配器 HandlerAdapter：按特定的规则执行Handler</li>
<li>处理器Handler（需要开发）:编写Handler按照HandlerAdapter的要求去做</li>
<li>视图解析器 View reolver：进行视图解析，根据逻辑视图名解析成真正的视图（view）</li>
<li>视图View（需要开发）：View是一个接口，实现类支持不同的View类型（jsp,freemarker,pdf…）</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/genuinenonage/genuinenonage.github.io.git/2020/09/17/MQ%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/genuinenonage/genuinenonage.github.io.git/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/genuinenonage/genuinenonage.github.io.git/2020/09/17/MQ%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">MQ介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-17 21:49:00" itemprop="dateCreated datePublished" datetime="2020-09-17T21:49:00+08:00">2020-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-08 15:34:48" itemprop="dateModified" datetime="2021-02-08T15:34:48+08:00">2021-02-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="MQ介绍"><a href="#MQ介绍" class="headerlink" title="MQ介绍"></a>MQ介绍</h2><p>消息队列，先进先出的数据结构。</p>
<p>发送方 –》 RPC –》 接受方<br>发送发 –》 消息发送MQ –》 有消息 –》 接受方</p>
<p>优点：</p>
<ul>
<li>应用解耦：不同系统之间通过 MQ存储消息 连接消息。</li>
<li>流量削峰：用户请求缓存到MQ中，系统在 MQ 中拉取支持的数量的请求。</li>
<li>数据分发：消息生产方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据即可。</li>
</ul>
<p>缺点：</p>
<ul>
<li>系统可用性降低：系统引入外部依赖越多，系统稳定性越差，一旦MQ宕机，会对业务造成影响。<ul>
<li>如何保证MQ的高可用？</li>
</ul>
</li>
<li>系统复杂度提高：MQ加入增加系统复杂度，以前系统间时同步的远程调用，现在是MQ进行异步调用。<ul>
<li>如何保证消息 没有被重复消费？怎么处理消息丢失情况？传递的顺序性？</li>
</ul>
</li>
<li>一致性问题？<ul>
<li>如何保证消息数据处理的一致性？</li>
</ul>
</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/genuinenonage/genuinenonage.github.io.git/2020/09/17/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/genuinenonage/genuinenonage.github.io.git/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/genuinenonage/genuinenonage.github.io.git/2020/09/17/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式（策略与单例）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-17 17:04:00" itemprop="dateCreated datePublished" datetime="2020-09-17T17:04:00+08:00">2020-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-08 15:33:43" itemprop="dateModified" datetime="2021-02-08T15:33:43+08:00">2021-02-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="为什么需要设计模式"><a href="#为什么需要设计模式" class="headerlink" title="为什么需要设计模式"></a>为什么需要设计模式</h2><p>设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。</p>
<p>新增功能（可扩展性），维护（可读性，规范性）项目变得容易<br>程序可靠，代码可重用。 </p>
<h2 id="为什么学习设计模式"><a href="#为什么学习设计模式" class="headerlink" title="为什么学习设计模式"></a>为什么学习设计模式</h2><p>如今程序员门槛越来越高。</p>
<p>在实际模式中使用过什么设计模式，怎样使用的，解决了什么问题。</p>
<h2 id="设计模式在软件的哪里"><a href="#设计模式在软件的哪里" class="headerlink" title="设计模式在软件的哪里"></a>设计模式在软件的哪里</h2><p>面向对象（OO）=&gt; 功能模块[设计模式+算法（数据结构）] =&gt; 框架[使用到多种设计模式] =&gt; 架构[服务器集群]</p>
<p>项目的某个功能用到设计模式，</p>
<h2 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h2><p>应用场景 -&gt; 设计模式 -&gt; 刨析原理 -&gt; 分析实现步骤步骤（图解） -&gt; 代码实现（对比） -&gt; 框架或项目源码分析（找到使用的地方）</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><ol>
<li><strong>代码重用性</strong>（相同功能的代码，不用多次编写）</li>
<li><strong>可读性高</strong>（编程规范性）</li>
<li><strong>可扩展性</strong>（增加新功能时，非常的方便）</li>
<li><strong>可靠性</strong>（增加功能，对原功能没有影响）</li>
<li><strong>程序高内聚，低耦合</strong>（AB模块的依赖性低）</li>
</ol>
<h3 id="金句"><a href="#金句" class="headerlink" title="金句"></a>金句</h3><p>懂了设计模式：就懂了面向对象分析和设计（OOA/D）的精要</p>
<h2 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h2><ol>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转原则</li>
<li>里氏替换原则</li>
<li>开闭原则</li>
<li>迪米特法则（最少知道原则）</li>
<li>复用合成原则</li>
</ol>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类应该只负责<strong>一项职责</strong>。如果负责两个不同的职责，职责1需求变更改变类时，可能造成职责2执行错误。</p>
<p>在类或方法上遵守单一职责原则。</p>
<h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol>
<li>降低类的复杂度</li>
<li>提高类的可读性，可维护性</li>
<li>降低变更的风险</li>
<li>通常应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法足够少，才可以在方法级别保持单一职责原则。</li>
</ol>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖建立在最小的接口上。</p>
<p>改进：将接口Interface1 <strong>拆分成为独立的几个接口</strong>，类与他们需要的接口建立依赖关系，也就是采用接口隔离原则。</p>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><ol>
<li>高层模块不应该依赖底层模块，都应该依赖其抽象。</li>
<li>抽象不因该依赖细节，细节应该依赖抽象。</li>
<li>依赖倒转（倒置）的中心思想时<strong>面向接口编程</strong>。</li>
<li><strong>设计理念：相对于细节（实现类）的多变性，抽象（接口或抽象类）的东西要稳定的多</strong>。</li>
<li>使用接口或抽象类的目的是<strong>指定好规范</strong>，不涉及任何具体操作，把展现细节的任务交给实现类去完成。</li>
</ol>
<h4 id="注意事项与细节"><a href="#注意事项与细节" class="headerlink" title="注意事项与细节"></a>注意事项与细节</h4><ol>
<li>底层模块尽量要有抽象类或接口，或者两者都有，程序稳定性更好。</li>
<li>变量的声明类型尽量都是抽象类或接口，这样变量引用和实际对象间，存在一个缓冲层，利于程序扩展和优化。</li>
<li>继承时遵循里氏替换原则。</li>
</ol>
<h4 id="依赖关系传递的三种方式"><a href="#依赖关系传递的三种方式" class="headerlink" title="依赖关系传递的三种方式"></a>依赖关系传递的三种方式</h4><ol>
<li>接口传递：方法参数声明类型尽量都是抽象类或接口，实现类实现方法。</li>
<li>构造方法传递：（创建一个接口成员）构造器给接口声明类型传递对象。</li>
<li>setter方法传递：（创建一个接口成员）setter给接口声明类型传递对象。</li>
</ol>
<h4 id="应用实例分析"><a href="#应用实例分析" class="headerlink" title="应用实例分析"></a>应用实例分析</h4><ol>
<li>如果我们获取的对象是微信，短信等等，则新增类，同时Perons也要增加相应的接受方法</li>
<li>解决思路，引入一个抽象的接口IReceiver，表示接收者，这样Person类与接口发送，因为Email，WeiXin 等等属于接受的范围，他们各自实现IReceiver接口就ok，这样我们就符合依赖倒转原则。</li>
</ol>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><h4 id="继承的弊端"><a href="#继承的弊端" class="headerlink" title="继承的弊端"></a>继承的弊端</h4><ol>
<li>父类中已经实现好的方法，是在设定规范和契约，如果子类对这些方法任意修改，可能会对整个继承体系造成破环。</li>
<li>继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，父类修改，必须考虑到所有的子类。</li>
</ol>
<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</p>
<p>继承实际上让两个类耦合性增强，在适当的情况下，可以通过<strong>聚合，组合，依赖</strong>来解决问题。</p>
<pre><code>如果父类A 子类B B 继承自 A
如果要修改父类A中的方法
让A类 与 B类 都继承刚高级的 C类。在C类中创建新方法
</code></pre>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>编程中最基础，最重要的设计原则</p>
<p>扩展开放，修改关闭。</p>
<p><strong>当软件需要变化时，扩展软件实体的行为来变化。而不是通过修改已有的代码。</strong></p>
<p>编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>别名：直接朋友原则，最少知道原则</p>
<p>一个类<strong>对自己依赖的类知道的越少越好</strong>，被依赖的类不管多麽复杂，都尽量将逻辑封装在类的内部，对外除了提供public方法，不对外泄露任何信息。</p>
<p><strong>直接朋友</strong>：每个对象都会与其他对象有耦合关系即为朋友关系。耦合的方式有很多，依赖，关联，组合，聚合等。我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，出现在局部变量中的类不是直接朋友，不是直接朋友最好不要以局部变量的形式出现在类的内部。</p>
<p><strong>不要再其他类中的方法中使用自己的类构造的对象，可以在自己类中设计出这个方法。</strong></p>
<h4 id="注意事项和细节-1"><a href="#注意事项和细节-1" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol>
<li>核心：降低类之间的耦合。</li>
<li>每个类都减少了不必要的依赖。（必要的依赖为直接的朋友）</li>
</ol>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>尽量使用合成/聚合的方式，而不是使用继承。</p>
<p>依赖（类似合成）：B类中方法使用A类作为参数。<br>组合：B类成员变量直接newA类<br>聚合：B类成员变量setA类</p>
<h2 id="设计原则的核心思想"><a href="#设计原则的核心思想" class="headerlink" title="设计原则的核心思想"></a>设计原则的核心思想</h2><ol>
<li>找出应用中可能需要变化之处独立出来。</li>
<li>针对接口编程。</li>
<li>为了交互对象之间的松耦合设计而努力。</li>
</ol>
<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li>UML–unified modeling language(统一建模语言)是一种用于软件系统分析和设计的语言工具。</li>
<li>UML本身是一套符号的规定，用于描述软件模型中的各个元素和他们之间的关系，比如类，接口，实现，泛化，依赖，组合，聚合等。</li>
</ol>
<p><img src="https://i.loli.net/2020/09/27/mpQvHI34kNJ9q7X.jpg" alt="UML类图的符号意义.jpg"> </p>
<h3 id="UML图分类"><a href="#UML图分类" class="headerlink" title="UML图分类"></a>UML图分类</h3><ol>
<li>用例图</li>
<li>静态结构图：类图，对象图，包图，组件图，部署图</li>
<li>动态行为图：交互图（时序图与协作图），状态图，活动图</li>
</ol>
<h2 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h2><ol>
<li>用于描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系。</li>
<li>类之间的关系：依赖，泛化（继承），实现，关联，聚合与组合</li>
</ol>
<h3 id="依赖关系-Dependence"><a href="#依赖关系-Dependence" class="headerlink" title="依赖关系(Dependence)"></a>依赖关系(Dependence)</h3><ol>
<li>类中用到了对方，就存在依赖关系。</li>
<li>可以是类的成员属性</li>
<li>可以是方法的返回类型</li>
<li>可以是方法接收的参数类型</li>
<li>方法中使用到</li>
</ol>
<h3 id="泛化关系（Generalization）"><a href="#泛化关系（Generalization）" class="headerlink" title="泛化关系（Generalization）"></a>泛化关系（Generalization）</h3><p>其实就是继承关系，是依赖关系的特例。</p>
<h3 id="实现关系（Implementation，Realization）"><a href="#实现关系（Implementation，Realization）" class="headerlink" title="实现关系（Implementation，Realization）"></a>实现关系（Implementation，Realization）</h3><p>A类实现B类，是依赖关系的特例。</p>
<h3 id="关联关系（Association）"><a href="#关联关系（Association）" class="headerlink" title="关联关系（Association）"></a>关联关系（Association）</h3><p>是类与类之间的联系，是依赖关系的特例。</p>
<p>关联具有到航性：即双向关系或单项关系</p>
<p>关系具有多重性：1表示有且仅有一个，0…表示0个或多个，“0，1”表示0个多一个，“n…m”表示n到m个都可以，“m…”表示至少m个。</p>
<h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>表示的是整体和部分的关系，整体与部分是可以分开的。是关联关系的特例，具有关联的导航性与多重性。</p>
<p>类似定义成员变量和set方法。</p>
<h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>整体和部分是不可分离的，升级为组合关系。</p>
<p>类似成员变量new对象。</p>
<h1 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的概述"><a href="#设计模式的概述" class="headerlink" title="设计模式的概述"></a>设计模式的概述</h2><p>设计模式分三种类型，共23种设计模式。</p>
<h3 id="掌握设计模式的层次"><a href="#掌握设计模式的层次" class="headerlink" title="掌握设计模式的层次"></a>掌握设计模式的层次</h3><p><img src="https://i.loli.net/2020/09/28/lfCRadB4TONp9bG.jpg" alt="掌握设计模式的层次.jpg"></p>
<h3 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h3><ol>
<li>创建型模式：单例模式，抽象工厂模式，原型模式，建造者模式，工厂模式。</li>
<li>结构型模式：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。</li>
<li>行为型模式：模板方法模式，命令模式，访问者模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式（责任链模式）</li>
</ol>
<h2 id="单例模式-看study-java的面试题部分"><a href="#单例模式-看study-java的面试题部分" class="headerlink" title="单例模式-看study-java的面试题部分"></a>单例模式-看study-java的面试题部分</h2><p>保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。</p>
<h3 id="单例模式有八种方式"><a href="#单例模式有八种方式" class="headerlink" title="单例模式有八种方式"></a>单例模式有八种方式</h3><ol>
<li><strong>饿汉式（静态常量）</strong></li>
<li><strong>饿汉式（静态代码块）</strong></li>
<li>懒汉式（线程不安全）</li>
<li>懒汉式（线程安全，同步方法）</li>
<li>懒汉式（线程安全，同步代码块）</li>
<li><strong>双重检查</strong></li>
<li><strong>静态内部类</strong></li>
<li><strong>枚举</strong></li>
</ol>
<h3 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>构造器私有化（防止new）</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/lwTHAduB6DvfpZK.jpg" alt="饿汉式-静态变量.jpg"></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>优点：写法简单，在类装载是完成实例化。避免了线程公布问题</li>
<li>缺点：在类装载时完成实例化，没有达到懒加载（Lazy Loading）的效果。如果从始至终从未使用过实例，会造成内存的浪费。</li>
<li>结论：可用，但是可能会造成内存浪费。</li>
</ol>
<h3 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h3><ol>
<li>构造器私有化（防止new）</li>
<li>类的内部创建对象变量</li>
<li>在静态代码块中，实例化对象</li>
<li>向外暴露一个静态的公共方法</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/28DIqLhlwWSpyEe.jpg" alt="饿汉式-静态代码块.jpg"></p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>与上面方式类似，只不过将类的实例化放在静态代码块中，也是在类装载时执行静态代码块中的代码，初始化类的实例。优缺点与上面相同。</li>
<li>结论：可用，但是可能内存浪费。</li>
</ol>
<h3 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h3><ol>
<li>构造器私有化</li>
<li>本类内部创建变量</li>
<li>共有的静态方法，当使用到该方法时，才去创建instance，返回实例对象</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/swJWAPpTCrdvgbz.jpg" alt="懒汉式-线程不安全.jpg"></p>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>起到了Lazy Loading的效果，但是只能在单线程下使用。</li>
<li>结论：在实际开发中，不要使用这种方式。</li>
</ol>
<h3 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h3><ol>
<li>构造私有化</li>
<li>本类内部创建变量</li>
<li>共有的静态方法，加入同步处理的代码，当使用到该方法时，才去创建instance，返回实例对象</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/Zhz2mljsDw1iRCJ.jpg" alt="懒汉式-线程安全同步方法.jpg"></p>
<h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>解决了线程不安全问题</li>
<li>效率太低，每次执行getInstance()方法都要同步。</li>
<li>结论：在实际开发中，不推荐使用这种方式。</li>
</ol>
<h3 id="懒汉式（线程安全，同步代码块）"><a href="#懒汉式（线程安全，同步代码块）" class="headerlink" title="懒汉式（线程安全，同步代码块）"></a>懒汉式（线程安全，同步代码块）</h3><ol>
<li>构造私有化</li>
<li>本类内部创建变量</li>
<li>共有的静态方法，加入同步处理的代码块，当使用到该方法时，才去创建instance，返回实例对象</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/qxPXbRVd4sa9kDG.jpg" alt="懒汉式-同步代码块.jpg"></p>
<h4 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>这种同步比更不能起到线程同步的作用。假如一个线程进入了if判断语句块，另一个线程通过了这个判断语句，便会产生多个实例。</li>
<li>结论：在实际开发中，不能使用这种方式。</li>
</ol>
<h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><ol>
<li>构造私有化</li>
<li>本类内部创建变量，使用volatile修饰，有修改直接到主存里面</li>
<li>共有的静态方法，双重检查，解决线程安全，同时解决懒加载。</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/f3aWYZM5xbEV1go.jpg" alt="双重检查.jpg"></p>
<p>使用volatile修饰成员变量。</p>
<h4 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>Double-Check概念是多线程开发中常使用到的。可以保证线程安全。</li>
<li>线程安全，延迟加载，效率较高。</li>
<li>结论：在实际开发中，推荐使用这种单例设计模式。</li>
</ol>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><ol>
<li>构造私有化</li>
<li>静态内部类，一个静态属性Singleton</li>
<li>静态共有方法直接返回SingletonInstance.INSTANCE。</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/CVc3qFDhETH9pO1.jpg" alt="单例-静态内部类.jpg"></p>
<p>类装载的时候，内部类不会被装载。只有调用内部类的时候才会装载一次。</p>
<h4 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>采用类装载机制保证初始化实例时只有一个线程。</li>
<li>类的静态属性只会在第一次加载类的时候初始化，JVM保证线程安全。</li>
<li>优点：线程安全，利用静态内部类实现延迟加载，效率高。</li>
<li>结论：推荐使用。</li>
</ol>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="https://i.loli.net/2020/09/28/leuQHjMXGkDYF2A.jpg" alt="单例-枚举.jpg"></p>
<h4 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>借助JDK1.5中添加的枚举来实现单例模式，避免多线程同步，还能防止反序列化才重新创建新的对象。</li>
<li>结论：推荐使用。</li>
</ol>
<h3 id="单例模式注意事项"><a href="#单例模式注意事项" class="headerlink" title="单例模式注意事项"></a>单例模式注意事项</h3><ol>
<li>单例模式保证了系统内存中，该类只存在一个对象。对于一些频繁创建销毁的对象，单例模式可以提高系统性能。</li>
<li>实例化单例类时，要使用相应的获取对象的方法。</li>
<li>单例模式使用场景：频繁的进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多（重量级对象），但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）</li>
</ol>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>定义一个创建对象的类，来封装实例化对象的行为。</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式：将可变的部分从程序中抽象出来分离成算法接口，在该接口下分别封装一系列算法实现。</p>
<p><img src="https://i.loli.net/2020/09/17/N4b3qvGBMWDZoLu.jpg" alt="策略模式.jpg"></p>
<h3 id="设计策略模式："><a href="#设计策略模式：" class="headerlink" title="设计策略模式："></a>设计策略模式：</h3><p>Hero抽象类：</p>
<pre><code>public abstract class Hero &#123;
    //英雄的名称
    private String heroName;
    //英雄的召唤师技能的接口（组合关系,需要使用时，需要传入一个具体的技能对象）
    private ISkill iSkill;

    //自我介绍的方法
    public abstract void display();
    //普通攻击的方法
    public abstract void normalAttack();
    //召唤师技能的使用方法
    public void skill()&#123;
        iSkill.useSkill();
    &#125;
</code></pre>
<p>HouYi实现类：</p>
<pre><code>public class HouYi extends Hero&#123;
    //编写构造方法
    public HouYi() &#123;
        super.setHeroName(&quot;后羿&quot;);
    &#125;
</code></pre>
<p>ISkill接口：</p>
<pre><code>public interface ISkill &#123;
    //使用召唤师技能的方法
    public abstract void useSkill();
&#125;
</code></pre>
<p>JiPao接口实现类：</p>
<pre><code>public class JiPao implements ISkill &#123;
    @Override
    public void useSkill() &#123;
        System.out.println(&quot;疾跑技能。增加移速。&quot;);
    &#125;
&#125;
</code></pre>
<p>调用：</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol>
<li>找出需要变化的部分，独立出来做成算法接口。</li>
<li>面向接口编程，而不是面向实现。</li>
<li>多用组合，少用继承。</li>
</ol>
<p>优点：</p>
<ol>
<li><strong>使用组合</strong>，而不单单继承，使得架构更加灵活。</li>
<li>富有弹性，<strong>可以较好的应对未来的变化</strong>。（开-闭原则）</li>
<li>更好的代码复用性。（相对于继承）</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加了对象的数量（每个接口都做成一个对象）。</li>
</ol>
<p>​    </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/genuinenonage/genuinenonage.github.io.git/2020/09/17/mysql/Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/genuinenonage/genuinenonage.github.io.git/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/genuinenonage/genuinenonage.github.io.git/2020/09/17/mysql/Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">Mysql</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-09-17 11:04:00 / 修改时间：17:59:10" itemprop="dateCreated datePublished" datetime="2020-09-17T11:04:00+08:00">2020-09-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="索引数据结构红黑树，Hash表，B-Tree"><a href="#索引数据结构红黑树，Hash表，B-Tree" class="headerlink" title="索引数据结构红黑树，Hash表，B+Tree"></a>索引数据结构红黑树，Hash表，B+Tree</h2><p>二叉树，红黑树，Hash表，B-Tree。</p>
<h3 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h3><p>索引是帮助Mysql高效获取数据的排好序的数据结构。</p>
<p>红黑树本质也是二叉树，不过可以自动平衡，不让二叉树一边叶子过长。</p>
<p>Hash：哈希算法：哈希散列值结果就是磁盘文件地址。</p>
<ul>
<li>不管表记录有多少，都能快速定位表数据的位置。</li>
<li>但是不能很好解决范围查找。</li>
</ul>
<p>B-Tree： </p>
<ul>
<li>叶子节点具有相同的深度，存放数据。</li>
<li>所有索引元素不重复。</li>
<li>节点中的数据索引从左到右递增排列。</li>
</ul>
<p>B+Tree：每个数据节点都能快速找到相邻节点（节点之间双向指针）。</p>
<ul>
<li>   非叶子节点不存储data，只存储索引（非叶子节点冗余索引），可以放更多的索引。</li>
<li>   叶子界定啊包含所有索引字段</li>
<li> 叶子节点用指针链接，提高区间访问的性能。</li>
<li>提高范围查找的性能。</li>
</ul>
<h3 id="B-Tree与B-Tree的不同："><a href="#B-Tree与B-Tree的不同：" class="headerlink" title="B-Tree与B+Tree的不同："></a>B-Tree与B+Tree的不同：</h3><ul>
<li><p>B+Tree叶子节点之间增加双向指针，B-Tree叶子节点之间没有。</p>
</li>
<li><p>B+Tree非叶子简单不存放数据，只存放索引（所以造成冗余索引）；B-Tree所有节点都存放数据，没有冗余索引。</p>
</li>
<li><p>在树的高度相同的情况下，B+Tree能放的数据更多。</p>
</li>
</ul>
<h2 id="千万级数据表快速查找"><a href="#千万级数据表快速查找" class="headerlink" title="千万级数据表快速查找"></a>千万级数据表快速查找</h2><p>Mysql底层数据结构：B+Tree（B-Tree变种）：多叉查找(x&lt;y&lt;=z]</p>
<p>B+Tree的索引每个节点大小：16kb</p>
<p>数据库有存储引擎的概念。表级别的概念。INNODB/MYISAM</p>
<p>MYISAM（非聚集索引）:</p>
<pre><code>frm表结构信息
MYD存储数据
MYI存储B+Tree的索引。
</code></pre>
<p>INNODB（聚集索引）: </p>
<pre><code>frm表结构信息
ibd索引和数据在一起
</code></pre>
<h2 id="基于B-Tree高性能索引"><a href="#基于B-Tree高性能索引" class="headerlink" title="基于B+Tree高性能索引"></a>基于B+Tree高性能索引</h2><p>INNODB索引实现（聚集）</p>
<ul>
<li>表数据文件本身就是按B+Tree组织的一个索引结构的文件。</li>
<li>聚集索引：叶子节点包含了完整的数据记录。</li>
<li>为什么INNODB表必须有主键，并且建议整型自增。<ul>
<li>如果没有主键，mysql找字段中的唯一字段作为索引，如果都没有，MySQL会创建一个隐藏列。不要增加MySQL的性能负担。</li>
<li>主键不要使用UUID（UUID不是整形也不是自增），B+树经常比大小，整形比大小快，上产环境高速SSD成本高。</li>
<li>在B+Tree数据结构中，自增树插入对B+Tree树的分裂小（B+Tree会自动优化分裂树的结构，保证在一定的规范下），随机树插入对B+Tree的分裂大</li>
</ul>
</li>
<li>为什么主键索引结构叶子节点存储的是主键值？（一致性和节省存储空间）</li>
</ul>
<h2 id="联合索引底层数据结构"><a href="#联合索引底层数据结构" class="headerlink" title="联合索引底层数据结构"></a>联合索引底层数据结构</h2><p>KEY ‘idx_name_age_position’ （’name’,’age’,’position’) USING BTREE</p>
<p>根据索引字段的顺序进行比较。先比较name后age后position</p>
<p><img src="https://i.loli.net/2020/09/17/pN3KRCx4UtlBEPi.jpg" alt="联合索引底层数据结构.jpg"></p>
<p>最左前缀优化：因为联合索引底层已经实现了</p>
<pre><code>explain select * from employees where name=&#39;Bill&#39; and age=31;
</code></pre>
<p>还有很多的知识需要学习。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/genuinenonage/genuinenonage.github.io.git/2020/09/12/java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/genuinenonage/genuinenonage.github.io.git/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/genuinenonage/genuinenonage.github.io.git/2020/09/12/java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Java多线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-12 13:25:00" itemprop="dateCreated datePublished" datetime="2020-09-12T13:25:00+08:00">2020-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-08 15:50:39" itemprop="dateModified" datetime="2021-02-08T15:50:39+08:00">2021-02-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="实现多线程"><a href="#实现多线程" class="headerlink" title="实现多线程"></a>实现多线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>正在运行的程序。  </p>
<ul>
<li>系统进行资源分配和调用的独立单位。</li>
<li>有自己的内存空间和系统资源。</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>进程中的单个顺序控制流，是一条执行路径。</p>
<ul>
<li>单线程：一个进程只有一条执行路径，成为单线程程序。</li>
<li>多线程：一个进程有多条执行路径，成为多线程程序。</li>
</ul>
<p>举例：</p>
<ul>
<li>单线程：记事本设置没有完成，不能使用编辑文本。</li>
<li>多线程：扫雷程序，时间在运行，同时可以游玩。</li>
</ul>
<h3 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h3><p>两种方法。</p>
<h4 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h4><pre><code>* 定义一个类MyThread继承Thread类
* 在MyThread类中重写run()方法
* 创建MyThread类对象
* 启动线程
</code></pre>
<h6 id="Thread方法"><a href="#Thread方法" class="headerlink" title="Thread方法"></a>Thread方法</h6><ol>
<li>public void start()</li>
<li>public void run()</li>
<li>public final void setName(String name)</li>
<li>public final void setPriority(int priority)</li>
<li>public final void setDaemon(boolean on)</li>
<li>public final void join(long millisec)  等待该线程终止的时间最长为 millis 毫秒。</li>
<li>public void interrupt()   中断线程。</li>
<li>public final boolean isAlive()</li>
</ol>
<p>静态方法</p>
<ol>
<li>public static void yield()  暂停当前正在执行的线程对象，并执行其他线程。</li>
<li>public static void sleep(long millisec)</li>
<li>public static Thread currentThread()  返回对当前正在执行的线程对象的引用。</li>
</ol>
<h4 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h4><pre><code>* 定义一个类MyRunnable实现Runnable接口。
* 重写run()方法。
* 创建MyRunnable类对象。
* 创建Thread类的对象，把MyRunnable对象作为构造方法的参数。
* 启动线程。
</code></pre>
<h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><ul>
<li>为什么要重写run()方法？<ul>
<li>应为run()用来封装被线程执行的代码。</li>
</ul>
</li>
<li>run()方法和start()方法的区别？<ul>
<li>run()：封装线程执行的代码，直接调用，相当于普通方法的调用。</li>
<li>start()：启动线程，然后由JVM调用此线程的run()方法。</li>
</ul>
</li>
<li>实现Runnable接口的好处：<ul>
<li>避免了Java单继承的局限性，可以继承想要的父类。</li>
<li>适合多个相同的程序代码去处理同一个资源，把线程和程序代码、数据有效分离，较好的体现了面向对象的设计思想。</li>
</ul>
</li>
</ul>
<h5 id="设置和获取线程名称"><a href="#设置和获取线程名称" class="headerlink" title="设置和获取线程名称"></a>设置和获取线程名称</h5><p>Thread类中设置和获取线程名称的方法：</p>
<ul>
<li>void setName(String name)：将此线程的名称更改为参数name。</li>
<li>String getName()：返回此线程的名称。</li>
<li>通过构造方法可以设置线程名称。</li>
</ul>
<p>如何获取main()方法所在的线程名称？</p>
<ul>
<li>public static Thread currentThread()：返回对当前正在执行的线程对象的引用</li>
</ul>
<h4 id="3-Callable和Future创建线程"><a href="#3-Callable和Future创建线程" class="headerlink" title="3. Callable和Future创建线程"></a>3. Callable和Future创建线程</h4><pre><code>1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。
2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。
</code></pre>
<h3 id="创建线程的三种方式对比"><a href="#创建线程的三种方式对比" class="headerlink" title="创建线程的三种方式对比"></a>创建线程的三种方式对比</h3><ol>
<li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
<li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li>
</ol>
<h5 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h5><p>线程有两种调度模型  </p>
<ul>
<li>分时调度模型：</li>
<li>抢占式调度模型：</li>
</ul>
<p>Java使用的是抢占式调度模型</p>
<p>Thread类中设置和获取线程优先级的方法（默认线程优先级都为5）</p>
<ul>
<li>public final int getPriority()：返回此线程的优先级。</li>
<li>public findl void setPriority(int newPriority)：更改此线程的优先级。  </li>
</ul>
<p>注意事项：</p>
<ul>
<li>线程优先级是有范围的（MAX_PRIORITY=10,MIN_PRIORITY=1,NORM_PRIORITY=5）</li>
<li>线程优先级高，仅仅是获取CPU时间片的几率高。</li>
</ul>
<h5 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h5><ul>
<li>static void sleep(long mmillis)：是当前正在执行的线程停留（暂停执行）指定的毫秒数。</li>
<li>void join()：等待这个线程死亡，join()之后的线程才能执行</li>
<li>void setDaemon(Boolean on)：此线程标记为守护线程，当运行的线程都是守护线程是，Java虚拟机退出。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>主线程运行完，守护线程不会立即消失，所以JVM不会立即停止运行。</li>
<li>join()之后的线程，只有join()对应的线程运行完才会执行。</li>
</ul>
<h5 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h5><p><img src="https://i.loli.net/2020/09/21/hXj6CeZJkxdfHu4.png" alt="Java集合框架图.PNG"></p>
<ol>
<li>新建：创建线程对象。</li>
<li>就绪（仅有执行资格）：start()；其他线程抢走CPU的执行权；sleep()方法时间到/阻塞方式结束。</li>
<li>运行：抢到CPU的执行权。</li>
<li>死亡：run()结束；stop()。</li>
<li>阻塞：sleep()/其他阻塞式方法。</li>
</ol>
<h2 id="线程的几个主要概念"><a href="#线程的几个主要概念" class="headerlink" title="线程的几个主要概念"></a>线程的几个主要概念</h2><p>在多线程编程时，你需要了解以下几个概念：</p>
<ul>
<li>线程同步</li>
<li>线程间通信</li>
<li>线程死锁</li>
<li>线程控制：挂起、停止和恢复</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/genuinenonage/genuinenonage.github.io.git/2020/09/10/spring/spring%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/genuinenonage/genuinenonage.github.io.git/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/genuinenonage/genuinenonage.github.io.git/2020/09/10/spring/spring%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">spring学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-10 17:19:00" itemprop="dateCreated datePublished" datetime="2020-09-10T17:19:00+08:00">2020-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-10-16 12:23:33" itemprop="dateModified" datetime="2020-10-16T12:23:33+08:00">2020-10-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><p>Spring框架是一系列应用框架的核心，是整合其他应用框架的基座。同时还是SpringBoot的基础。里面包含了Spring，SpringMVC，SpringData（事务），SpringTest等等。</p>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>IOC负责降低代码间的依赖关系，使项目灵活度更高，可复用性更强。</p>
<p>AOP让方法间的各个部分更加独立，达到统一调用执行，使后期维护更加方便。</p>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>对Servlet和JSP的API进行了封装，并在此基础上进一步加强。它推出的一套注解，可以更轻松的做表现层开发。</p>
<h3 id="SpringData"><a href="#SpringData" class="headerlink" title="SpringData"></a>SpringData</h3><p>一组技术合集。里面包含了JDBC，Data JPA，Data Redis，Data Mongodb，Data Rabbit，Data ElasticSearch等等。合集中的每一项都是针对不同数据存储做的简化封装。</p>
<h3 id="SpringTest"><a href="#SpringTest" class="headerlink" title="SpringTest"></a>SpringTest</h3><p>对Junit单元测试的整合。在开发中以及开发后期进行测试时，直接使用Junit结合spring一起测试。</p>
<h1 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring"></a>Spring</h1><h3 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h3><p>Spring是分层的JavaSE/EE应用的轻量级开源框架，IOC和AOP为内核，提供了展现层MVC和持久层Spring JDBC以及业务层事务管理等众多企业级应用技术，还能整合众多第三方框架和类库。主键成为使用最多的JavaEE企业应用开源框架。</p>
<h3 id="spring的优势"><a href="#spring的优势" class="headerlink" title="spring的优势"></a>spring的优势</h3><ul>
<li>方便解耦</li>
<li>AOP编程的支持</li>
<li>声明式事务的支持</li>
<li>方便层序的测试</li>
<li>方便集成各种优秀的框架</li>
<li>降低JavaAPI的使用难度</li>
<li>Java源码是经典设计范例</li>
</ul>
<h3 id="spring体系框架"><a href="#spring体系框架" class="headerlink" title="spring体系框架"></a>spring体系框架</h3><p><img src="https://i.loli.net/2020/09/22/oYXJAV9mB4dh36D.jpg" alt="spring体系框架.jpg"></p>
<p>IOC：控制反转，对象创建的权力转移了，不在new了，交由spring管理。<br>AOP：日志与异常的代码，动态的切入业务类。</p>
<p>以前使用EJB，臃肿、低效的开发模式。</p>
<p>开发分三层：</p>
<ul>
<li>表现层：整合Struts</li>
<li>业务层：事务管理，记录日志</li>
<li>持久层：整合Hibernate，JdbcTemplate</li>
</ul>
<h2 id="Spring的IOC"><a href="#Spring的IOC" class="headerlink" title="Spring的IOC"></a>Spring的IOC</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>控制反转，把创建对象的权力交给框架。包括依赖注入和依赖查找。</p>
<p>ioc的作用：削减计算机程序的耦合（减少代码间的依赖关系）。</p>
<h3 id="设计模式-工厂模式"><a href="#设计模式-工厂模式" class="headerlink" title="设计模式-工厂模式"></a>设计模式-工厂模式</h3><p>最常用的实例化对象模式，用工厂中的方法代替new创建对象的一种设计模式。</p>
<h3 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a>IOC和DI</h3><h4 id="IOC-Inversion-of-Control"><a href="#IOC-Inversion-of-Control" class="headerlink" title="IOC-Inversion of Control"></a>IOC-Inversion of Control</h4><p>控制反转。不是一个技术，而是一个思想。</p>
<p>对象创建的权力转移了，不在new了，交由spring管理。</p>
<p>作用：削减代码间的耦合。</p>
<p>实现思想：利用工厂模式，把创建对象代码从具体类中剥离出去，交由工厂完成，从而降低代码间的依赖关系。</p>
<p>耦合分类：耦合程序间的依赖关系</p>
<ol>
<li>内容耦合：修改时需要修改源码</li>
<li>公共耦合：开发时需要限制作用范围</li>
<li>外部耦合</li>
<li>控制耦合：</li>
<li>标记耦合</li>
<li>数据耦合</li>
<li>非直接耦合</li>
</ol>
<p>为什么要解耦：</p>
<ul>
<li>耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用原则：<ul>
<li>如果模块间必然存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。</li>
</ul>
</li>
</ul>
<h4 id="DI-Dependency-Injection"><a href="#DI-Dependency-Injection" class="headerlink" title="DI-Dependency Injection"></a>DI-Dependency Injection</h4><p>依赖注入。是spring框架核心IOC的具体实现。</p>
<h3 id="IOC-细节"><a href="#IOC-细节" class="headerlink" title="IOC 细节"></a>IOC 细节</h3><p>获取spring的IOC核心容器，并根据id获取对象</p>
<p>Application||Context的常用的三个常用的实现类：</p>
<ol>
<li>ClassPathXmlApplicationContext:可以加载类路径下的配置文件，要求配置文件必须在类路径下。</li>
<li>FileSystemXmlApplicationContext:可以加载磁盘任意路径下的配置文件（必须有访问权限），使用绝对路径。</li>
<li>AnnotationConfigApplicationContext:用于读取注解创建容器的。</li>
</ol>
<p>核心容器的两个接口：</p>
<ol>
<li>ApplicationContext（单例对象适用）：在构建容器时，创建对象，采取立即加载的方式。只要一读取完配置文件就创建配置文件中配置的对象。</li>
<li>BeanFactory（多例对象适用）：在构建核心容器时，创建对象，采用延迟加载的方式。什么时候根据id获取对象，才真正的获取对象。</li>
</ol>
<h3 id="bean细节"><a href="#bean细节" class="headerlink" title="bean细节"></a>bean细节</h3><h4 id="创建bean的三种方式"><a href="#创建bean的三种方式" class="headerlink" title="创建bean的三种方式"></a>创建bean的三种方式</h4><ol>
<li><p>默认构造函数创建：在spring的配置文件中使用bean标签，配以id和class属性，没有其他属性和标签时，采用默认构造函数创建bean对象。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com...AccountServiceImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用普通工厂中的方法创建对象（使用某个类的方法创建对象，并存入spring容器）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;instanceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com...InstanceFactory&quot;</span> /&gt;</span></span><br><span class="line">2. <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;instanceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getAccountService&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>工厂中静态方法（某个类中静态方法创建对象，并存入spring容器）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com...StaticFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getAccountService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="bean对象的作用范围"><a href="#bean对象的作用范围" class="headerlink" title="bean对象的作用范围"></a>bean对象的作用范围</h4><p>bean标签的scope属性：用于指定bean的作用范围</p>
<p>取值：</p>
<ol>
<li>singleton：单例的（默认值）</li>
<li>prototype：多例的</li>
<li>request：作用于web应用的请求范围</li>
<li>session：作用于web应用的会话范围</li>
<li>global-session：作用于集群环境的会话范围（全局会话范围），不是集群环境时，就是session</li>
</ol>
<h4 id="bean-对象的生命周期"><a href="#bean-对象的生命周期" class="headerlink" title="bean 对象的生命周期"></a>bean 对象的生命周期</h4><ol>
<li><p>单例对象</p>
<ol>
<li>出生：当容器对象创建时</li>
<li>容器还在，对象一直在</li>
<li>容器销毁，对象消亡</li>
<li>结论：单例对象生命周期和容器相同。</li>
</ol>
</li>
<li><p>多例对象</p>
<ol>
<li>出生：当使用对象时创建</li>
<li>对象使用时，一直在</li>
<li>当对象长时间不用，且没有别的对象引用时，GC回收。</li>
</ol>
</li>
</ol>
<h3 id="spring中的依赖注入"><a href="#spring中的依赖注入" class="headerlink" title="spring中的依赖注入"></a>spring中的依赖注入</h3><p>当前类需要使用到其他类的对象，由spring提供，依赖关系的维护称之为依赖注入。</p>
<p>能注入的数据有3类：</p>
<ol>
<li>基本类型和String</li>
<li>其他bean类型（在配置文件中或者注解配置过的bean）</li>
<li>复杂类型/集合类型<ol>
<li>list结构集合注入标签：list，array，set</li>
<li>Map结构结合注入标签：map，props</li>
</ol>
</li>
</ol>
<p>注入的方式3中：</p>
<ol>
<li>构造函数提供：编写带参构造函数<ol>
<li>使用标签constructor-arg</li>
<li>位置：bean标签内部</li>
<li>属性：<ol>
<li>type：构造函数中某个或某些参数的类型</li>
<li>index：构造函数中指定索引位置的参数赋值</li>
<li>name：构造函数中指定名称的参数赋值（以上三个用于指定给构造函数中那个参数赋值）</li>
<li>value：提供基本类型和String类型的数据</li>
<li>ref：指定其他的bean类型数据。spring的IOC核心容器中出现过的bean对象</li>
</ol>
</li>
<li>优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。</li>
<li>弊端：改变了bean对象的实例化方式，在创建对象时，如果用不到这些方式也会提供。</li>
</ol>
</li>
<li>set方法提供（需要给成员变量写set方法）<ol>
<li>标签：property；复杂类型/集合类型可以在内部使用对应的标签。</li>
<li>位置：bean标签的内部</li>
<li>属性：<ol>
<li>name：指定注入时set方法名称（setUserName–&gt;userName）</li>
<li>value</li>
<li>ref</li>
</ol>
</li>
<li>优势：创建对象是没有明确的限制，可以直接使用默认构造函数。</li>
<li>弊端：如果某个成员必须有值，则获取对象时可能set方法没有执行。</li>
</ol>
</li>
<li>注解提供</li>
</ol>
<h2 id="spring基于注解的IOC"><a href="#spring基于注解的IOC" class="headerlink" title="spring基于注解的IOC"></a>spring基于注解的IOC</h2><h3 id="曾经的xml配置："><a href="#曾经的xml配置：" class="headerlink" title="曾经的xml配置："></a>曾经的xml配置：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com...AccountServiceImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="用于创建对象"><a href="#用于创建对象" class="headerlink" title="用于创建对象"></a>用于创建对象</h4><ol>
<li>@Component：用于把当前对象存入spring容器中。<ol>
<li>属性：value：用于指定bean的id。默认值为当前类名，首字母小写<ol>
<li>需要在配置文件中导入context命名空间。<strong>告知spring在创建容器时要扫描的包</strong>，配置需要的标签不是在 nbeans的约束中，在context名称空间和约束中 &lt;context:component-scan base-package=”com.genuine”/&gt;</li>
</ol>
</li>
</ol>
</li>
<li>@Controller：表现层</li>
<li>@Service：业务层</li>
<li>@Repository：持久层</li>
<li>2-4三个注解的作用和属性与Component时一模一样的。spring框架提供明确的三层使用是为了使三层对象更清晰。</li>
</ol>
<h4 id="用于注入数据"><a href="#用于注入数据" class="headerlink" title="用于注入数据"></a>用于注入数据</h4><ol>
<li>@Autowired：自动按照类型注入<ol>
<li>只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配就注入成功</li>
<li>如果有多个同类型。先根据对象类型查找后根据变量名称查找。</li>
</ol>
</li>
<li>@Qualifier（与Autowired一起使用）：在按照类中注入的基础上，再按照名称注入，value用于指定bean的id，在方法中可以单独使用。</li>
<li>@Resource：name属性直接指定bean 的id。</li>
<li>@Value：用于注入基本类型和String类型的数据<ol>
<li>属性：value：用于指定数据的值。</li>
<li>可以使用spring中的SpEL（spring的el表达式）。SqEL的写法：${表达式}</li>
</ol>
</li>
</ol>
<p>总结：以上1-3个只能注入其他bean类型的数据，基本类型和String类型无法使用上述注解实现。集合类型的注入只能通过xml来实现。</p>
<h4 id="用于改变作用范围"><a href="#用于改变作用范围" class="headerlink" title="用于改变作用范围"></a>用于改变作用范围</h4><p>@Scope：用于指定bean的作用范围。属性value指定范围取值。常用值：singleton，prototype。</p>
<h4 id="和生命周期相关（了解）"><a href="#和生命周期相关（了解）" class="headerlink" title="和生命周期相关（了解）"></a>和生命周期相关（了解）</h4><ol>
<li>@ProDestroy：用于销毁方法上</li>
<li>@PostConstruct：用于初始化方法上</li>
</ol>
<h4 id="基于xml的ioc案例"><a href="#基于xml的ioc案例" class="headerlink" title="基于xml的ioc案例"></a>基于xml的ioc案例</h4><p>需要粘钩：使用dbutils的queryrunner数据库操作方法，链接c3p0数据库连接池。</p>
<p>spring中ioc的常用注解</p>
<p>xml方式和注解方式实现CRUD</p>
<p>基于注解的ioc案例，使用纯注解的方式实现</p>
<p>spring和Junit整合</p>
<h3 id="spring配置类"><a href="#spring配置类" class="headerlink" title="spring配置类"></a>spring配置类</h3><p>作用与bean.xml是一样的。</p>
<ol>
<li><p>@Configuration：指定当前类是一个配置类。</p>
<ol>
<li>当使用annotationconfigration（**.class）如果没有class文件，就要在类中加入该注解。</li>
</ol>
</li>
<li><p>@ComponentScan：通过注解指定spring在创建容器时要扫描的包。</p>
<ol>
<li><p>属性basePackages：指定创建容器时要扫描的包。</p>
</li>
<li><p>属性value：和basePackages的作用是一样的。</p>
</li>
<li><p>当时使用了此注解，就等同于在xml中配置了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.genuine&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>@Bean：把当前方法的返回值作为bean对象，存入spring的ioc容器中。</p>
<ol>
<li>属性name：指定bean的id，默认值是当前方法的名称。</li>
<li>如果方法有参数，spring框架会去容器中查找有没有可用的bean对象，查找的方式和Autowired注解的作用相同。</li>
</ol>
</li>
<li><p>@Import(JdbcConfig.class)： 可以在主配置类中，导入其他的子配置类。</p>
</li>
<li><p>@PropertySource(“classpath:**.properties”)：指定properties文件的位置。</p>
<ol>
<li>属性value：指定文件的名称和路径。关键字classpath，表示类路径下。</li>
</ol>
</li>
</ol>
<h3 id="spring整合Junit单元测试"><a href="#spring整合Junit单元测试" class="headerlink" title="spring整合Junit单元测试"></a>spring整合Junit单元测试</h3><ol>
<li>导入spring整合junit的jar</li>
<li>使用junit提供的一个注解把原有的main方法替换了，替换成@RunWith(SpringJunit4ClassRunner.class)</li>
<li>告知spring的运行器，spring和ioc创建居于xml还是注解，并说明位置@contextConfiguration<ol>
<li>localtions：指定xml文件的位置，加上classpath关键字。</li>
<li>classes：指定注解类所在的位置。</li>
</ol>
</li>
</ol>
<p>使用spring5.x时，要使用junit的jar包4.12版本及以上。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>连接池在项目启动的时候会创建一些连接，从而避免了数据库连接的操作。</p>
<p>在项目启动的时候，线程池统一管理这些线程。</p>
<ol>
<li>前置通知： 开始事务</li>
<li>后置通知：提交事务</li>
<li>异常通知：回滚</li>
<li>最终通知：关闭连接</li>
</ol>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>特点：字节码随用随创建，随用随加载</p>
<p>作用：不修改源码的基础上对方法增强</p>
<p>分类：</p>
<ol>
<li>基于接口的动态代理</li>
<li>基于子类的动态代理</li>
</ol>
<h4 id="基于接口的动态代理："><a href="#基于接口的动态代理：" class="headerlink" title="基于接口的动态代理："></a>基于接口的动态代理：</h4><ol>
<li>涉及的类：Proxy</li>
<li>提供者：JDK官方</li>
</ol>
<p>如何创建代理对象：</p>
<ol>
<li>使用Proxy类中的newProxyInstance方法</li>
</ol>
<p>创建代理对象的要求：</p>
<ol>
<li>被代理类最少实现一个接口，如果没有则不能使用</li>
</ol>
<p>newProxyInstance方法的参数：</p>
<ol>
<li>ClassLoader：类加载器。用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。</li>
<li>Class[]：字节码数组。用于让代理对象和被代理对象拥有相同的方法。固定写法。</li>
<li>InvocationHandler：用于提供增强的代码。一般都是一些接口地实现类，通常是匿名内部类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(producer.getClass().getClassLoader(),producer.getClass().getIntergaces(),</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">InvocationHander</span>()&#123;</span><br><span class="line">         <span class="comment">//作用：执行被代理对象的任何接口方法都会经过该方法，方法参数的意义：proxy代理对象的引用，method当前方法的执行，args当前方法所需的参数，return和被代理对象方法相同的返回值。</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy,Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h4><p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifacId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifacId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1_3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>设计的类：Enhancer</li>
<li>提供者：第三方cglib</li>
</ol>
<p>如何创建代理对象：</p>
<ol>
<li>使用Enhancer类中的create方法</li>
</ol>
<p>创建代理对象的要求：</p>
<ol>
<li>被代理类不是最终类。</li>
</ol>
<p>create方法的参数：</p>
<ol>
<li>Class：字节码。用于被代理对象的字节码</li>
<li>Callback：用于提供增强的代码。一般都是一些接口地实现类，通常是匿名内部类。一般都写该接口的子接口实现类：MethodInterceptor</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Producer producer</span><br><span class="line">Enhancer.create(producer.getClass(),<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>()&#123;</span><br><span class="line">    <span class="comment">//MethodProxy 当前执行方法的代理对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object proxy,Method method,Object[] args,MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>Aspect Oriented Programming 面向切面编程。</p>
<p><strong>作用：</strong>在程序运行期间，不修改源码对已有方法进行增强。</p>
<p><strong>优势：</strong></p>
<ol>
<li><p>减少重复代码</p>
</li>
<li><p>提高开发效率</p>
</li>
<li><p>维护方便</p>
</li>
</ol>
<p>实现方式：使用动态代理技术</p>
<h2 id="Spring的AOP"><a href="#Spring的AOP" class="headerlink" title="Spring的AOP"></a>Spring的AOP</h2><h4 id="AOP中的术语："><a href="#AOP中的术语：" class="headerlink" title="AOP中的术语："></a>AOP中的术语：</h4><ol>
<li>**Joinpoint **连接点：指那些被拦截到的点。在 spring 中,这些点指的是方法。</li>
<li><strong>Pointcut</strong> 切入点：指我们要对哪些 Joinpoint 进行拦截的定义。</li>
<li><strong>Advice(通知/增强):</strong> 指拦截到 Joinpoint 之后所要做的事情就是通知。通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。</li>
<li>**Introduction(引介):**引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。</li>
<li>**Target(目标对象):**代理的目标对象。</li>
<li>**Weaving(织入):**是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。</li>
<li>**Proxy（代理）:**一个类被 AOP 织入增强后，就产生一个结果代理类。</li>
<li>**Aspect(切面):**是切入点和通知（引介）的结合。</li>
</ol>
<h4 id="运行阶段Spring-框架："><a href="#运行阶段Spring-框架：" class="headerlink" title="运行阶段Spring 框架："></a>运行阶段Spring 框架：</h4><p>Spring框架监听切入点方法的执行。一旦监听到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成功能的代码逻辑运行。</p>
<h3 id="基于配置的springAOP"><a href="#基于配置的springAOP" class="headerlink" title="基于配置的springAOP"></a>基于配置的springAOP</h3><ol>
<li><p>配置spring的ioc进行service对象bean配置</p>
</li>
<li><p>配置Logger 日志AOP类进行对象bean配置</p>
</li>
<li><p>配置aop：</p>
<ol>
<li>```xml<br><a href="aop:config">aop:config</a><pre><code>&lt;!-- 配置切入顶啊表达式 id唯一表示 exxpression指定表达式内容  在aop:aspect标签中，只能在该标签中使用，可以写在外面--&gt;
    &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(public void com.genuine.service.impl.*.*(..))&quot;/&gt;
    &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;
        &lt;!-- 前置通知 --&gt;
        &lt;aop:before method=&quot;beforePrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt;
        &lt;!-- 后置通知 --&gt;
        &lt;aop:after-returning method=&quot;afterReturningPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-returning&gt;
        &lt;!-- 异常通知 --&gt;
        &lt;aop:after-throwing method=&quot;afterThrowingPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-throwing&gt;
        &lt;!-- 最终通知 --&gt;
        &lt;aop:after method=&quot;afterPrintLog&quot; pointcut=&quot;execution(public void com.genuine.service.impl.*.*(..))&quot;&gt;&lt;/aop:after&gt;

        &lt;!-- 环绕通知 --&gt;
        &lt;aop:around method=&quot;aroundPrintLog&quot; pointcut=&quot;execution(public void com.genuine.service
    &lt;/aop:aspect&gt;
</code></pre>
</aop:config><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. Logger类中环绕通知书写规范：</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123;</span><br><span class="line">           Object rtValue = null;</span><br><span class="line">           try &#123;</span><br><span class="line">               Object[] args = pjp.getArgs();</span><br><span class="line">               System.out.println(&quot;前置Logger类的beforePrintLog方法开始记录日志。。。&quot;);</span><br><span class="line">               </span><br><span class="line">               rtValue = pjp.proceed();//明确调用业务层方法（切入点方法）</span><br><span class="line">               </span><br><span class="line">               System.out.println(&quot;后置Logger类的afterReturningPrintLog方法开始记录日志。。。&quot;);</span><br><span class="line">               return rtValue;</span><br><span class="line">           &#125; catch (Throwable t) &#123;</span><br><span class="line">               System.out.println(&quot;异常Logger类的afterThrowingPrintLog方法开始记录日志。。。&quot;);</span><br><span class="line">               throw new RuntimeException(t);</span><br><span class="line">           &#125;finally &#123;</span><br><span class="line">               System.out.println(&quot;最终Logger类的afterPrintLog方法开始记录日志。。。&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="基于注解的springAOP"><a href="#基于注解的springAOP" class="headerlink" title="基于注解的springAOP"></a>基于注解的springAOP</h3><ol>
<li><p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置spring创建容器时要扫描的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.genuine&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置spring开启注解AOP的支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Logger类细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;logger&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//表示当前类是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="comment">//切点表达式</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.genuine.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Before(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="meta">@After(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="meta">@Around(&quot;pt1()&quot;)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="保证idea的maven的jdk保持不变"><a href="#保证idea的maven的jdk保持不变" class="headerlink" title="保证idea的maven的jdk保持不变"></a>保证idea的maven的jdk保持不变</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在pom.xml文件中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Spring的JdbcTemplate"><a href="#Spring的JdbcTemplate" class="headerlink" title="Spring的JdbcTemplate"></a>Spring的JdbcTemplate</h2><ol>
<li><p>需要导入ioc，jdbc，tx，mysql依赖。</p>
</li>
<li><p>编写是实体类，需要实现Serializable接口。私有属性，get/set/toString方法。</p>
</li>
<li><p>JdbcTemplate简单使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//准备数据源：spring 的内置数据源</span></span><br><span class="line"><span class="type">DriverManagerDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>();</span><br><span class="line">ds.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">ds.setUrl(<span class="string">&quot;jdbc:mysql://39.97.117.252:3306/essy?useUnicode=true&amp;charcterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;severTimezone=UTC&quot;</span>);</span><br><span class="line">ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">ds.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//1.创建JdbcTemplate对象</span></span><br><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">jt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line"><span class="comment">//给jt设置数据源</span></span><br><span class="line">jt.setDataSource(ds);</span><br><span class="line"><span class="comment">//2.执行操作</span></span><br><span class="line">jt.execute(<span class="string">&quot;insert into account (name,money) values (&#x27;ccc&#x27;,1000)&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>配置数据源</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置JdbcTemplate --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://39.97.117.252:3306/essy?useUnicode=true<span class="symbol">&amp;amp;</span>charcterEncoding=utf8<span class="symbol">&amp;amp;</span>autoReconnect=true<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>severTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">1.</span> 获取容器</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="comment">//2. 获取对象</span></span><br><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">jt</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>,JdbcTemplate.class);</span><br></pre></td></tr></table></figure></li>
<li><p>JdbcTemplate的CURD</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存</span></span><br><span class="line">jt.update(<span class="string">&quot;insert into account (name,money) values (&#x27;eee&#x27;,1000)&quot;</span>);</span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line">jt.update(<span class="string">&quot;update account set name=?,money=? where id=?&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="number">4567</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">jt.update(<span class="string">&quot;delete from account where id=?&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//查询所有 需要new BeanPropertyRowMapper对象</span></span><br><span class="line"><span class="comment">//List&lt;Account&gt; accounts = jt.query(&quot;select * from account where money &gt; ?&quot;, new AccountRowMapper(), 99d);//这样方式需要定义account的封装策略</span></span><br><span class="line">List&lt;Account&gt; accounts = jt.query(<span class="string">&quot;select * from account where money &gt; ?&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class), <span class="number">99d</span>);</span><br><span class="line"><span class="keyword">for</span> (Account account :accounts) &#123;System.out.println(account);&#125;</span><br><span class="line"><span class="comment">//查询一个</span></span><br><span class="line">List&lt;Account&gt; account = jt.query(<span class="string">&quot;select * from account where id = ?&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class), <span class="number">1</span>);</span><br><span class="line">System.out.println(account.isEmpty()?<span class="string">&quot;没有内容&quot;</span> : account.get(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//查询返回一行一列（使用聚合函数，但不加group by字句）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jt.queryForObject(<span class="string">&quot;select count(*) from account&quot;</span>,Integer.class);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义account的封装策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountRowMapper</span> <span class="keyword">implements</span> <span class="title class_">RowMapper</span>&lt;Account&gt;&#123;</span><br><span class="line">    <span class="comment">//把结果及中的数据封装到account中,由spring把每个account加到集合中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">mapRow</span><span class="params">(ResultSet resultSet, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        account.setId(resultSet.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        account.setName(resultSet.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        account.setMoney(resultSet.getDouble(<span class="string">&quot;money&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="SpringMVC-1"><a href="#SpringMVC-1" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>基于Java实现的MVC设计模型的请求驱动类型的轻量级Web框架</p>
<h3 id="SpringMVC的优势"><a href="#SpringMVC的优势" class="headerlink" title="SpringMVC的优势"></a>SpringMVC的优势</h3><ol>
<li>清晰的角色划分：<ol>
<li><p>前端控制器DispatcherServlet：是整个流程控制的中心，由</p>
<p>它调用其它组件处理用户的请求，在降低了组件之间的耦合性。</p>
</li>
<li><p>处理器映射器HandlerMapping：根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
</li>
<li><p>处理器Handler：开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由</p>
<p>Handler 对具体的用户请求进行处理。</p>
</li>
<li><p>处理器适配器HandlerAdapter：通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理</p>
<p>器进行执行。</p>
</li>
<li><p>视图解析器ViewResolver：负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>
</li>
<li><p>视图View：要通过页面标签或页面模版技术将模型数据通过页面展示给用户。</p>
</li>
<li><p>验证器</p>
</li>
<li><p>命令对象</p>
</li>
<li><p>表单对象</p>
</li>
</ol>
</li>
<li>分工明确，容易扩展。</li>
<li>。。。</li>
</ol>
<h3 id="SpringMVC与Struts2的优略分析"><a href="#SpringMVC与Struts2的优略分析" class="headerlink" title="SpringMVC与Struts2的优略分析"></a>SpringMVC与Struts2的优略分析</h3><p>共同点：</p>
<ol>
<li>都是表现成框架，基于MVC模型编写</li>
<li>底层都离不开原始的ServletAPI</li>
<li>处理请求的机制都是一个核心控制器</li>
</ol>
<p>区别：</p>
<ol>
<li>SpringMVC的入口是Servlet，而Struts2是Filter</li>
<li>SpringMVC是基于方法设计的，而Struts2是基于类（多例的，每次执行都会创建一个动作类）</li>
<li>SpringMVC更加简洁，同时支持JSR303（JavaBean参数校验的标准），处理ajax的请求更方便。</li>
<li>Struts2的OGNL表达式时页面的开发效率相比SpringMVC更高，但执行效率没有JSTL高，尤其是struts2的表单标签，远没有html执行效率高。</li>
</ol>
<h2 id="SpringMVC入门程序"><a href="#SpringMVC入门程序" class="headerlink" title="SpringMVC入门程序"></a>SpringMVC入门程序</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol>
<li><p>创建Maven项目</p>
</li>
<li><p>选择maven-archetype-webapp模型</p>
</li>
<li><p>选择自己maven仓库</p>
</li>
<li><p>为解决maven项目创建过慢的问题在Properties中添加一个键值对archetypeCatalog：internal</p>
</li>
<li><p>在项目目录下创建java和resourecs文件夹，并Mark directory as 对应的选项。</p>
</li>
<li><p>导入pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span> $&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  前端控制器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- / 表示：所有的路径都会经过 dispatcherServlet --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>部署项目-环境搭建完成</p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/10/12/zCs9JenfOpXtH1i.png" alt="image.png"></p>
<h4 id="入门程序-springmvc-xml"><a href="#入门程序-springmvc-xml" class="headerlink" title="入门程序-springmvc.xml"></a>入门程序-springmvc.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.genuine&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    视图解析器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        会找该目录下的文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        后缀名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    开启springmvc注解的支持配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h4><ol>
<li>启动服务器，加载一些配置文件<ol>
<li>DispatcherServlet对象创建</li>
<li>springmvc.xml被加载</li>
<li>HelloController创建成对象</li>
</ol>
</li>
<li>发送请求，后台处理请求<ol>
<li>DispatcherServlet：前端控制器，控制作用，指挥中心</li>
<li>找到控制器类方法</li>
<li>InternalResourceViewResolver，通过视图解析器的包名和后缀名。</li>
<li>找到对应的jsp页面</li>
<li>返回给前端控制器再给浏览器。</li>
</ol>
</li>
</ol>
<p><img src="https://i.loli.net/2020/10/12/cRlNruMIPqY3FdE.png" alt="image.png"></p>
<p>SpringMVC框架基于组件方式执行流程：</p>
<ol>
<li><p>Request请求给前端控制器（控制整个流程 ）。</p>
</li>
<li><p>前端控制器根据请求通过处理器映射器<strong>找到</strong>对应的Controller类中的方法。</p>
</li>
<li><p>通过处理器适配器去执行方法返回结果</p>
</li>
<li><p>通过视图解析器找页面并返回给前端控制器</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。</p>
<p>使用自动加载 RequestMappingHandlerMapping （处理映射器）和RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用替代注解处理器和适配器的配置。</p>
<h3 id="注解讲解"><a href="#注解讲解" class="headerlink" title="注解讲解"></a>注解讲解</h3><ol>
<li><p>@RequestMapping</p>
<ol>
<li>属性path与value：作用相同，指路径</li>
<li>属性method：RequestMethod枚举类，请求方式</li>
<li>属性params：指定限制请求参数的条件</li>
<li>属性headers：用于指定限制请求消息头的条件</li>
</ol>
</li>
<li><p>@RequestParam：把请求中指定名称的参数给控制器中的形参赋值（由于可能两者的参数名不同）。以下方法均用于形参中</p>
<ol>
<li>value：请求参数中的名称。</li>
<li>required：请求参数中是否必须提供此参数。默认值：true。</li>
</ol>
</li>
<li><p>@RequestBody：用于获取请求体内容，直接使用得到是 key=value&amp;key=value…结构的字符串数据。get不适用</p>
<ol>
<li>required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。</li>
</ol>
</li>
<li><p>@PathVariable：用于绑定 url 中的占位符。例如：请求 url 中 /delete/**{id}<strong>，这个</strong>{id}**就是 url 占位符。url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。</p>
<ol>
<li>value：用于指定 url 中占位符名称。</li>
<li>required：是否必须提供占位符。</li>
</ol>
</li>
<li><p>@RequestHeader：用于获取请求消息头。</p>
<ol>
<li>value：提供消息头名称</li>
<li>required：是否必须有此消息头</li>
</ol>
</li>
<li><p>@CookieValue：用于把指定 cookie 名称的值传入控制器方法参数。</p>
<ol>
<li>value：指定 cookie 的名称。</li>
<li>required：是否必须有此 cookie。</li>
</ol>
</li>
<li><p>@ModelAttribute</p>
<ol>
<li>出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。</li>
<li>出现在参数上，获取指定的数据给参数赋值。</li>
<li>value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。</li>
</ol>
</li>
<li><p>@SessionAttribute：用于多次执行控制器方法间的参数共享。</p>
<ol>
<li>value：用于指定存入的属性名称</li>
<li>type：用于指定存入的数据类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SessionAttributes(value =&#123;&quot;username&quot;,&quot;password&quot;&#125;,types=&#123;Integer.class&#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionAttributeController</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 把数据存入 SessionAttribute</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* Model 是 spring 提供的一个接口，该接口有一个实现类 ExtendedModelMap</span></span><br><span class="line"><span class="comment">* 该类继承了 ModelMap，而 ModelMap 就是 LinkedHashMap 子类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testPut&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testPut</span><span class="params">(Model model)</span>&#123; </span><br><span class="line"> model.addAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;泰斯特&quot;</span>); </span><br><span class="line"> model.addAttribute(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>); </span><br><span class="line"> model.addAttribute(<span class="string">&quot;age&quot;</span>, <span class="number">31</span>); </span><br><span class="line"> <span class="comment">//跳转之前将数据保存到 username、password 和 age 中，因为注解@SessionAttribute 中有这几个参数 </span></span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h3><h4 id="绑定的机制"><a href="#绑定的机制" class="headerlink" title="绑定的机制"></a>绑定的机制</h4><p>表单中请求参数都是基于 key=value 。</p>
<h4 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a><strong>支持的数据类型</strong></h4><ol>
<li><p><strong>基本类型</strong></p>
<ol>
<li>基本类型和String类型：参数名称和方法的形参名称保持一致。(严格区分大小写)。</li>
</ol>
</li>
<li><p><strong>POJO</strong> <strong>类型参数</strong></p>
<ol>
<li><p>实体类以及关联的实体类：表单中参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;address.provinceName&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>数组和集合类型参数</strong></p>
<ol>
<li><p>List 结构和 Map 结构的集合（包括数组）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;list[0].name&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;map[&#x27;one&#x27;].name&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>接收的请求参数是 json 格式数据。需要借助一个注解实现</p>
</li>
</ol>
</li>
<li><p><strong>特殊类型转换要求，需要我们自己编写自定义类型转换器。</strong></p>
<ol>
<li><p><strong>定义一个类，实现</strong> <strong>Converter</strong> <strong>接口，该接口有两个泛型。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String,Date&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">convert</span><span class="params">(String source)</span>&#123;</span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(source)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;请输入要转换的日期&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            format = <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> format.parse(source);</span><br><span class="line">            <span class="keyword">return</span> date;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入日期有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>在</strong> <strong>spring</strong> <strong>配置文件中配置类型转换器。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置类型转换器工厂 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;converterService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 给工厂注入一个新的类型转换器 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- 配置自定义类型转换器 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.web.converter.StringToDateConverter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>在</strong> <strong>annotation-driven</strong> <strong>标签中引用配置的类型转换服务</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用自定义类型转换器 --&gt;</span> <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;converterService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="请求参数乱码问题"><a href="#请求参数乱码问题" class="headerlink" title="请求参数乱码问题"></a><strong>请求参数乱码问题</strong></h4><p>在post方式会出现乱码问题，可以配置过滤器解决。</p>
<p>在 web.xml 中配置一个过滤器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 springMVC 编码过滤器 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 设置过滤器中的属性值 --&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line"> 		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 启动过滤器 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 过滤所有请求 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-ServletAPI-对象作为方法参数"><a href="#使用-ServletAPI-对象作为方法参数" class="headerlink" title="使用 ServletAPI 对象作为方法参数"></a><strong>使用</strong> <strong>ServletAPI</strong> <strong>对象作为方法参数</strong></h4><p>SpringMVC 支持使用原始 ServletAPI 对象作为控制器方法的参数。<strong>把需要的对象，直接写在控制的方法参数中使用。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">testServletAPI</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                            HttpServletResponse response,</span></span><br><span class="line"><span class="params">                            HttpSession session)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于HiddentHttpMethodFilter的多种请求方式"><a href="#基于HiddentHttpMethodFilter的多种请求方式" class="headerlink" title="基于HiddentHttpMethodFilter的多种请求方式"></a>基于HiddentHttpMethodFilter的多种请求方式</h3><p>由于浏览器 form 表单只支持 GET 与 POST 请求，而 DELETE、PUT 等 method 并不支持，Spring3.0 添加了一个过滤器，可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持 GET、POST、PUT 与 DELETE 请求。</p>
<p>使用方法：</p>
<ol>
<li><p>在 web.xml 中配置该过滤器。</p>
</li>
<li><p>请求方式必须使用 post 请求。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;springmvc/testRestPUT/1&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">用户名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;更新&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>按照要求提供_method 请求参数，该参数的取值就是我们需要的请求方式。</p>
</li>
</ol>
<h2 id="响应数据和结果视图"><a href="#响应数据和结果视图" class="headerlink" title="响应数据和结果视图"></a>响应数据和结果视图</h2><h3 id="1-按返回值分类"><a href="#1-按返回值分类" class="headerlink" title="1.按返回值分类"></a>1.按返回值分类</h3><h4 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定逻辑视图名，经过视图解析器解析为 jsp 物理路径：/WEB-INF/pages/success.jsp</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testReturnString&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testReturnString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-void"><a href="#2-void" class="headerlink" title="2. void"></a>2. void</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testReturnVoid&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReturnVoid</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> </span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 controller 方法形参上可以定义 request 和 response，使用 request 或 response 指定响应结果</p>
<ol>
<li><p>使用 request 转发页面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/pages/success.jsp&quot;</span>).forward(request, </span><br><span class="line">response);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 response 页面重定向</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendREdirect(<span class="string">&quot;testReturnString&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 response 指定响应结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">response.getWriter().write(<span class="string">&quot;json 串&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-ModelAndView"><a href="#3-ModelAndView" class="headerlink" title="3.ModelAndView"></a>3.ModelAndView</h4><p>ModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。</p>
<p>该对象中有两个方法：</p>
<p><img src="https://i.loli.net/2020/10/15/GDQkdFzswOPTnUu.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/10/15/GDQkdFzswOPTnUu.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testReturnModelAndView&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testReturnModelAndView</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    mv.addObject(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    mv.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;/head&gt; &lt;body&gt;</span><br><span class="line">执行成功！</span><br><span class="line">$&#123;requestScope.username&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>注意：在页面上获取使用的是 requestScope.username 取的，所以返回 ModelAndView 类型时，浏览器跳转只能是请求转发。</p>
<h3 id="2-转发和重定向"><a href="#2-转发和重定向" class="headerlink" title="2.转发和重定向"></a>2.转发和重定向</h3><h4 id="1-forward转发"><a href="#1-forward转发" class="headerlink" title="1.forward转发"></a>1.forward转发</h4><p>controller 方法在提供了 String 类型的返回值之后，默认就是请求转发。我们也可以写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/WEB-INF/pages/success.jsp&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/user/findAll&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-Redirect重定向"><a href="#2-Redirect重定向" class="headerlink" title="2. Redirect重定向"></a>2. Redirect重定向</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:testReturnModelAndView&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/add.jsp&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果是重定向到 jsp 页面，则 jsp 页面不能写在 WEB-INF 目录中，否则无法找到。</p>
<h3 id="3-ResponseBody-响应-json-数据"><a href="#3-ResponseBody-响应-json-数据" class="headerlink" title="3.ResponseBody 响应 json 数据"></a>3.ResponseBody 响应 json 数据</h3><p>该注解用于将 Controller 的方法返回的对象，通过 HttpMessageConverter 接口转换为指定格式的数据如：json,xml 等，通过 Response 响应给客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseJson&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> Account <span class="title function_">testResponseJson</span><span class="params">(<span class="meta">@RequestBody</span> Account account)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;异步请求：&quot;</span>+account);</span><br><span class="line"><span class="keyword">return</span> account; &#125;</span><br></pre></td></tr></table></figure>

<p>使用需要要导入jar包jackson。</p>
<h2 id="SpringMVC文件上传"><a href="#SpringMVC文件上传" class="headerlink" title="SpringMVC文件上传"></a>SpringMVC文件上传</h2><h3 id="1-文件上传回顾"><a href="#1-文件上传回顾" class="headerlink" title="1.文件上传回顾"></a>1.文件上传回顾</h3><p>导入文件上传的jar包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/genuinenonage/genuinenonage.github.io.git/2020/08/27/linux/Linux%E5%AE%89%E8%A3%85Mysql%208.0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/genuinenonage/genuinenonage.github.io.git/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/genuinenonage/genuinenonage.github.io.git/2020/08/27/linux/Linux%E5%AE%89%E8%A3%85Mysql%208.0/" class="post-title-link" itemprop="url">Linux安装Mysql 8.0</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-27 10:42:00" itemprop="dateCreated datePublished" datetime="2020-08-27T10:42:00+08:00">2020-08-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-08-29 11:21:55" itemprop="dateModified" datetime="2020-08-29T11:21:55+08:00">2020-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/genuinenonage/genuinenonage.github.io.git/categories/%E5%AE%89%E8%A3%85/" itemprop="url" rel="index"><span itemprop="name">安装</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiexinxx0225/article/details/107665316" title="参考连接">https://blog.csdn.net/xiexinxx0225/article/details/107665316</a>  </p>
<h2 id="卸载MariaDB"><a href="#卸载MariaDB" class="headerlink" title="卸载MariaDB"></a>卸载MariaDB</h2><p>MariaDB是Linux默认数据库，需先卸载。  </p>
<ol>
<li>使用 yum list installed | grep mariadb 检查MariaDB是否安装。</li>
<li>使用 yum -y remove mariadb* 命令 卸载</li>
</ol>
<h2 id="删除MySQL对应的文件夹"><a href="#删除MySQL对应的文件夹" class="headerlink" title="删除MySQL对应的文件夹"></a>删除MySQL对应的文件夹</h2><ol>
<li><p>whereis mysql</p>
</li>
<li><p>find / -name musql</p>
<pre><code> [root@localhost /]# whereis mysql
 mysql: /usr/bin/mysql /usr/include/mysql
 [root@localhost lib]# find / -name mysql
 /data/mysql
 /data/mysql/mysql
</code></pre>
</li>
</ol>
<ol start="3">
<li><p>删除上两条命令查询出来的相关目录或文件。</p>
<pre><code> [root@localhost /]#  rm -rf /usr/bin/mysql /usr/include/mysql /data/mysql /data/mysql/mysql 
</code></pre>
</li>
<li><p>重复输入1、2命令，是否删除完毕。</p>
</li>
</ol>
<h2 id="检查MySQL用户组和用户是否存在，如果没有，则创建"><a href="#检查MySQL用户组和用户是否存在，如果没有，则创建" class="headerlink" title="检查MySQL用户组和用户是否存在，如果没有，则创建"></a>检查MySQL用户组和用户是否存在，如果没有，则创建</h2><pre><code>[root@localhost /]# cat /etc/group | grep mysql
[root@localhost /]# cat /etc/passwd |grep mysql
[root@localhost /]# groupadd mysql
[root@localhost /]# useradd -r -g mysql mysql
[root@localhost /]#
</code></pre>
<h2 id="命令下载Linux的Mysql安装包"><a href="#命令下载Linux的Mysql安装包" class="headerlink" title="命令下载Linux的Mysql安装包"></a>命令下载Linux的Mysql安装包</h2><pre><code>[root@localhost ~]#  wget https://cdn.mysql.com/archives/mysql-8.0/mysql-8.0.19-linux-glibc2.12-x86_64.tar.xz
</code></pre>
<h1 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h1><h2 id="解压安装包"><a href="#解压安装包" class="headerlink" title="解压安装包"></a>解压安装包</h2><pre><code>[root@localhost /]#  tar xvf mysql-8.0.19-linux-glibc2.12-x86_64.tar.xz
[root@localhost /]# ls
mysql-8.0.19-linux-glibc2.12-x86_64
mysql-8.0.19-linux-glibc2.12-x86_64.tar.xz
</code></pre>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol>
<li>首先确保/usr/local/下没有mysql文件夹，如果有就删除  </li>
<li>执行移动命令  <pre><code> [root@localhost ~]# mv mysql-8.0.19-linux-glibc2.12-x86_64 /usr/local/mysql
</code></pre>
</li>
</ol>
<ol start="3">
<li><p>在/usr/local/mysql目录下创建data目录  </p>
<pre><code> [root@localhost /]# mkdir /usr/local/mysql/data
</code></pre>
</li>
<li><p>更改mysql目录下所有的目录及文件夹所属的用户组和用户，以及权限  </p>
<pre><code> [root@localhost /]# chown -R mysql:mysql /usr/local/mysql
 [root@localhost /]# chmod -R 755 /usr/local/mysql 
</code></pre>
</li>
<li><p>下载链接库文件  </p>
<pre><code> [root@localhost bin]#  yum -y install libaio-devel.x86_64
</code></pre>
</li>
<li><p>编译安装并初始化mysql,务必记住初始化输出日志末尾的密码（数据库管理员临时密码）  </p>
<pre><code> [root@localhost /]# cd /usr/local/mysql/bin
 [root@localhost bin]# ./mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql
</code></pre>
</li>
<li><p>编辑配置文件my.cnf，添加配置如下</p>
<pre><code> [root@localhost bin]#  vi /etc/my.cnf

 [mysqld]
 datadir=/usr/local/mysql/data
 port=3306
 sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
 symbolic-links=0
 max_connections=600
 innodb_file_per_table=1
 log-error=/usr/local/mysql/data/error.log
</code></pre>
</li>
<li><p>测试启动mysql服务器</p>
<pre><code> [root@localhost /]# /usr/local/mysql/support-files/mysql.server start
</code></pre>
</li>
<li><p>添加软连接，并重启mysql服务</p>
<pre><code> [root@localhost /]#  ln -s /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql 
 [root@localhost /]#  ln -s /usr/local/mysql/bin/mysql /usr/bin/mysql
 [root@localhost /]#  service mysql restart  
</code></pre>
</li>
<li><p>登录mysql，修改密码(密码为步骤6生成的临时密码)</p>
<pre><code>[root@localhost /]#  mysql -u root -p
Enter password:
mysql&gt;ALTER USER USER() IDENTIFIED BY &#39;yourpass&#39;;
mysql&gt;flush privileges;
</code></pre>
</li>
<li><p>开放远程连接  </p>
<pre><code>mysql&gt;use mysql;
msyql&gt;update user set user.Host=&#39;%&#39; where user.User=&#39;root&#39;;
mysql&gt;flush privileges; 
</code></pre>
</li>
</ol>
<ol start="12">
<li><p>必须修改加密规则  </p>
<pre><code>1.输入 use mysql; 出现Database changed
2.输入select user,host from user; 目的为了查看user的root 对应host是什么  我对应的是 %
3.修改加密规则：输入ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;

root:为数据库用户名
123456：为数据库密码
</code></pre>
</li>
</ol>
<ol start="13">
<li><p>可以自由设置开机自动启动</p>
<pre><code>1、将服务文件拷贝到init.d下，并重命名为mysql
[root@localhost /]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld
2、赋予可执行权限
[root@localhost /]# chmod +x /etc/init.d/mysqld
3、添加服务
[root@localhost /]# chkconfig --add mysqld
4、显示服务列表
[root@localhost /]# chkconfig --list
</code></pre>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/genuinenonage/genuinenonage.github.io.git/2020/08/24/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-%E6%9C%AA%E5%AE%8C%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/genuinenonage/genuinenonage.github.io.git/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/genuinenonage/genuinenonage.github.io.git/2020/08/24/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-%E6%9C%AA%E5%AE%8C%E6%88%90/" class="post-title-link" itemprop="url">并发编程基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-24 15:04:00" itemprop="dateCreated datePublished" datetime="2020-08-24T15:04:00+08:00">2020-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-11-11 09:35:40" itemprop="dateModified" datetime="2020-11-11T09:35:40+08:00">2020-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/genuinenonage/genuinenonage.github.io.git/categories/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ArrayList线程不安全，他的读写方法没有同步策略，会导致脏数据和不可预期的结果。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>读-改-写操作，线程要么全部执行，要么全部不执行。<br>使用Synchronized可以实现线程安全，即实现可见性和同步，但是Synchronized是独占锁，没有获得内部锁的线程会被阻塞掉。  </p>
<h3 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a>原子变量类</h3><p>原子变量类比锁更轻巧，比如AtomicLong代表了一个Long值，并提供了get,set方法，get，set方法语义和volatile相同，因为AtomicLong内部就是使用了volatile修饰的真正的Long变量。另外提供了原子性的自增自减操作。<br>相比使用Synchronized的好处在于原子类操作不会导致线程的挂起和重新调度，内部使用的是cas的非阻塞算法。<br>常用的原子类为：AtomicLong,AtomicInteger,AtomicBoolean,AtomicReference。  </p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS（CompareAndSet） 比较并设置。<br>CAS有三个操作数：内存位置，旧的预期值，新的值。<br>当内存位置的变量值为旧的预期值时，使用新的值替换旧的值，否则返回旧的值。这个处理器提供的一个原子性指令。  </p>
<pre><code>for (;;) &#123;
    long current = get();（1）
    long next = current + 1;（2）
    if (compareAndSet(current, next))（3）
        return next;
&#125;
</code></pre>
<p>这里使用了无限循环使用CAS进行轮询检查，一定程度上浪费了cpu，但是相比锁避免了线程的上下文切换和调度。  </p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>一个线程要获取被其他线程占用的锁时，线程会被阻塞。<br>可重入锁：当线程再次获取他自己已经获取的锁时，不会被阻塞。只要线程获得了该锁，可以无限制次数进入被该锁锁住的代码。 </p>
<p>如果内置锁不是可重入的那么该调用就会导致死锁了，因为线程持有并等待了锁。  </p>
<p>实际上内部锁是可重入锁，例如synchronized关键字管理的方法，可重入锁的原理是在锁内部维护了一个线程标示，标示该锁目前被那个线程占用，关联一个计数器，一开始计数器值为0，说明该锁没有被任何线程占用，当一个线程获取了该锁，计数器会变成1，其他线程在获取该锁时候发现锁的所有者不是自己所以被阻塞，但是当获取该锁的线程再次获取锁时候发现锁拥有者是自己会把计数器值+1， 当释放锁后计数器会-1，当计数器为0时候，锁里面的线程标示重置为null,这时候阻塞的线程会获取被唤醒来获取该锁。  </p>
<h2 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h2><p>synchronized块是Java提供的一种强制性内置锁，执行代码在进入synchronized代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时候会阻塞掉。拿到内部锁的线程会在正常退出同步代码块或者异常抛出后释放内部锁，这时候阻塞掉的线程才能获取内部锁进入同步代码块。  </p>
<p>线程A进入同步块修改变量值后，会在退出同步块前把值刷新到主内存，而线程B在进入同步块前会首先清空本地内存内容，从主内存重新获取变量值，所以实现了可见性。但是要注意一点所有线程使用的是同一个锁。  </p>
<p>注意 Synchronized关键字会引起线程上下文切换和线程调度。  </p>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>Synchronized可以实现同步，但是只有一个线程访问共享变量。正常情况下，对于多个读操作时不需要同步。而大部分情况下读操作次数多于写操作，ReentrantReadWriteLock，可以实现读写分离，多个线程同时进行读取，但是最多一个写线程存在。  </p>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><pre><code>public class ArrayList&lt;E&gt;
&#123;
    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    public E get(int index)&#123;
        Lock readLock = readWriteLock.readLock();
        readLock.lock();
        try&#123;
            return list.get(index);
        &#125;finally&#123;
            readLock.unlock();
        &#125;
    &#125;
    public E set(int index, E element)&#123;
        Lock wirteLock = readWriteLock.writeLock();
        wirteLock.lock();
        try&#123;
            return list.set(index, element);
        &#125;finally&#123;
            wirteLock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p>get方法readWriteLock.readLock()获取读锁，多个线程可获得。<br>set方法readwriteLock.writeLock()获取写锁，一个线程可获得，其他线程会被阻塞。<br>一个线程获得了读锁，要获得写锁需要等待释放读锁<br>一个线程获得了写锁，要获取读锁需要等待释放写锁<br>相比Synchronized来说运行多个读者同时存在，提高了并发量。<br>** 注意：需要显示调用Lock与unlock操作。** </p>
<h2 id="Volatile变量"><a href="#Volatile变量" class="headerlink" title="Volatile变量"></a>Volatile变量</h2><p>注意 volatile关键字不会引起线程上下文切换和线程调度。另外volatile还用来解决重排序问题。  </p>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>指数据被外界修改持保守态度(悲观)，在数据处理过程中，数据处于锁定状态。悲观锁的实现依靠数据库的锁机制。<br>数据库中实现对数据记录操作前，先给记录加排它锁，如果获取锁失败，则说明数据正在被其他线程修改，则等待或者抛出异常。如果加锁成功，则获取记录，对其修改，然后事务提交后释放排它锁。<br>一个例子：select * from 表 where .. for update;</p>
<p>悲观锁是先加锁再访问策略，处理加锁会让数据库产生额外的开销，还有增加产生死锁的机会，另外在多个线程只读情况下不会产生数据不一致行问题，没必要使用锁，只会增加系统负载，降低并发性，因为当一个事务锁定了该条记录，其他读该记录的事务只能等待。</p>
<h4 id="悲观锁详细操作"><a href="#悲观锁详细操作" class="headerlink" title="悲观锁详细操作"></a>悲观锁详细操作</h4><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁是相对悲观锁来说的，它认为数据一般情况下不会造成冲突，所以在访问记录前不会加排他锁，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，具体说根据update返回的行数让用户决定如何去做。乐观锁并不会使用数据库提供的锁机制，一般在表添加version字段或者使用业务状态来做。  </p>
<p>乐观锁直到提交的时候才去锁定，所以不会产生任何锁和死锁。  </p>
<h4 id="乐观锁详细操作"><a href="#乐观锁详细操作" class="headerlink" title="乐观锁详细操作"></a>乐观锁详细操作</h4><h2 id="独占锁与共享锁"><a href="#独占锁与共享锁" class="headerlink" title="独占锁与共享锁"></a>独占锁与共享锁</h2><p>根据锁能够被单个线程还是多个线程共同持有，锁又分为独占锁和共享锁。<br>独占锁保证任何时候都只有一个线程能读写权限，ReentrantLock就是以独占方式实现的互斥锁。<br>共享锁则可以同时有多个读线程，但最多只能有一个写线程，读和写是互斥的，例如ReadWriteLock读写锁。  </p>
<p>独占锁是一种悲观锁，每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据一致性，而独占锁只允许同时一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。</p>
<p>共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。  </p>
<h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>根据线程获取锁的抢占机制锁可以分为公平锁和非公平锁。<br>公平锁表示线程获取锁的顺序是按照线程加锁的时间多少来决定的，也就是最早加锁的线程将最早获取锁，也就是先来先得的FIFO顺序。而非公平锁则运行闯入，也就是先来不一定先得。  </p>
<p>ReentrantLock提供了公平和非公平锁的实现：<br>公平锁ReentrantLock pairLock = new ReentrantLock(true);<br>非公平锁 Reen trantLock pairLock = new ReentrantLock(false);<br>如果构造函数不传递参数，则默认是非公平锁。<br>在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销。  </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/genuinenonage/genuinenonage.github.io.git/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/genuinenonage/genuinenonage.github.io.git/">1</a><span class="space">&hellip;</span><a class="page-number" href="/genuinenonage/genuinenonage.github.io.git/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/genuinenonage/genuinenonage.github.io.git/page/7/">7</a><a class="page-number" href="/genuinenonage/genuinenonage.github.io.git/page/8/">8</a><a class="extend next" rel="next" href="/genuinenonage/genuinenonage.github.io.git/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QB</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/genuinenonage/genuinenonage.github.io.git/js/comments.js"></script><script src="/genuinenonage/genuinenonage.github.io.git/js/utils.js"></script><script src="/genuinenonage/genuinenonage.github.io.git/js/motion.js"></script><script src="/genuinenonage/genuinenonage.github.io.git/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/genuinenonage/genuinenonage.github.io.git/js/third-party/search/local-search.js"></script>





  




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"genuinenonage/comments","issue_term":"pathname","theme":"github-light"}</script>
<script src="/genuinenonage/genuinenonage.github.io.git/js/third-party/comments/utterances.js"></script>

</body>
</html>
