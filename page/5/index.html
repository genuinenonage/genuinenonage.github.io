<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="菜鸡">
<meta property="og:type" content="website">
<meta property="og:title" content="genuine nonage">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="genuine nonage">
<meta property="og:description" content="菜鸡">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="QB">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>genuine nonage</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">genuine nonage</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">减少放电，增加充电</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QB</p>
  <div class="site-description" itemprop="description">菜鸡</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/12/java/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/12/java/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/" class="post-title-link" itemprop="url">阿里巴巴开发手册</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-12 17:42:50" itemprop="dateCreated datePublished" datetime="2020-11-12T17:42:50+08:00">2020-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-09 18:17:06" itemprop="dateModified" datetime="2023-03-09T18:17:06+08:00">2023-03-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>划分七个维度：编程规约、异常日志、单元测试、安全规约、MySQL数据库、工程结构、设计规约。</p>
<h2 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><ol>
<li>代码中的命名不能以下划线或美元符号开始或结束。</li>
<li>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文。</li>
<li>类名是使用UpperCamelCase风格，但有例外：DO/BO/DTO/VO/AO/PO/UID等。<ol>
<li>正例：UserDO/XmlService</li>
<li>反例：UserDo/XMLService</li>
</ol>
</li>
<li>方法名、参数名、成员变量、局部变量统一使用lowerCamelCase风格。必须遵从驼峰式。</li>
<li>常量名全部大写，单词间用下划线隔开，力求语义表达完整，不要嫌名字长。</li>
<li>抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以Test结尾。</li>
<li>类型与中括号紧挨相连表示数组。</li>
<li>POJO类中布尔类型变量都不要加si前缀，否则部分框架解析会引起序列化错误。</li>
<li>包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。</li>
<li>避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名。</li>
<li>杜绝不规范缩写。</li>
<li>任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。</li>
<li>命名常量与变量时，表示类型的名词放在词尾。<ol>
<li>正例：startTime</li>
</ol>
</li>
<li>如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式<ol>
<li>public class OrderFactory;</li>
</ol>
</li>
<li>接口类中的方法和属性不要加任何修饰符号（public也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，除非与接口方法相关，并且是整个应用的基础常量。</li>
<li>接口和实现类有两套命名规则<ol>
<li>对于Service和DAO类，基于SOA理念，暴露出来的服务一定是接口，额你不的实现类用Impl的后缀与接口区别。</li>
<li>如果是形容能力的接口名称，去对应的形容词为接口名（通常是-able的形容词）<ol>
<li>正例：AbstractTranslator实现Translatable接口。</li>
</ol>
</li>
</ol>
</li>
<li>枚举类名带上Enum后缀，枚举成员名称需全大写，单词间用下划线隔开。<ol>
<li>说明：枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有。</li>
</ol>
</li>
<li>各层命名规约：<ol>
<li>Service/DAO层方法命名规约<ol>
<li>获取单个对象的方法用 get 做前缀。</li>
<li>获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。</li>
<li> 获取统计值的方法用 count 做前缀。 </li>
<li>插入的方法用 save/insert 做前缀。</li>
<li>删除的方法用 remove/delete 做前缀。</li>
<li>修改的方法用 update 做前缀。</li>
</ol>
</li>
<li>领域模型命名规约<ol>
<li>数据对象：xxxDO，xxx 即为数据表名。</li>
<li>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</li>
<li>展示对象：xxxVO，xxx 一般为网页名称。</li>
<li>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><h3 id="OOP规约"><a href="#OOP规约" class="headerlink" title="OOP规约"></a>OOP规约</h3><h3 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h3><h3 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><ol>
<li>获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</li>
<li>创建线程或线程池是请指定有意义的线程名称，方便出错时回溯。</li>
<li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</li>
<li>线程池不允许使用Executors去创建，通过ThreadPoolExector的方式。可以更加明确线程池的运行规则，规避资源耗尽的风险。</li>
<li>SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。</li>
<li>必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如不清理，可能会影响后续业务逻辑和造成内存泄漏等问题。尽量在代理中使用try-finally块进行回收。</li>
<li>高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，不要锁整个方法体；能用对象锁，不要用类锁。<ol>
<li>说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。</li>
</ol>
</li>
<li>对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</li>
<li>在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。</li>
<li>在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。<ol>
<li>说明：Lock 对象的 unlock 方法在执行时，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），如果当前线程不持有锁，则抛出IllegalMonitorStateException 异常。</li>
</ol>
</li>
<li>并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。<ol>
<li>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。</li>
</ol>
</li>
<li>多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，如果在处理定时任务时使用ScheduledExecutorService 则没有这个问题。</li>
<li>资金相关的金融敏感信息，使用悲观锁策略。<ol>
<li>说明：乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常。</li>
</ol>
</li>
<li>使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至await方法，知道超出时才返回结果。<ol>
<li>说明：注意，子线程抛出异常堆栈，不能在主线程try-catch到。</li>
</ol>
</li>
<li>避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。</li>
<li>在并发场景下，通过双重检查锁实现延迟初始化的优化问题隐患，推荐解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。</li>
<li>volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</li>
<li>HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。</li>
<li>ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。</li>
</ol>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><ol>
<li>在一个switch块内，每个case要么通过continue/break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，必须包含一个default语句并且放在最后，即使什么代码也没有。</li>
<li>当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null判断。</li>
<li>在 if/else/for/while/do 语句中必须使用大括号。</li>
<li>在高并发场景中，避免使用”等于”判断作为中断或退出的条件。</li>
<li>表达异常的分支时，少用 if-else 方式。</li>
</ol>
<h3 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h3><ol>
<li>类、类属性、类方法的注释必须使用Javadoc规范，使用/** 内容 */格式，不得使用// xxx 方式。<ol>
<li>说明：在IDE编辑窗口中，Javadoc方式会提示相关注释。提高阅读效率。</li>
</ol>
</li>
<li>所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释，除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。<ol>
<li>说明：对子类的实现要求，或者调用注意事项，请一并说明。</li>
</ol>
</li>
<li>所有的类都必须添加创建者和创建日期。</li>
<li>方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐。</li>
<li>所有的枚举类型字段必须要有注释，说明每个数据项的用途。</li>
<li>与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。</li>
<li>代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。</li>
<li>谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。</li>
<li>对于注释的要求：第一、能够准确反映设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。</li>
<li>好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。</li>
<li>特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<ol>
<li>待办事宜（TODO）:（标记人，标记时间，[预计处理时间]）</li>
<li>错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）</li>
</ol>
</li>
<li>对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由。</li>
</ol>
<h2 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol>
<li>Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过 catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等。</li>
<li>异常不要用来做流程控制，条件控制。<ol>
<li>说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</li>
</ol>
</li>
<li>catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。</li>
<li>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</li>
<li>有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。</li>
<li>finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。<ol>
<li>说明：如果 JDK7 及以上，可以使用 try-with-resources 方式。</li>
</ol>
</li>
<li>不要在 finally 块中使用 return。</li>
<li>捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。</li>
<li>在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 Throwable类来进行拦截。</li>
<li>方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。</li>
<li>防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：<ol>
<li>返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。</li>
<li>数据库的查询结果可能为 null。 </li>
<li>集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。 </li>
<li>远程调用返回对象时，一律要求进行空指针判断，防止 NPE。 </li>
<li>对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。</li>
<li>级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。</li>
</ol>
</li>
<li>定义时区分 unchecked / checked 异常，避免直接抛出 new RuntimeException()，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等。</li>
<li>对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。</li>
<li>避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。</li>
</ol>
<h3 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h3><ol>
<li>应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</li>
<li>所有日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。网络运行状态、安全相关信息、系统监测、管理后台操作、用户敏感操作需要留存相关的网络日志不少于 6 个月。</li>
<li>应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。</li>
<li>在日志输出时，字符串变量之间的拼接使用占位符的方式。</li>
<li>对于 trace/debug/info 级别的日志输出，必须进行日志级别的开关判断。</li>
<li>避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。</li>
<li>异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。</li>
<li>谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。</li>
<li>可以使用 warn 日志级别来记录用户输入参数错误的情况</li>
<li>尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。【强制】国际化团队或海外部署的服务器由于字符集问题，使用全英文来注释和描述日志错误信息。</li>
</ol>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol>
<li>好的单元测试必须遵守 AIR 原则。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。</li>
<li>单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。</li>
<li>保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。</li>
<li>单元测试是可以重复执行的，不能受到外界环境的影响。</li>
</ol>
<h2 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h2><ol>
<li>隶属于用户个人的页面或者功能必须进行权限控制校验。</li>
<li>用户敏感数据禁止直接展示，必须对展示数据进行脱敏。</li>
<li>用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。</li>
<li>用户请求传入的任何参数必须做有效性验证。</li>
<li>禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</li>
<li>表单、AJAX 提交必须执行 CSRF 安全验证。</li>
<li>在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的 机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。</li>
<li>发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。</li>
</ol>
<h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><h2 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h2><ol>
<li><p>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。</p>
<ol>
<li>说明：任何字段如果为非负数，必须是 unsigned。</li>
<li>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在&lt; resultMap &gt;设置从 is_xxx到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。</li>
</ol>
</li>
<li><p>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p>
<ol>
<li>说明：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。</li>
</ol>
</li>
<li><p>表名不使用复数名词。</p>
</li>
<li><p>禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p>
</li>
<li><p>主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</p>
<ol>
<li>说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</li>
</ol>
</li>
<li><p>小数类型为 decimal，禁止使用 float 和 double。</p>
<ol>
<li>说明：在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。</li>
</ol>
</li>
<li><p>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p>
</li>
<li><p>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p>
</li>
<li><p>表必备三字段：id, create_time, update_time。</p>
<ol>
<li>说明：：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。create_time, update_time的类型均为 datetime 类型。</li>
</ol>
</li>
<li><p>表的命名最好是遵循“业务名称_表的作用”</p>
<ol>
<li>正例：alipay_task / force_project / trade_config</li>
</ol>
</li>
<li><p>库名与应用名称尽量一致。</p>
</li>
<li><p>如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p>
</li>
<li><p>字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</p>
<ol>
<li>不是频繁修改的字段。</li>
<li>不是 varchar 超长字段，更不能是 text 字段。</li>
<li>不是唯一索引的字段。</li>
</ol>
</li>
<li><p>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</p>
<ol>
<li>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</li>
</ol>
</li>
<li><p>合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检</p>
<p>索速度。</p>
</li>
</ol>
<h2 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h2><ol>
<li>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</li>
<li>超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。</li>
<li>在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</li>
<li>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</li>
<li>如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。<ol>
<li>正例：where a=? and b=? order by c; 索引：a_b_c 。</li>
</ol>
</li>
<li>利用覆盖索引来进行查询操作，避免回表。<ol>
<li>说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。</li>
</ol>
</li>
<li>利用延迟关联或者子查询优化超多分页场景。<ol>
<li>说明：：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL改写。</li>
</ol>
</li>
<li>SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是consts 最好。<ol>
<li>consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。</li>
<li>ref 指的是使用普通的索引（normal index）。 </li>
<li>range 对索引进行范围检索。</li>
</ol>
</li>
<li>建组合索引的时候，区分度最高的在最左边。<ol>
<li>如果 where a=? and b=? ，如果 a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。</li>
<li>说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：where c&gt;? and d=? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 idx_d_c。</li>
</ol>
</li>
<li>防止因字段类型不同造成的隐式转换，导致索引失效。</li>
<li>创建索引时避免有如下极端误解：<ol>
<li>宁滥勿缺。认为一个查询就需要建一个索引。</li>
<li>宁缺勿滥。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。</li>
<li>抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</li>
</ol>
</li>
</ol>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><ol>
<li>不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。<ol>
<li>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</li>
</ol>
</li>
<li>count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</li>
<li>当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。<ol>
<li>正例：使用如下方式来避免 sum 的 NPE 问题：SELECT IFNULL(SUM(column), 0) FROM table;</li>
</ol>
</li>
<li>使用 ISNULL()来判断是否为 NULL 值。<ol>
<li>说明：NULL 与任何值的直接比较都为 NULL。 </li>
</ol>
</li>
<li>代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</li>
<li>不得使用外键与级联，一切外键概念必须在应用层解决。<ol>
<li>说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</li>
</ol>
</li>
<li>禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</li>
<li>数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认无误才能执行更新语句。</li>
<li>in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。</li>
<li>如果有国际化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。<ol>
<li>说明：如果需要存储表情，那么选择 utf8mb4 来进行存储，注意它与 utf-8 编码的区别。</li>
</ol>
</li>
<li>TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。</li>
</ol>
<h3 id="ORM映射"><a href="#ORM映射" class="headerlink" title="ORM映射"></a>ORM映射</h3><ol>
<li>在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。<ol>
<li>增加查询分析器解析成本。</li>
<li>增加查询分析器解析成本。</li>
<li>无用字段增加网络消耗，尤其是 text 类型的字段。</li>
</ol>
</li>
<li>POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。</li>
<li>不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个 POJO 类与之对应。</li>
<li>sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</li>
<li>iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。<ol>
<li>其实现方式是在数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList 取start,size 的子集合。</li>
</ol>
</li>
<li>不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</li>
<li>更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。</li>
<li>不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</li>
<li>@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</li>
<li>&lt; isEqual &gt;中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；&lt; isNotEmpty &gt;表示不为空且不为 null 时执行；&lt; isNotNull &gt;表示不为 null 值时执行。 </li>
</ol>
<h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><h3 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h3><h3 id="二方库依赖"><a href="#二方库依赖" class="headerlink" title="二方库依赖"></a>二方库依赖</h3><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><h2 id="设计规约"><a href="#设计规约" class="headerlink" title="设计规约"></a>设计规约</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/10/%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/10/%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">一些知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-10 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-10T00:00:00+08:00">2020-11-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-09 18:18:34" itemprop="dateModified" datetime="2023-03-09T18:18:34+08:00">2023-03-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-一方库、二方库、三方库是什么？"><a href="#1-一方库、二方库、三方库是什么？" class="headerlink" title="1. 一方库、二方库、三方库是什么？"></a>1. 一方库、二方库、三方库是什么？</h3><p>一方库：本工程中的各模块的相互依赖。</p>
<p>二方库：公司内部的依赖库，一般指公司内部的其他项目发布的jar包</p>
<p>三方库：公司之外的开源库，比如apache、ibm、google等发布的依赖</p>
<h3 id="2-Java中-方法签名是什么？"><a href="#2-Java中-方法签名是什么？" class="headerlink" title="2. Java中 方法签名是什么？"></a>2. Java中 方法签名是什么？</h3><p>方法声明的两个组件构成了方法签名：方法的名称和参数类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateAnswer</span><span class="params">(<span class="type">double</span> wingSpan, <span class="type">int</span> numberOfEngines,</span></span><br><span class="line"><span class="params">                              <span class="type">double</span> length, <span class="type">double</span> grossTons)</span> &#123;</span><br><span class="line">    <span class="comment">//do the calculation here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法的签名是:<br><code>calculateAnswer(double, int, double, double)</code></p>
<h3 id="3-OOM"><a href="#3-OOM" class="headerlink" title="3. OOM"></a>3. OOM</h3><h4 id="什么是OOM？"><a href="#什么是OOM？" class="headerlink" title="什么是OOM？"></a>什么是OOM？</h4><p>OOM，全称”Out Of Memory”—“内存用完了”，来源于java.lang.OutOfMemoryError。</p>
<p>当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也没有空间可回收时，就会抛出这个error。</p>
<h4 id="为什么会OOM？"><a href="#为什么会OOM？" class="headerlink" title="为什么会OOM？"></a>为什么会OOM？</h4><ol>
<li>分配的少了：虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。</li>
<li>应用用的太多，并且用完没释放，浪费了。此时造成内存泄露或者内存溢出。</li>
</ol>
<h4 id="内存泄漏，内存溢出"><a href="#内存泄漏，内存溢出" class="headerlink" title="内存泄漏，内存溢出"></a>内存泄漏，内存溢出</h4><p><strong>内存泄漏</strong>：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了。因为申请者不用了，而又不能被虚拟机分配给别人用。</p>
<p><strong>内存溢出</strong>：申请的内存超出了JVM能提供的内存大小，此时称之为溢出。</p>
<p><strong>在Java语言中</strong>，由于存在了垃圾自动回收机制，所以，我们一般不用去主动释放不用的对象所占的内存，也就是理论上来说，是<strong>不会存在“内存泄露”的</strong>。</p>
<p><strong>如果编码不当</strong>，比如，将某个对象的引用放到了全局的Map中，虽然方法结束了，但是由于垃圾回收器会根据对象的引用情况来回收内存，导致该对象不能被及时的回收。如果该种情况出现次数多了，就<strong>会导致内存溢出</strong>，比如<strong>系统中经常使用的缓存机制。</strong></p>
<h3 id="4-内部接口的作用？"><a href="#4-内部接口的作用？" class="headerlink" title="4. 内部接口的作用？"></a>4. 内部接口的作用？</h3><p>也被称为嵌套接口，在另一个接口内声明一个接口。</p>
<ol>
<li>逻辑分组仅在一个地方使用的接口的一种方式。</li>
<li>增加了封装。</li>
<li>更易读和可维护的代码。</li>
</ol>
<h3 id="5-缓存（cache）与缓冲区（buffer）的主要区别"><a href="#5-缓存（cache）与缓冲区（buffer）的主要区别" class="headerlink" title="5. 缓存（cache）与缓冲区（buffer）的主要区别"></a>5. 缓存（cache）与缓冲区（buffer）的主要区别</h3><p>Buffer的核心作用是用来缓冲，缓和冲击。</p>
<p>Cache的核心作用是加快取用的速度。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/19/%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/19/%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE1/" class="post-title-link" itemprop="url">商城项目（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-19 15:03:00" itemprop="dateCreated datePublished" datetime="2020-10-19T15:03:00+08:00">2020-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-04-23 09:57:21" itemprop="dateModified" datetime="2021-04-23T09:57:21+08:00">2021-04-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>暂时设计B2C，未来项目成熟后，转向C2C。</p>
<p>分布式基础部分</p>
<ol>
<li>分布式的基本概念<ul>
<li>微服务、注册中心、配置中心、feign远程调用、网关（统一配置跨域）</li>
</ul>
</li>
<li>基础开发<ul>
<li>Spring Boot 2.0 、Spring Cloud、Mybatis-Plus、Vue组件化、阿里云对象存储</li>
</ul>
</li>
<li>环境<ul>
<li>Linux、Docker、MySql、Redis、逆向工程&amp;人人开源</li>
</ul>
</li>
<li>开发规范<ul>
<li>数据校验JSR303、全局异常处理、全局统一返回、全局跨域处理</li>
<li>枚举状态、业务状态码、VO与TO与PO划分、逻辑删除</li>
<li>Lombok：@Data、@Slf4j</li>
</ul>
</li>
</ol>
<h2 id="项目技术特点："><a href="#项目技术特点：" class="headerlink" title="项目技术特点："></a>项目技术特点：</h2><p>前后端分离开发，开发基于vue的后台管理系统</p>
<p>SpringCloud全新的解决方案</p>
<p>应用监控、限流、网关、熔断降级等分布式方案，全方位涉及</p>
<p>分布式事务、分布式锁等分布式系统难题</p>
<p>高并发场景，线程池、异步编排等使用</p>
<p>压力测试，性能优化</p>
<p>各种集群技术使用</p>
<p>CI/CD使用</p>
<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>微服务：拒绝大型单体应用，基于业务边界进行服务强化拆分，服务独立部署运行。</p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>网络地址转换</p>
<h1 id="项目开始"><a href="#项目开始" class="headerlink" title="项目开始"></a>项目开始</h1><h2 id="1-安装服务器工具-docker-mysql-redis"><a href="#1-安装服务器工具-docker-mysql-redis" class="headerlink" title="1.安装服务器工具(docker,mysql,redis)"></a>1.安装服务器工具(docker,mysql,redis)</h2><ol>
<li><p>安装虚拟机</p>
<ol>
<li><p>安装VirtualBox</p>
</li>
<li><p>安装 vagrant 快速搭建虚拟机</p>
<ol>
<li><p>安装成功后重启系统。</p>
</li>
<li><p>cmd输入命令vagrant测试是否安装成功。</p>
</li>
<li><p>cmd输入vagrant init centos/7</p>
</li>
<li><p>cmd输入vagrant up 启动虚拟机（停止可以在VirtualBox中停止）</p>
</li>
<li><p>cmd输入vagrant ssh 链接上虚拟机</p>
<blockquote>
<p>vagrant reload   重启虚拟机</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
<li><p>安装docker</p>
<ol>
<li><p>卸载旧版本docke</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>下载</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>安装</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>启动</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>检查当前虚拟机的镜像</p>
<blockquote>
<p>$ sudo docker images</p>
</blockquote>
</li>
<li><p>设置开机自启动</p>
<blockquote>
<p>$ sudo systemctl enable docker</p>
</blockquote>
</li>
<li><p>配置镜像加速</p>
<blockquote>
<p>在阿里云查找镜像加速器</p>
<p>sudo mkdir -p /etc/docker</p>
<p>sudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’ </p>
<p>{</p>
<p> “registry-mirrors”: [“<a href="https://x7tuoc0z.mirror.aliyuncs.com&quot;]">https://x7tuoc0z.mirror.aliyuncs.com&quot;]</a> </p>
<p>} </p>
<p>EOF</p>
<p>sudo systemctl daemon-reload </p>
<p>sudo systemctl restart docker</p>
</blockquote>
</li>
<li><p>其他的使用</p>
<blockquote>
<p>如果遇到docker镜像重启无法使用，就重启docker</p>
<p>systemctl restart docker</p>
<p>查看正在运行中的容器</p>
<p>docker ps</p>
<p>查看全部容器</p>
<p>docker ps -a</p>
<p>删除容器</p>
<p>docker rm -f 容器名</p>
<p>docker rmi 容器名</p>
<p>停止容器</p>
<p>docker stop 容器id</p>
<p>启动容器</p>
<p>docker start 容器id</p>
<p>删除镜像</p>
<p>docker rmi mysql:8.0</p>
<p>重启容器</p>
<p>docker restart 容器名</p>
<p>设置容器开机自启</p>
<p>docker update –restart=always 容器名</p>
</blockquote>
</li>
</ol>
</li>
<li><p>docker安装mysql</p>
<ol>
<li><p>mysql57</p>
<ol>
<li><p>下载MySQL57镜像</p>
<blockquote>
<p>docker pull mysql:5.7</p>
</blockquote>
</li>
<li><p>创建my.cnf文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/mysql57/conf/</span><br><span class="line">touch /mydata/mysql57/conf/my.cnf</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   [client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">   </span><br><span class="line">[mysql]</span><br><span class="line">   default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">   init_connect=&#x27;SET collation_connection=utf8_unicode_ci&#x27;</span><br><span class="line">   init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line">   character-set-server=utf8</span><br><span class="line">   collation-server=utf8_unicode_ci</span><br><span class="line">   skip-character-set-client-handshake</span><br><span class="line">   skip-name-resolve</span><br><span class="line">   max_connections=1500</span><br></pre></td></tr></table></figure></li>
<li><p>安装</p>
<blockquote>
<p>docker run -p 3306:3306 –name mysql57 <br>-v /mydata/mysql57/log:/var/log/mysql <br>-v /mydata/mysql57/data:/var/lib/mysql <br>-v /mydata/mysql57/conf:/etc/mysql <br>-e MYSQL_ROOT_PASSWORD=Aa19990804 <br>-d mysql:5.7</p>
</blockquote>
<blockquote>
<p>docker run -p 3306:3306 –name mysql57 -v $PWD/conf:/etc/mysql/conf.d -v $PWD/log:/logs -v $PWD/data:/mysql_data -e MYSQL_ROOT_PASSWORD=Aa19990804 -d mysql:5.7</p>
</blockquote>
<ol start="4">
<li><p>进入容器</p>
<blockquote>
<p>docker exec -it mysql57 /bin/bash</p>
</blockquote>
</li>
</ol>
</li>
<li><p>mysql8</p>
<ol>
<li><p>下载MySQL8.0镜像</p>
<blockquote>
<p>docker pull mysql:8.0</p>
</blockquote>
</li>
<li><p>创建my.cnf文件</p>
<blockquote>
<p>vi /mydata/mysql8/conf/my.cnf</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      [mysqld]</span><br><span class="line">      pid-file        = /var/run/mysqld/mysqld.pid</span><br><span class="line">      socket          = /var/run/mysqld/mysqld.sock</span><br><span class="line">      datadir         = /var/lib/mysql</span><br><span class="line">      secure-file-priv= NULL</span><br><span class="line">      # Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">      symbolic-links=0</span><br><span class="line"></span><br><span class="line">      # Custom config should go here</span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br><span class="line">      </span><br><span class="line">      default_authentication_plugin= mysql_native_password</span><br></pre></td></tr></table></figure></li>
<li><p>安装</p>
<blockquote>
<p>docker run <br>-p 3307:3306 <br>-e MYSQL_ROOT_PASSWORD=root <br>-v /mydata/mysql8/data:/var/lib/mysql:rw <br>-v /mydata/mysql8/log:/var/log/mysql:rw <br>-v /mydata/mysql8/conf/my.cnf:/etc/mysql/my.cnf:rw <br>-v /etc/localtime:/etc/localtime:ro <br>–name mysql8 <br>–restart=always <br>-d mysql:8.0</p>
</blockquote>
</li>
<li><p>进入容器</p>
<blockquote>
<p>docker exec -it mysql8 /bin/bash</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
<li><p>docker安装redis</p>
<ol>
<li><p>下载镜像</p>
<blockquote>
<p>docker pull redis</p>
</blockquote>
</li>
<li><p>创建配置</p>
<blockquote>
<p>mkdir -p /mydata/redis/conf</p>
<p>touch /mydata/redis/conf/redis.conf </p>
</blockquote>
</li>
<li><p>运行容器</p>
<blockquote>
<p>docker run -p 6379:6379 –name redis -v /mydata/redis/data:/data -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf</p>
</blockquote>
</li>
<li><p>开启redis客户端</p>
<blockquote>
<p>docker exec -it redis redis-cli</p>
<p>redis默认是没有持久化的，数据存储在内存中。</p>
</blockquote>
</li>
<li><p>在Linux中编辑redis.conf文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">让redis启用aof的持久化方式</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="2-安装电脑工具"><a href="#2-安装电脑工具" class="headerlink" title="2. 安装电脑工具"></a>2. 安装电脑工具</h2><p>完成navicat，redisdesktopmanager，idea，vxcode，maven，git工具的安装与配置</p>
<h2 id="3-搭建脚手架"><a href="#3-搭建脚手架" class="headerlink" title="3. 搭建脚手架"></a>3. 搭建脚手架</h2><ol>
<li><p>在码云创建一个仓库java,maven。</p>
</li>
<li><p>在idea中新建Project from version control</p>
</li>
<li><p>创建项目微服务</p>
<ol>
<li>```txt<br>共同点：<ol>
<li>web，openfeign</li>
<li>每个服务，包名com.genuine.wmall.xxx(product/order/ware/coupon/member)</li>
<li>模块名：wmall-<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   2. 创建所有模块module，使用spring快速搭建，由于是**微服务**，必要的两个依赖web的**springweb**和**springcloudrouting的openfeign**</span><br><span class="line"></span><br><span class="line">4. 在wmall中创建并编辑pom.xml</span><br><span class="line"></span><br><span class="line">   关联各个微服务</span><br><span class="line"></span><br><span class="line">   ```xml</span><br><span class="line">   &lt;groupId&gt;com.genuine.wmall&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;wmall&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">       &lt;name&gt;wmall&lt;/name&gt;</span><br><span class="line">       &lt;description&gt;聚合服务&lt;/description&gt;</span><br><span class="line">   	&lt;!-- 使用maven分模块管理 一般所有父级项目的packaging都为pom，packaging默认类型jar类型，如果不做配置，maven会将该项目打成jar包。 --&gt;</span><br><span class="line">       &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">       &lt;modules&gt;</span><br><span class="line">           &lt;module&gt;wmall-coupon&lt;/module&gt;</span><br><span class="line">           &lt;module&gt;wmall-member&lt;/module&gt;</span><br><span class="line">           &lt;module&gt;wmall-order&lt;/module&gt;</span><br><span class="line">           &lt;module&gt;wmall-product&lt;/module&gt;</span><br><span class="line">           &lt;module&gt;wmall-ware&lt;/module&gt;</span><br><span class="line">       &lt;/modules&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>在maven中添加wmall模块（默认使root模块）。</p>
</li>
<li><p>在wmall中的.gitignore（git的模板，可以忽视垃圾文件）</p>
<p><strong>忽略设置：使git不上传远程仓库规定文件</strong></p>
<p>只将有用的代码纳入版本控制（Add VCS）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**/  -- 代表任意目录</span><br><span class="line"></span><br><span class="line">**/mvnw</span><br><span class="line">**/mvnw.cmd</span><br><span class="line">**/.mvn</span><br><span class="line">**/target</span><br><span class="line">.idea</span><br><span class="line">**/.gitignore</span><br></pre></td></tr></table></figure></li>
<li><p>设计数据库</p>
<p>设计表，创建表。</p>
<p>在电商项目中表与表之间不做外键。</p>
<p>每一个服务创建自己的数据库。</p>
</li>
<li><p><strong>反向创建代码</strong></p>
<p>自动创建数据库实体类，dao层，service层</p>
<ol>
<li><p>构建数据库</p>
</li>
<li><p>下载人人开源的renren-fast和renren-fast-vue项目。</p>
</li>
<li><p>将两个项目的.git文件夹删掉</p>
</li>
<li><p>将renren-fast项目放入后台项目中，加入modules中，并创建数据库，之后可以运行测试。</p>
</li>
<li><p>使用vscode打开renren-fast-vue项目。</p>
<blockquote>
<p>npm install</p>
<p>npm run duv</p>
</blockquote>
</li>
<li><p>登录账户密码：admin   admin</p>
</li>
<li><p>下载并安装代码生成器renren-generator项目，放入wmall项目中，加入modules中，修改application.yml文件中的数据库配置。修改generator.properties文件中的配置</p>
<blockquote>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mainPath</span>=<span class="string">com.genuine</span></span><br><span class="line"><span class="attr">package</span>=<span class="string">com.genuine.wmall</span></span><br><span class="line"><span class="attr">moduleName</span>=<span class="string">product</span></span><br><span class="line"><span class="attr">author</span>=<span class="string">xuanhuanxingkong8</span></span><br><span class="line"><span class="attr">email</span>=<span class="string">xuanhuanxingkong8@gmail.com</span></span><br><span class="line"><span class="attr">tablePrefix</span>=<span class="string">pms</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>运行代码生成器服务</p>
</li>
<li><p>根据数据库的表，生成代码，导入到项目中。</p>
</li>
<li><p>修改程序中的报错的问题，将公共工具放到common模块中。</p>
</li>
<li><p><strong>整合MyBatis-Plus</strong></p>
<ol>
<li><p>导入依赖</p>
</li>
<li><p>配置</p>
<ol>
<li><p>配置数据源</p>
<ol>
<li><p>导入数据库驱动</p>
</li>
<li><p>配置数据源相关信息</p>
</li>
<li><p>配置MyBatis-Plus</p>
<pre><code>1. 使用@MapperScan
  
2. 告诉MyBatis-Plus，sql映射文件位置
  
   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://81.70.204.157:3306/gulimall_pms</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="comment"># 表主键自增</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># mapper-locations: classpath*:/mapper/**/*.xml</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/**/*.xml</span></span><br></pre></td></tr></table></figure>
  
   classpath后*表示任意模块路径下的mapper的任意路径下的任意.xml结尾的文件。
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="4-微服务"><a href="#4-微服务" class="headerlink" title="4. 微服务"></a>4. 微服务</h2><p>技术搭配方案：</p>
<p>Nacos：注册中心（服务发现/注册）</p>
<p>Nacos：配置中心（动态配置管理）</p>
<p>Ribbon：负载均衡</p>
<p>Feign：声明式HTTP客户端（调用远程服务）</p>
<p>Sentinel：服务容错（限流、降级、熔断）</p>
<p>Gateway：API网关（webflux编程模式）</p>
<p>Sleuth：调用链监控</p>
<p>Seata：原Fescar，分布式事务解决方案</p>
<h3 id="Nacos注册中心和OpenFeign远程调用"><a href="#Nacos注册中心和OpenFeign远程调用" class="headerlink" title="Nacos注册中心和OpenFeign远程调用"></a>Nacos注册中心和OpenFeign远程调用</h3><ol>
<li><p>分布式组件spring cloud alibaba</p>
<p>导入依赖：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>下载nacos服务器（注册中心、配置中心），并启动服务。</p>
<p><strong>在项目配置文件中配置Nacos Server地址和当前服务名</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8848</span></span><br><span class="line">  application:</span><br><span class="line">    name: 项目名</span><br></pre></td></tr></table></figure>

<p><strong>使用@EnableDiscoveryClient注解开启服务注册与发现功能</strong></p>
<p>运行项目</p>
</li>
<li><p>Feign声明式远程调用</p>
<p>简介：Feign是一个声明式的HTTP客户端。整合了Ribbon（负载均衡）和Hystrix（服务熔断）。</p>
<p>步骤：</p>
<ol>
<li><p>引入open-feign</p>
</li>
<li><p>编写一个接口，需要调用远程服务</p>
<ol>
<li><p>声明接口的每一个方法都是调用那个远程服务的请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被调用方 类中</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/member/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">membercoupons</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">CouponEntity</span> <span class="variable">couponEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CouponEntity</span>();</span><br><span class="line">    couponEntity.setCouponName(<span class="string">&quot;满100减10&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> R.ok().put(<span class="string">&quot;coupons&quot;</span>,Arrays.asList(couponEntity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用远程服务的服务名</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;wmall-coupon&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CouponFeignService</span> &#123;</span><br><span class="line">    <span class="comment">//使用接口的完整签名</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/coupon/coupon/member/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">membercoupons</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">调用方 类中</span><br><span class="line">   </span><br><span class="line">   ```java</span><br><span class="line">   //test调用方 类中</span><br><span class="line">   @Autowired</span><br><span class="line">   CouponFeignService couponFeignService;</span><br><span class="line">   </span><br><span class="line">   @RequestMapping(&quot;/coupons&quot;)</span><br><span class="line">public R test()&#123;</span><br><span class="line">       MemberEntity memberEntity = new MemberEntity();</span><br><span class="line">    memberEntity.setNickname(&quot;张三&quot;);</span><br><span class="line">       R membercoupons = couponFeignService.membercoupons();</span><br><span class="line">       return R.ok().put(&quot;member&quot;,memberEntity).put(&quot;coupons&quot;,membercoupons.get(&quot;coupons&quot;));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>调用方 启动类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启远程调用功能 自动扫描 全包名</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.genuine.wmall.member.feign&quot;)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WmallMemberApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(WmallMemberApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在浏览器发送请求：localhost:8000/member/member/coupons</p>
<p>附：如果服务停止，前端会显示，连接超时。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h3><ol>
<li><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用配置中心做配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个bootstrap.properties文件</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">wmall-coupon项目名</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br></pre></td></tr></table></figure></li>
<li><p>给配置中心默认添加一个 数据集（Data Id）。 默认规则：应用名.properties</p>
</li>
<li><p>给 应用名.properties 添加任何配置</p>
</li>
<li><p>动态获取配置。</p>
<ol>
<li><p>@RefreshScope 动态获取，并刷新配置。可应用在控制器类名上</p>
</li>
<li><p>@Value(${配置项名})  获取到配置</p>
<p>当配置中心和当前应用都配置了相同的项，优先使用配置中心的配置。</p>
</li>
</ol>
</li>
<li><p>细节：</p>
<ol>
<li><p>命名空间：配置隔离：</p>
<p>默认：public（保留空间）</p>
<p>基于不同环境隔离：开发，测试，生产：利用命名空间做环境隔离。</p>
<p>注意：在bootstrap.properties中配置</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string">bf179235-e27b-42e6-b162-8b598e0a2bae</span></span><br></pre></td></tr></table></figure>

<p><strong>基于微服务隔离</strong>：每一个微服务之间互相隔离配置，每一个微服务都创建自己的命名空间，只加载自己明明空间下的所有配置。</p>
</li>
<li><p>配置集：所有的配置的集合。</p>
</li>
<li><p>配置集id：类似于文件名。就是Data ID</p>
</li>
<li><p>配置分组：默认所有配置集都属于：DEFAULT_GROUP</p>
<p><strong>每个微服务创建自己的命名空间，使用配置分组区分环境。</strong> 分组：dev、prod</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.config.group</span>=<span class="string">dev Group名</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>同时加载多个配置集</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置集id</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[0].data-id</span>=<span class="string">datasource.yml</span></span><br><span class="line"><span class="comment"># 配置分组</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[0].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="comment"># 启动配置刷新</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[0].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[1].data-id</span>=<span class="string">mybatis.yml</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[1].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[1].refresh</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">...</span></span><br></pre></td></tr></table></figure>

<ol>
<li>微服务任何配置信息，任何配置文件都可以放在配置中心中。</li>
<li>只需要在bootstrap.properties说明加载配置中心的哪些配置文件即可。</li>
<li>SpringBoot任何方法从配置文件中获取值，都能使用配置中心获取文件。</li>
</ol>
</li>
</ol>
<h3 id="API网关-Gateway"><a href="#API网关-Gateway" class="headerlink" title="API网关 Gateway"></a>API网关 Gateway</h3><p>分布式开发中需要api网关：</p>
<ol>
<li>实时的接受注册中心的服务是否上线，将请求转发到正确的目标服务。</li>
<li>不将登录校验的功能分布到每一个服务上，在网关服务上实现。</li>
</ol>
<p><strong>Gateway简介</strong>：</p>
<p>网关作为流量的入口，常用功能包括 <strong>路由转发、权限校验、限流控制等</strong>，而spring cloud gateway 作为SpringCloud官方推出的第二代网关框架，取代了Zuul网关。</p>
<p>（每秒能处理三万多的请求，请求到达网关，通过断言，是否符合路由规则，然后经过filter路由到指定地方） </p>
<p>学习Gateway，在官方文档中学习与使用。</p>
<p>断言：判断请求是否符合路由规则，符合就经过一系列filter过滤后到达指定地点。</p>
<ol>
<li><p>新建网关项目，仅依赖网关gateway</p>
</li>
<li><p>依赖common工程，注册到common中</p>
</li>
<li><p>统一gateway的spring版本与springcloud版本</p>
</li>
<li><p>开启服务注册发现（配置服务信息）</p>
<p>启动类中添加@EnableDiscoveryClient</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties 配置nacos注册中心</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">wmall-gateway</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">88</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bootstrap.properties 配置nacos配置中心</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string">da468fd0-0579-4ac8-b473-f93211213424</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.group</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">wmall-coupon</span></span><br></pre></td></tr></table></figure>

<p>有需要时，在配置中心配置</p>
<p>启动网关的时候会遇到数据源相关的错误，网关排除掉跟数据库相关的自动配置 @SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</p>
<p>网关是基于Netty启动的。</p>
<p>请求转发：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">test_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Query=baz</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">qq_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.qq.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Query=url,</span> <span class="string">qq</span></span><br></pre></td></tr></table></figure>

<p>浏览器输入localhost:88/?baz 会跳转到百度页面</p>
<p>输入localhost:88/?url=qq 会跳转到qq页面</p>
</li>
</ol>
<h1 id="项目问题待解决"><a href="#项目问题待解决" class="headerlink" title="项目问题待解决"></a>项目问题待解决</h1><h3 id="Maven-plugins-爆红，无法导入"><a href="#Maven-plugins-爆红，无法导入" class="headerlink" title="Maven plugins 爆红，无法导入"></a>Maven plugins 爆红，无法导入</h3><h3 id="springcloud版本问题"><a href="#springcloud版本问题" class="headerlink" title="springcloud版本问题"></a>springcloud版本问题</h3><p>已解决，我已经全部换成:</p>
<p>spring-boot-starter-parent 2.1.3.RELEASE</p>
<p>spring-cloud.version Greenwich.SR3</p>
<ol>
<li><p>gulimall-common</p>
</li>
<li><p>gulimall-coupon<br>spring-boot-starter-parent 2.4.1<br>spring-cloud.version 2020.0.0-M6</p>
</li>
<li><p>gulimall-member<br>spring-boot-starter-parent 2.3.4.RELEASE<br>spring-cloud.version Greenwich.SR3</p>
</li>
<li><p>gulimall-order</p>
<p>spring-boot-starter-parent 2.4.1<br>spring-cloud.version 2020.0.0-M6</p>
</li>
<li><p>gulimall-product</p>
<p>spring-boot-starter-parent 2.3.5.RELEASE<br>spring-cloud.version Greenwich.SR3</p>
</li>
<li><p>gulimall-ware</p>
<p>spring-boot-starter-parent 2.4.1<br>spring-cloud.version 2020.0.0-M6</p>
</li>
</ol>
<h3 id="Java解决Excel（POI）"><a href="#Java解决Excel（POI）" class="headerlink" title="Java解决Excel（POI）"></a>Java解决Excel（POI）</h3><p>已解决，如果maven阿里云仓库没有最新的依赖，阿里云将会去国外中央仓库下载</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/12/Tomcat%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/12/Tomcat%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">tomcat问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-12 17:01:00" itemprop="dateCreated datePublished" datetime="2020-10-12T17:01:00+08:00">2020-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-08 15:31:05" itemprop="dateModified" datetime="2021-02-08T15:31:05+08:00">2021-02-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><h5 id="springmvc启动tomcate控制台乱码问题"><a href="#springmvc启动tomcate控制台乱码问题" class="headerlink" title="springmvc启动tomcate控制台乱码问题"></a>springmvc启动tomcate控制台乱码问题</h5><p>在tomcat文件夹中的conf包下的logging.properties中找到</p>
<p>java.util.logging.ConsoleHandler.encoding = UTF-8</p>
<p>将这行代码注销改为</p>
<p>java.util.logging.ConsoleHandler.encoding = GBK</p>
<p>重启tomcat即可！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/21/java/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/21/java/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">Java8的新特性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-21 07:31:00" itemprop="dateCreated datePublished" datetime="2020-09-21T07:31:00+08:00">2020-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-08 15:51:01" itemprop="dateModified" datetime="2021-02-08T15:51:01+08:00">2021-02-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>新增了非常多的特性，主要有：</p>
<ul>
<li><strong>Lambad表达式</strong>：Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li>
<li><strong>方法引用</strong>：可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合，使语言的构造更紧凑简洁，减少冗余代码。</li>
<li><strong>默认方法</strong>：默认方法就是一个在接口里面有了一个实现的方法。</li>
<li><strong>StreamAPI</strong>：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li>
<li><strong>DateTimeAPI</strong>：加强对日期与时间的处理。</li>
<li><strong>Optional类</strong>：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li><strong>Nashorn，JavaScript引擎</strong>：Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li>
</ul>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p>
<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>
<ol>
<li><p>接收2个int型整数,返回他们的和<br>(int x, int y) -&gt; x + y  </p>
</li>
<li><p>接受2个参数(数字),并返回他们的差值<br>(x, y) -&gt; x – y  </p>
</li>
<li><p>接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)<br>(String s) -&gt; System.out.print(s)</p>
<pre><code> public class Java8Tester &#123;
    public static void main(String args[])&#123;
       Java8Tester tester = new Java8Tester();
         
       // 类型声明
       MathOperation addition = (int a, int b) -&gt; a + b;
         
       // 不用类型声明
       MathOperation subtraction = (a, b) -&gt; a - b;
         
       // 大括号中的返回语句
       MathOperation multiplication = (int a, int b) -&gt; &#123; return a * b; &#125;;
         
       // 没有大括号及返回语句
       MathOperation division = (int a, int b) -&gt; a / b;
         
       System.out.println(&quot;10 + 5 = &quot; + tester.operate(10, 5, addition));
       System.out.println(&quot;10 - 5 = &quot; + tester.operate(10, 5, subtraction));
       System.out.println(&quot;10 x 5 = &quot; + tester.operate(10, 5, multiplication));
       System.out.println(&quot;10 / 5 = &quot; + tester.operate(10, 5, division));
         
       // 不用括号
       GreetingService greetService1 = message -&gt;
       System.out.println(&quot;Hello &quot; + message);
         
       // 用括号
       GreetingService greetService2 = (message) -&gt;
       System.out.println(&quot;Hello &quot; + message);
         
       greetService1.sayMessage(&quot;Runoob&quot;);
       greetService2.sayMessage(&quot;Google&quot;);
    &#125;
     
    interface MathOperation &#123;
       int operation(int a, int b);
    &#125;
     
    interface GreetingService &#123;
       void sayMessage(String message);
    &#125;
     
    private int operate(int a, int b, MathOperation mathOperation)&#123;
       return mathOperation.operation(a, b);
    &#125;
 &#125;
</code></pre>
</li>
</ol>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用通过方法的名字来指向一个方法。</p>
<p>方法引用使用一对冒号 :: 。</p>
<ul>
<li><p>构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new</p>
<ul>
<li>实例如下：<br>final Car car = Car.create( Car::new );<br>final List&lt; Car &gt; cars = Arrays.asList( car );</li>
</ul>
</li>
<li><p>静态方法引用：它的语法是Class::static_method</p>
<ul>
<li>实例如下：<br>cars.forEach( Car::collide );</li>
</ul>
</li>
<li><p>特定类的任意对象的方法引用：它的语法是Class::method</p>
<ul>
<li>实例如下：<br>cars.forEach( Car::repair );</li>
</ul>
</li>
<li><p>特定对象的方法引用：它的语法是instance::method</p>
<ul>
<li><p>实例如下：<br>final Car police = Car.create( Car::new );<br>cars.forEach( police::follow );</p>
<pre><code>  public class Java8Tester &#123;
     public static void main(String args[])&#123;
        List names = new ArrayList();
          
        names.add(&quot;Google&quot;);
        names.add(&quot;Runoob&quot;);
        names.add(&quot;Taobao&quot;);
        names.add(&quot;Baidu&quot;);
        names.add(&quot;Sina&quot;);
          
        names.forEach(System.out::println);
     &#125;
  &#125;
  实例中我们将 System.out::println 方法作为静态方法来引用。
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>
<p>函数式接口可以被隐式转换为 lambda 表达式。</p>
<pre><code>@FunctionalInterface
interface GreetingService 
&#123;
    void sayMessage(String message);
&#125;
</code></pre>
<p>使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：</p>
<pre><code>GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message);
</code></pre>
<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>新增了接口的默认方法。</p>
<p>接口可以有实现方法，不需要实现类去实现其方法。</p>
<p>只需在方法名前面加个 default 关键字即可实现默认方法。</p>
<h4 id="静态默认方法"><a href="#静态默认方法" class="headerlink" title="静态默认方法"></a>静态默认方法</h4><p>Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。</p>
<pre><code>public interface Vehicle &#123;
   default void print()&#123;
      System.out.println(&quot;我是一辆车!&quot;);
   &#125;
    // 静态方法
   static void blowHorn()&#123;
      System.out.println(&quot;按喇叭!!!&quot;);
   &#125;
&#125;
</code></pre>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p>
<p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p>
<h4 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h4><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作。</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
<li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>
</ul>
<h4 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h4><p>在 Java 8 中, 集合接口有两个方法来生成流：</p>
<ul>
<li>stream()  为集合创建串行流。</li>
<li>parallelStream()  为集合创建并行流。</li>
</ul>
<h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><ul>
<li>一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</li>
<li>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。 </li>
<li>Optional 类的引入很好的解决空指针异常。</li>
</ul>
<h3 id="日期时间API"><a href="#日期时间API" class="headerlink" title="日期时间API"></a>日期时间API</h3><p>通过发布新的Date-Time API  加强对日期与时间的处理。 </p>
<p>旧版日期时间API问题：</p>
<ul>
<li>非线程安全：java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</li>
<li>设计很差：Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字。</li>
<li>时区处理麻烦：日期类并不提供国际化，没有时区支持。</li>
</ul>
<p>Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：</p>
<ul>
<li>Local(本地) − 简化了日期时间的处理，没有时区的问题。</li>
<li>Zoned(时区) − 通过制定的时区处理日期时间。</li>
</ul>
<h4 id="本地化日期时间API"><a href="#本地化日期时间API" class="headerlink" title="本地化日期时间API"></a>本地化日期时间API</h4><p>LocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况。</p>
<h4 id="时区的时间日期API"><a href="#时区的时间日期API" class="headerlink" title="时区的时间日期API"></a>时区的时间日期API</h4><p>需要考虑到时区，就可以使用时区的日期时间API。</p>
<pre><code>public void testZonedDateTime()&#123;
    
  // 获取当前时间日期
  ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);
  System.out.println(&quot;date1: &quot; + date1);
    
  ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);
  System.out.println(&quot;ZoneId: &quot; + id);
    
  ZoneId currentZone = ZoneId.systemDefault();
  System.out.println(&quot;当期时区: &quot; + currentZone);
</code></pre>
<p>   }</p>
<h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>在Java 8中，Base64编码已经成为Java类库的标准。</p>
<p>Java 8 内置了 Base64 编码的编码器和解码器。</p>
<p>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p>
<ul>
<li>基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。</li>
<li>URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。</li>
<li>MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。</li>
</ul>
<h4 id="内嵌类"><a href="#内嵌类" class="headerlink" title="内嵌类"></a>内嵌类</h4><ol>
<li>static class Base64.Decoder  该类实现一个解码器用于，使用 Base64 编码来解码字节数据。</li>
<li>static class Base64.Encoder  该类实现一个编码器，使用 Base64 编码来编码字节数据。</li>
</ol>
<p>有多个get方法使用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/21/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%89%8B%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/21/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%89%8B%E6%9E%B6/" class="post-title-link" itemprop="url">什么是脚手架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-09-21 06:43:00 / 修改时间：06:50:35" itemprop="dateCreated datePublished" datetime="2020-09-21T06:43:00+08:00">2020-09-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="在我看来："><a href="#在我看来：" class="headerlink" title="在我看来："></a>在我看来：</h3><p>脚手架就是搭建的能直接从事业务开发的项目框架。比如整合并配置完成了：AOP/Swagger/Mybatis/Druid/通用工具类等。</p>
<h3 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h3><p>指的是两种技术：</p>
<ol>
<li>与某些MVC 框架中的数据库访问相关的代码生成技术</li>
<li>由各种工具支持的项目生成技术</li>
</ol>
<p>脚手架是一种由一些 model–view–controller 框架支持的技术，程序员可以在其中指定应用程序数据库的使用方式。该编译器或框架使用说明书中，与预先定义的代码模板在一起，产生最终代码的应用程序可以使用它来创建，读取，更新和删除数据库条目，有效治疗模板作为“ 支架 ”上建立更强大的应用程序。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/18/Spring/SpringMVC%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/18/Spring/SpringMVC%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/" class="post-title-link" itemprop="url">SpringMVC框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-18 18:33:00" itemprop="dateCreated datePublished" datetime="2020-09-18T18:33:00+08:00">2020-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-08 15:34:08" itemprop="dateModified" datetime="2021-02-08T15:34:08+08:00">2021-02-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SpringMVC框架"><a href="#SpringMVC框架" class="headerlink" title="SpringMVC框架"></a>SpringMVC框架</h1><p>springmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。</p>
<p>springmvc是一个基于mvc的web框架。</p>
<h3 id="什么是mvc"><a href="#什么是mvc" class="headerlink" title="什么是mvc"></a>什么是mvc</h3><p>mvc是一个设计模式。</p>
<h4 id="mvc在b-s系统下的应用"><a href="#mvc在b-s系统下的应用" class="headerlink" title="mvc在b/s系统下的应用"></a>mvc在b/s系统下的应用</h4><p><img src="https://i.loli.net/2020/09/18/L4xKMIndoywCD1q.jpg" alt="mvc在bs系统下的应用.jpg"></p>
<h4 id="springmvc的框架"><a href="#springmvc的框架" class="headerlink" title="springmvc的框架"></a>springmvc的框架</h4><p><img src="https://i.loli.net/2020/09/21/cETUaj26e9LoM5O.png" alt="springmvc框架1.PNG"><br><img src="https://i.loli.net/2020/09/21/BLzTq9XCuEKQdpP.jpg" alt="springmvc框架2.jpg"></p>
<p>组件：</p>
<ol>
<li>前端控制器 Dispatcherservlet：作用接受请求，响应结果，相当于转发器(非常重要)。</li>
<li>处理器映射器 HandlerMapping：根据请求的url查找Handler</li>
<li>处理器适配器 HandlerAdapter：按特定的规则执行Handler</li>
<li>处理器Handler（需要开发）:编写Handler按照HandlerAdapter的要求去做</li>
<li>视图解析器 View reolver：进行视图解析，根据逻辑视图名解析成真正的视图（view）</li>
<li>视图View（需要开发）：View是一个接口，实现类支持不同的View类型（jsp,freemarker,pdf…）</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/17/MQ%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/17/MQ%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">MQ介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-17 21:49:00" itemprop="dateCreated datePublished" datetime="2020-09-17T21:49:00+08:00">2020-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-08 15:34:48" itemprop="dateModified" datetime="2021-02-08T15:34:48+08:00">2021-02-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="MQ介绍"><a href="#MQ介绍" class="headerlink" title="MQ介绍"></a>MQ介绍</h2><p>消息队列，先进先出的数据结构。</p>
<p>发送方 –》 RPC –》 接受方<br>发送发 –》 消息发送MQ –》 有消息 –》 接受方</p>
<p>优点：</p>
<ul>
<li>应用解耦：不同系统之间通过 MQ存储消息 连接消息。</li>
<li>流量削峰：用户请求缓存到MQ中，系统在 MQ 中拉取支持的数量的请求。</li>
<li>数据分发：消息生产方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据即可。</li>
</ul>
<p>缺点：</p>
<ul>
<li>系统可用性降低：系统引入外部依赖越多，系统稳定性越差，一旦MQ宕机，会对业务造成影响。<ul>
<li>如何保证MQ的高可用？</li>
</ul>
</li>
<li>系统复杂度提高：MQ加入增加系统复杂度，以前系统间时同步的远程调用，现在是MQ进行异步调用。<ul>
<li>如何保证消息 没有被重复消费？怎么处理消息丢失情况？传递的顺序性？</li>
</ul>
</li>
<li>一致性问题？<ul>
<li>如何保证消息数据处理的一致性？</li>
</ul>
</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/17/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/17/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式（策略与单例）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-17 17:04:00" itemprop="dateCreated datePublished" datetime="2020-09-17T17:04:00+08:00">2020-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-08 15:33:43" itemprop="dateModified" datetime="2021-02-08T15:33:43+08:00">2021-02-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="为什么需要设计模式"><a href="#为什么需要设计模式" class="headerlink" title="为什么需要设计模式"></a>为什么需要设计模式</h2><p>设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。</p>
<p>新增功能（可扩展性），维护（可读性，规范性）项目变得容易<br>程序可靠，代码可重用。 </p>
<h2 id="为什么学习设计模式"><a href="#为什么学习设计模式" class="headerlink" title="为什么学习设计模式"></a>为什么学习设计模式</h2><p>如今程序员门槛越来越高。</p>
<p>在实际模式中使用过什么设计模式，怎样使用的，解决了什么问题。</p>
<h2 id="设计模式在软件的哪里"><a href="#设计模式在软件的哪里" class="headerlink" title="设计模式在软件的哪里"></a>设计模式在软件的哪里</h2><p>面向对象（OO）=&gt; 功能模块[设计模式+算法（数据结构）] =&gt; 框架[使用到多种设计模式] =&gt; 架构[服务器集群]</p>
<p>项目的某个功能用到设计模式，</p>
<h2 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h2><p>应用场景 -&gt; 设计模式 -&gt; 刨析原理 -&gt; 分析实现步骤步骤（图解） -&gt; 代码实现（对比） -&gt; 框架或项目源码分析（找到使用的地方）</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><ol>
<li><strong>代码重用性</strong>（相同功能的代码，不用多次编写）</li>
<li><strong>可读性高</strong>（编程规范性）</li>
<li><strong>可扩展性</strong>（增加新功能时，非常的方便）</li>
<li><strong>可靠性</strong>（增加功能，对原功能没有影响）</li>
<li><strong>程序高内聚，低耦合</strong>（AB模块的依赖性低）</li>
</ol>
<h3 id="金句"><a href="#金句" class="headerlink" title="金句"></a>金句</h3><p>懂了设计模式：就懂了面向对象分析和设计（OOA/D）的精要</p>
<h2 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h2><ol>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转原则</li>
<li>里氏替换原则</li>
<li>开闭原则</li>
<li>迪米特法则（最少知道原则）</li>
<li>复用合成原则</li>
</ol>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类应该只负责<strong>一项职责</strong>。如果负责两个不同的职责，职责1需求变更改变类时，可能造成职责2执行错误。</p>
<p>在类或方法上遵守单一职责原则。</p>
<h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol>
<li>降低类的复杂度</li>
<li>提高类的可读性，可维护性</li>
<li>降低变更的风险</li>
<li>通常应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法足够少，才可以在方法级别保持单一职责原则。</li>
</ol>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖建立在最小的接口上。</p>
<p>改进：将接口Interface1 <strong>拆分成为独立的几个接口</strong>，类与他们需要的接口建立依赖关系，也就是采用接口隔离原则。</p>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><ol>
<li>高层模块不应该依赖底层模块，都应该依赖其抽象。</li>
<li>抽象不因该依赖细节，细节应该依赖抽象。</li>
<li>依赖倒转（倒置）的中心思想时<strong>面向接口编程</strong>。</li>
<li><strong>设计理念：相对于细节（实现类）的多变性，抽象（接口或抽象类）的东西要稳定的多</strong>。</li>
<li>使用接口或抽象类的目的是<strong>指定好规范</strong>，不涉及任何具体操作，把展现细节的任务交给实现类去完成。</li>
</ol>
<h4 id="注意事项与细节"><a href="#注意事项与细节" class="headerlink" title="注意事项与细节"></a>注意事项与细节</h4><ol>
<li>底层模块尽量要有抽象类或接口，或者两者都有，程序稳定性更好。</li>
<li>变量的声明类型尽量都是抽象类或接口，这样变量引用和实际对象间，存在一个缓冲层，利于程序扩展和优化。</li>
<li>继承时遵循里氏替换原则。</li>
</ol>
<h4 id="依赖关系传递的三种方式"><a href="#依赖关系传递的三种方式" class="headerlink" title="依赖关系传递的三种方式"></a>依赖关系传递的三种方式</h4><ol>
<li>接口传递：方法参数声明类型尽量都是抽象类或接口，实现类实现方法。</li>
<li>构造方法传递：（创建一个接口成员）构造器给接口声明类型传递对象。</li>
<li>setter方法传递：（创建一个接口成员）setter给接口声明类型传递对象。</li>
</ol>
<h4 id="应用实例分析"><a href="#应用实例分析" class="headerlink" title="应用实例分析"></a>应用实例分析</h4><ol>
<li>如果我们获取的对象是微信，短信等等，则新增类，同时Perons也要增加相应的接受方法</li>
<li>解决思路，引入一个抽象的接口IReceiver，表示接收者，这样Person类与接口发送，因为Email，WeiXin 等等属于接受的范围，他们各自实现IReceiver接口就ok，这样我们就符合依赖倒转原则。</li>
</ol>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><h4 id="继承的弊端"><a href="#继承的弊端" class="headerlink" title="继承的弊端"></a>继承的弊端</h4><ol>
<li>父类中已经实现好的方法，是在设定规范和契约，如果子类对这些方法任意修改，可能会对整个继承体系造成破环。</li>
<li>继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，父类修改，必须考虑到所有的子类。</li>
</ol>
<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</p>
<p>继承实际上让两个类耦合性增强，在适当的情况下，可以通过<strong>聚合，组合，依赖</strong>来解决问题。</p>
<pre><code>如果父类A 子类B B 继承自 A
如果要修改父类A中的方法
让A类 与 B类 都继承刚高级的 C类。在C类中创建新方法
</code></pre>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>编程中最基础，最重要的设计原则</p>
<p>扩展开放，修改关闭。</p>
<p><strong>当软件需要变化时，扩展软件实体的行为来变化。而不是通过修改已有的代码。</strong></p>
<p>编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>别名：直接朋友原则，最少知道原则</p>
<p>一个类<strong>对自己依赖的类知道的越少越好</strong>，被依赖的类不管多麽复杂，都尽量将逻辑封装在类的内部，对外除了提供public方法，不对外泄露任何信息。</p>
<p><strong>直接朋友</strong>：每个对象都会与其他对象有耦合关系即为朋友关系。耦合的方式有很多，依赖，关联，组合，聚合等。我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，出现在局部变量中的类不是直接朋友，不是直接朋友最好不要以局部变量的形式出现在类的内部。</p>
<p><strong>不要再其他类中的方法中使用自己的类构造的对象，可以在自己类中设计出这个方法。</strong></p>
<h4 id="注意事项和细节-1"><a href="#注意事项和细节-1" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol>
<li>核心：降低类之间的耦合。</li>
<li>每个类都减少了不必要的依赖。（必要的依赖为直接的朋友）</li>
</ol>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>尽量使用合成/聚合的方式，而不是使用继承。</p>
<p>依赖（类似合成）：B类中方法使用A类作为参数。<br>组合：B类成员变量直接newA类<br>聚合：B类成员变量setA类</p>
<h2 id="设计原则的核心思想"><a href="#设计原则的核心思想" class="headerlink" title="设计原则的核心思想"></a>设计原则的核心思想</h2><ol>
<li>找出应用中可能需要变化之处独立出来。</li>
<li>针对接口编程。</li>
<li>为了交互对象之间的松耦合设计而努力。</li>
</ol>
<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li>UML–unified modeling language(统一建模语言)是一种用于软件系统分析和设计的语言工具。</li>
<li>UML本身是一套符号的规定，用于描述软件模型中的各个元素和他们之间的关系，比如类，接口，实现，泛化，依赖，组合，聚合等。</li>
</ol>
<p><img src="https://i.loli.net/2020/09/27/mpQvHI34kNJ9q7X.jpg" alt="UML类图的符号意义.jpg"> </p>
<h3 id="UML图分类"><a href="#UML图分类" class="headerlink" title="UML图分类"></a>UML图分类</h3><ol>
<li>用例图</li>
<li>静态结构图：类图，对象图，包图，组件图，部署图</li>
<li>动态行为图：交互图（时序图与协作图），状态图，活动图</li>
</ol>
<h2 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h2><ol>
<li>用于描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系。</li>
<li>类之间的关系：依赖，泛化（继承），实现，关联，聚合与组合</li>
</ol>
<h3 id="依赖关系-Dependence"><a href="#依赖关系-Dependence" class="headerlink" title="依赖关系(Dependence)"></a>依赖关系(Dependence)</h3><ol>
<li>类中用到了对方，就存在依赖关系。</li>
<li>可以是类的成员属性</li>
<li>可以是方法的返回类型</li>
<li>可以是方法接收的参数类型</li>
<li>方法中使用到</li>
</ol>
<h3 id="泛化关系（Generalization）"><a href="#泛化关系（Generalization）" class="headerlink" title="泛化关系（Generalization）"></a>泛化关系（Generalization）</h3><p>其实就是继承关系，是依赖关系的特例。</p>
<h3 id="实现关系（Implementation，Realization）"><a href="#实现关系（Implementation，Realization）" class="headerlink" title="实现关系（Implementation，Realization）"></a>实现关系（Implementation，Realization）</h3><p>A类实现B类，是依赖关系的特例。</p>
<h3 id="关联关系（Association）"><a href="#关联关系（Association）" class="headerlink" title="关联关系（Association）"></a>关联关系（Association）</h3><p>是类与类之间的联系，是依赖关系的特例。</p>
<p>关联具有到航性：即双向关系或单项关系</p>
<p>关系具有多重性：1表示有且仅有一个，0…表示0个或多个，“0，1”表示0个多一个，“n…m”表示n到m个都可以，“m…”表示至少m个。</p>
<h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>表示的是整体和部分的关系，整体与部分是可以分开的。是关联关系的特例，具有关联的导航性与多重性。</p>
<p>类似定义成员变量和set方法。</p>
<h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>整体和部分是不可分离的，升级为组合关系。</p>
<p>类似成员变量new对象。</p>
<h1 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的概述"><a href="#设计模式的概述" class="headerlink" title="设计模式的概述"></a>设计模式的概述</h2><p>设计模式分三种类型，共23种设计模式。</p>
<h3 id="掌握设计模式的层次"><a href="#掌握设计模式的层次" class="headerlink" title="掌握设计模式的层次"></a>掌握设计模式的层次</h3><p><img src="https://i.loli.net/2020/09/28/lfCRadB4TONp9bG.jpg" alt="掌握设计模式的层次.jpg"></p>
<h3 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h3><ol>
<li>创建型模式：单例模式，抽象工厂模式，原型模式，建造者模式，工厂模式。</li>
<li>结构型模式：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。</li>
<li>行为型模式：模板方法模式，命令模式，访问者模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式（责任链模式）</li>
</ol>
<h2 id="单例模式-看study-java的面试题部分"><a href="#单例模式-看study-java的面试题部分" class="headerlink" title="单例模式-看study-java的面试题部分"></a>单例模式-看study-java的面试题部分</h2><p>保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。</p>
<h3 id="单例模式有八种方式"><a href="#单例模式有八种方式" class="headerlink" title="单例模式有八种方式"></a>单例模式有八种方式</h3><ol>
<li><strong>饿汉式（静态常量）</strong></li>
<li><strong>饿汉式（静态代码块）</strong></li>
<li>懒汉式（线程不安全）</li>
<li>懒汉式（线程安全，同步方法）</li>
<li>懒汉式（线程安全，同步代码块）</li>
<li><strong>双重检查</strong></li>
<li><strong>静态内部类</strong></li>
<li><strong>枚举</strong></li>
</ol>
<h3 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>构造器私有化（防止new）</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/lwTHAduB6DvfpZK.jpg" alt="饿汉式-静态变量.jpg"></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>优点：写法简单，在类装载是完成实例化。避免了线程公布问题</li>
<li>缺点：在类装载时完成实例化，没有达到懒加载（Lazy Loading）的效果。如果从始至终从未使用过实例，会造成内存的浪费。</li>
<li>结论：可用，但是可能会造成内存浪费。</li>
</ol>
<h3 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h3><ol>
<li>构造器私有化（防止new）</li>
<li>类的内部创建对象变量</li>
<li>在静态代码块中，实例化对象</li>
<li>向外暴露一个静态的公共方法</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/28DIqLhlwWSpyEe.jpg" alt="饿汉式-静态代码块.jpg"></p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>与上面方式类似，只不过将类的实例化放在静态代码块中，也是在类装载时执行静态代码块中的代码，初始化类的实例。优缺点与上面相同。</li>
<li>结论：可用，但是可能内存浪费。</li>
</ol>
<h3 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h3><ol>
<li>构造器私有化</li>
<li>本类内部创建变量</li>
<li>共有的静态方法，当使用到该方法时，才去创建instance，返回实例对象</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/swJWAPpTCrdvgbz.jpg" alt="懒汉式-线程不安全.jpg"></p>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>起到了Lazy Loading的效果，但是只能在单线程下使用。</li>
<li>结论：在实际开发中，不要使用这种方式。</li>
</ol>
<h3 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h3><ol>
<li>构造私有化</li>
<li>本类内部创建变量</li>
<li>共有的静态方法，加入同步处理的代码，当使用到该方法时，才去创建instance，返回实例对象</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/Zhz2mljsDw1iRCJ.jpg" alt="懒汉式-线程安全同步方法.jpg"></p>
<h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>解决了线程不安全问题</li>
<li>效率太低，每次执行getInstance()方法都要同步。</li>
<li>结论：在实际开发中，不推荐使用这种方式。</li>
</ol>
<h3 id="懒汉式（线程安全，同步代码块）"><a href="#懒汉式（线程安全，同步代码块）" class="headerlink" title="懒汉式（线程安全，同步代码块）"></a>懒汉式（线程安全，同步代码块）</h3><ol>
<li>构造私有化</li>
<li>本类内部创建变量</li>
<li>共有的静态方法，加入同步处理的代码块，当使用到该方法时，才去创建instance，返回实例对象</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/qxPXbRVd4sa9kDG.jpg" alt="懒汉式-同步代码块.jpg"></p>
<h4 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>这种同步比更不能起到线程同步的作用。假如一个线程进入了if判断语句块，另一个线程通过了这个判断语句，便会产生多个实例。</li>
<li>结论：在实际开发中，不能使用这种方式。</li>
</ol>
<h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><ol>
<li>构造私有化</li>
<li>本类内部创建变量，使用volatile修饰，有修改直接到主存里面</li>
<li>共有的静态方法，双重检查，解决线程安全，同时解决懒加载。</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/f3aWYZM5xbEV1go.jpg" alt="双重检查.jpg"></p>
<p>使用volatile修饰成员变量。</p>
<h4 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>Double-Check概念是多线程开发中常使用到的。可以保证线程安全。</li>
<li>线程安全，延迟加载，效率较高。</li>
<li>结论：在实际开发中，推荐使用这种单例设计模式。</li>
</ol>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><ol>
<li>构造私有化</li>
<li>静态内部类，一个静态属性Singleton</li>
<li>静态共有方法直接返回SingletonInstance.INSTANCE。</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/CVc3qFDhETH9pO1.jpg" alt="单例-静态内部类.jpg"></p>
<p>类装载的时候，内部类不会被装载。只有调用内部类的时候才会装载一次。</p>
<h4 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>采用类装载机制保证初始化实例时只有一个线程。</li>
<li>类的静态属性只会在第一次加载类的时候初始化，JVM保证线程安全。</li>
<li>优点：线程安全，利用静态内部类实现延迟加载，效率高。</li>
<li>结论：推荐使用。</li>
</ol>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="https://i.loli.net/2020/09/28/leuQHjMXGkDYF2A.jpg" alt="单例-枚举.jpg"></p>
<h4 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>借助JDK1.5中添加的枚举来实现单例模式，避免多线程同步，还能防止反序列化才重新创建新的对象。</li>
<li>结论：推荐使用。</li>
</ol>
<h3 id="单例模式注意事项"><a href="#单例模式注意事项" class="headerlink" title="单例模式注意事项"></a>单例模式注意事项</h3><ol>
<li>单例模式保证了系统内存中，该类只存在一个对象。对于一些频繁创建销毁的对象，单例模式可以提高系统性能。</li>
<li>实例化单例类时，要使用相应的获取对象的方法。</li>
<li>单例模式使用场景：频繁的进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多（重量级对象），但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）</li>
</ol>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>定义一个创建对象的类，来封装实例化对象的行为。</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式：将可变的部分从程序中抽象出来分离成算法接口，在该接口下分别封装一系列算法实现。</p>
<p><img src="https://i.loli.net/2020/09/17/N4b3qvGBMWDZoLu.jpg" alt="策略模式.jpg"></p>
<h3 id="设计策略模式："><a href="#设计策略模式：" class="headerlink" title="设计策略模式："></a>设计策略模式：</h3><p>Hero抽象类：</p>
<pre><code>public abstract class Hero &#123;
    //英雄的名称
    private String heroName;
    //英雄的召唤师技能的接口（组合关系,需要使用时，需要传入一个具体的技能对象）
    private ISkill iSkill;

    //自我介绍的方法
    public abstract void display();
    //普通攻击的方法
    public abstract void normalAttack();
    //召唤师技能的使用方法
    public void skill()&#123;
        iSkill.useSkill();
    &#125;
</code></pre>
<p>HouYi实现类：</p>
<pre><code>public class HouYi extends Hero&#123;
    //编写构造方法
    public HouYi() &#123;
        super.setHeroName(&quot;后羿&quot;);
    &#125;
</code></pre>
<p>ISkill接口：</p>
<pre><code>public interface ISkill &#123;
    //使用召唤师技能的方法
    public abstract void useSkill();
&#125;
</code></pre>
<p>JiPao接口实现类：</p>
<pre><code>public class JiPao implements ISkill &#123;
    @Override
    public void useSkill() &#123;
        System.out.println(&quot;疾跑技能。增加移速。&quot;);
    &#125;
&#125;
</code></pre>
<p>调用：</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol>
<li>找出需要变化的部分，独立出来做成算法接口。</li>
<li>面向接口编程，而不是面向实现。</li>
<li>多用组合，少用继承。</li>
</ol>
<p>优点：</p>
<ol>
<li><strong>使用组合</strong>，而不单单继承，使得架构更加灵活。</li>
<li>富有弹性，<strong>可以较好的应对未来的变化</strong>。（开-闭原则）</li>
<li>更好的代码复用性。（相对于继承）</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加了对象的数量（每个接口都做成一个对象）。</li>
</ol>
<p>​    </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/17/MySQL/Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="genuine nonage">
      <meta itemprop="description" content="菜鸡">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | genuine nonage">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/17/MySQL/Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">Mysql</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-09-17 11:04:00 / 修改时间：17:59:10" itemprop="dateCreated datePublished" datetime="2020-09-17T11:04:00+08:00">2020-09-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="索引数据结构红黑树，Hash表，B-Tree"><a href="#索引数据结构红黑树，Hash表，B-Tree" class="headerlink" title="索引数据结构红黑树，Hash表，B+Tree"></a>索引数据结构红黑树，Hash表，B+Tree</h2><p>二叉树，红黑树，Hash表，B-Tree。</p>
<h3 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h3><p>索引是帮助Mysql高效获取数据的排好序的数据结构。</p>
<p>红黑树本质也是二叉树，不过可以自动平衡，不让二叉树一边叶子过长。</p>
<p>Hash：哈希算法：哈希散列值结果就是磁盘文件地址。</p>
<ul>
<li>不管表记录有多少，都能快速定位表数据的位置。</li>
<li>但是不能很好解决范围查找。</li>
</ul>
<p>B-Tree： </p>
<ul>
<li>叶子节点具有相同的深度，存放数据。</li>
<li>所有索引元素不重复。</li>
<li>节点中的数据索引从左到右递增排列。</li>
</ul>
<p>B+Tree：每个数据节点都能快速找到相邻节点（节点之间双向指针）。</p>
<ul>
<li>   非叶子节点不存储data，只存储索引（非叶子节点冗余索引），可以放更多的索引。</li>
<li>   叶子界定啊包含所有索引字段</li>
<li> 叶子节点用指针链接，提高区间访问的性能。</li>
<li>提高范围查找的性能。</li>
</ul>
<h3 id="B-Tree与B-Tree的不同："><a href="#B-Tree与B-Tree的不同：" class="headerlink" title="B-Tree与B+Tree的不同："></a>B-Tree与B+Tree的不同：</h3><ul>
<li><p>B+Tree叶子节点之间增加双向指针，B-Tree叶子节点之间没有。</p>
</li>
<li><p>B+Tree非叶子简单不存放数据，只存放索引（所以造成冗余索引）；B-Tree所有节点都存放数据，没有冗余索引。</p>
</li>
<li><p>在树的高度相同的情况下，B+Tree能放的数据更多。</p>
</li>
</ul>
<h2 id="千万级数据表快速查找"><a href="#千万级数据表快速查找" class="headerlink" title="千万级数据表快速查找"></a>千万级数据表快速查找</h2><p>Mysql底层数据结构：B+Tree（B-Tree变种）：多叉查找(x&lt;y&lt;=z]</p>
<p>B+Tree的索引每个节点大小：16kb</p>
<p>数据库有存储引擎的概念。表级别的概念。INNODB/MYISAM</p>
<p>MYISAM（非聚集索引）:</p>
<pre><code>frm表结构信息
MYD存储数据
MYI存储B+Tree的索引。
</code></pre>
<p>INNODB（聚集索引）: </p>
<pre><code>frm表结构信息
ibd索引和数据在一起
</code></pre>
<h2 id="基于B-Tree高性能索引"><a href="#基于B-Tree高性能索引" class="headerlink" title="基于B+Tree高性能索引"></a>基于B+Tree高性能索引</h2><p>INNODB索引实现（聚集）</p>
<ul>
<li>表数据文件本身就是按B+Tree组织的一个索引结构的文件。</li>
<li>聚集索引：叶子节点包含了完整的数据记录。</li>
<li>为什么INNODB表必须有主键，并且建议整型自增。<ul>
<li>如果没有主键，mysql找字段中的唯一字段作为索引，如果都没有，MySQL会创建一个隐藏列。不要增加MySQL的性能负担。</li>
<li>主键不要使用UUID（UUID不是整形也不是自增），B+树经常比大小，整形比大小快，上产环境高速SSD成本高。</li>
<li>在B+Tree数据结构中，自增树插入对B+Tree树的分裂小（B+Tree会自动优化分裂树的结构，保证在一定的规范下），随机树插入对B+Tree的分裂大</li>
</ul>
</li>
<li>为什么主键索引结构叶子节点存储的是主键值？（一致性和节省存储空间）</li>
</ul>
<h2 id="联合索引底层数据结构"><a href="#联合索引底层数据结构" class="headerlink" title="联合索引底层数据结构"></a>联合索引底层数据结构</h2><p>KEY ‘idx_name_age_position’ （’name’,’age’,’position’) USING BTREE</p>
<p>根据索引字段的顺序进行比较。先比较name后age后position</p>
<p><img src="https://i.loli.net/2020/09/17/pN3KRCx4UtlBEPi.jpg" alt="联合索引底层数据结构.jpg"></p>
<p>最左前缀优化：因为联合索引底层已经实现了</p>
<pre><code>explain select * from employees where name=&#39;Bill&#39; and age=31;
</code></pre>
<p>还有很多的知识需要学习。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QB</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"genuinenonage/comments","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
