---
title: Java垃圾回收GC
date: 2020/7/22 16:09:00
updated: 2020/7/28 09:48:00
tags:
- Java
categories: 
- Java
---
## Java垃圾回收GC  
Barbage Collection  
Java有C++发展来的，摒弃了C++一些繁琐容易出错额东西，其中GC。C#借鉴了Java。  
程序员不需要再手动的去控制内存的释放。Java虚拟机或.NEXTCLR 会自动去清理无用对象 所占用的内存空间。  
程序中也可以显式的使用：System.gc() / System.GC.Collect() 强制进行一次立即的内存清理。  
当一个对象不再被引用的时候，内存回收它所占用的内存空间，以便空间被后来的新对象使用。除了释放没用的对象，垃圾收集也可以清除内存记录碎片。  
1. 引用计数法（Reference Counting Collector）  
引用计数法是唯一没有使用根集的垃圾回收的算法。该算法使用引用计数器来区分存活对象和不再使用的对象。一般来说，堆中的每个对象对应一个引用计数器。  
	* 当每一次常见一个对象并赋给变量时，引用计数器置为1。  
	* 当对象被赋给任意变量时，引用计数器每次加1。  
	* 当对象出了作用域后（该对象丢弃不再使用），引用计数器减1。  
	* 引用计数器为0，对象就满足了垃圾收集的条件。  
基于引用计数器的垃圾收集器运行较快，不会长时间中断程序执行，适宜地必须实时运行的程序。但引用计数器增加了程序执行的开销，每次对象赋给新的变量，计数器加1，每次现有对象出了作用域，计数器减1。  
2. tracing算法（Tracing Collector）  
tracing算法为了解决引用计数法的问题而提出，使用了根集的概念。基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，那些对象不可达，并用某种方式标记可达对象，例如的对每个可达对象设置一个或多个位。在扫描识别过程中，基于tracing算法的垃圾收集也称为标记和清除（mark-and-sweep）垃圾收集器。  
3. compacting算法（Compacting collector）  
为了解决堆碎片问题，基于tracing的垃圾回收吸收了Compacting算法的思想，在清除的过程中，算法将所有的对象移到堆的一端，堆的另一端变成了一个相邻的空闲内存区，收集器会对它移动的所有对象的所有引用进行更新，使得这些引用在新的位置能识别原来的对象。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。  
4. copying算法（Coping Collector）  
该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。  

