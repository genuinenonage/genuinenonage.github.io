---
title: 并发编程基础
date: 2020/8/24 15:04:00
tags: 
- java
- 并发
categories:
- 并发
---

ArrayList线程不安全，他的读写方法没有同步策略，会导致脏数据和不可预期的结果。

## 原子性  
读-改-写操作，线程要么全部执行，要么全部不执行。  
使用Synchronized可以实现线程安全，即实现可见性和同步，但是Synchronized是独占锁，没有获得内部锁的线程会被阻塞掉。  

### 原子变量类  
原子变量类比锁更轻巧，比如AtomicLong代表了一个Long值，并提供了get,set方法，get，set方法语义和volatile相同，因为AtomicLong内部就是使用了volatile修饰的真正的Long变量。另外提供了原子性的自增自减操作。  
相比使用Synchronized的好处在于原子类操作不会导致线程的挂起和重新调度，内部使用的是cas的非阻塞算法。  
常用的原子类为：AtomicLong,AtomicInteger,AtomicBoolean,AtomicReference。  
## CAS  
CAS（CompareAndSet） 比较并设置。  
CAS有三个操作数：内存位置，旧的预期值，新的值。  
当内存位置的变量值为旧的预期值时，使用新的值替换旧的值，否则返回旧的值。这个处理器提供的一个原子性指令。  

	for (;;) {
        long current = get();（1）
        long next = current + 1;（2）
        if (compareAndSet(current, next))（3）
            return next;
    }

这里使用了无限循环使用CAS进行轮询检查，一定程度上浪费了cpu，但是相比锁避免了线程的上下文切换和调度。  

## 可重入锁  
一个线程要获取被其他线程占用的锁时，线程会被阻塞。  
可重入锁：当线程再次获取他自己已经获取的锁时，不会被阻塞。只要线程获得了该锁，可以无限制次数进入被该锁锁住的代码。 

如果内置锁不是可重入的那么该调用就会导致死锁了，因为线程持有并等待了锁。  
 
实际上内部锁是可重入锁，例如synchronized关键字管理的方法，可重入锁的原理是在锁内部维护了一个线程标示，标示该锁目前被那个线程占用，关联一个计数器，一开始计数器值为0，说明该锁没有被任何线程占用，当一个线程获取了该锁，计数器会变成1，其他线程在获取该锁时候发现锁的所有者不是自己所以被阻塞，但是当获取该锁的线程再次获取锁时候发现锁拥有者是自己会把计数器值+1， 当释放锁后计数器会-1，当计数器为0时候，锁里面的线程标示重置为null,这时候阻塞的线程会获取被唤醒来获取该锁。  
## Synchronized关键字  
synchronized块是Java提供的一种强制性内置锁，执行代码在进入synchronized代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时候会阻塞掉。拿到内部锁的线程会在正常退出同步代码块或者异常抛出后释放内部锁，这时候阻塞掉的线程才能获取内部锁进入同步代码块。  

线程A进入同步块修改变量值后，会在退出同步块前把值刷新到主内存，而线程B在进入同步块前会首先清空本地内存内容，从主内存重新获取变量值，所以实现了可见性。但是要注意一点所有线程使用的是同一个锁。  

注意 Synchronized关键字会引起线程上下文切换和线程调度。  

## ReentrantReadWriteLock  
Synchronized可以实现同步，但是只有一个线程访问共享变量。正常情况下，对于多个读操作时不需要同步。而大部分情况下读操作次数多于写操作，ReentrantReadWriteLock，可以实现读写分离，多个线程同时进行读取，但是最多一个写线程存在。  
##### 代码示例  
	public class ArrayList<E>
	{
		private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
		public E get(int index){
			Lock readLock = readWriteLock.readLock();
			readLock.lock();
			try{
				return list.get(index);
			}finally{
				readLock.unlock();
			}
		}
		public E set(int index, E element){
			Lock wirteLock = readWriteLock.writeLock();
			wirteLock.lock();
			try{
				return list.set(index, element);
			}finally{
				wirteLock.unlock();
			}
		}
	}

get方法readWriteLock.readLock()获取读锁，多个线程可获得。  
set方法readwriteLock.writeLock()获取写锁，一个线程可获得，其他线程会被阻塞。  
一个线程获得了读锁，要获得写锁需要等待释放读锁    
一个线程获得了写锁，要获取读锁需要等待释放写锁   
相比Synchronized来说运行多个读者同时存在，提高了并发量。  
** 注意：需要显示调用Lock与unlock操作。** 
 
## Volatile变量  
注意 volatile关键字不会引起线程上下文切换和线程调度。另外volatile还用来解决重排序问题。  
## 乐观锁与悲观锁  
### 悲观锁  
指数据被外界修改持保守态度(悲观)，在数据处理过程中，数据处于锁定状态。悲观锁的实现依靠数据库的锁机制。  
数据库中实现对数据记录操作前，先给记录加排它锁，如果获取锁失败，则说明数据正在被其他线程修改，则等待或者抛出异常。如果加锁成功，则获取记录，对其修改，然后事务提交后释放排它锁。  
一个例子：select * from 表 where .. for update;

悲观锁是先加锁再访问策略，处理加锁会让数据库产生额外的开销，还有增加产生死锁的机会，另外在多个线程只读情况下不会产生数据不一致行问题，没必要使用锁，只会增加系统负载，降低并发性，因为当一个事务锁定了该条记录，其他读该记录的事务只能等待。

#### 悲观锁详细操作

### 乐观锁  
乐观锁是相对悲观锁来说的，它认为数据一般情况下不会造成冲突，所以在访问记录前不会加排他锁，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，具体说根据update返回的行数让用户决定如何去做。乐观锁并不会使用数据库提供的锁机制，一般在表添加version字段或者使用业务状态来做。  

乐观锁直到提交的时候才去锁定，所以不会产生任何锁和死锁。  


#### 乐观锁详细操作 

## 独占锁与共享锁  
根据锁能够被单个线程还是多个线程共同持有，锁又分为独占锁和共享锁。  
独占锁保证任何时候都只有一个线程能读写权限，ReentrantLock就是以独占方式实现的互斥锁。  
共享锁则可以同时有多个读线程，但最多只能有一个写线程，读和写是互斥的，例如ReadWriteLock读写锁。  
 
独占锁是一种悲观锁，每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据一致性，而独占锁只允许同时一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。

共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。  

## 公平锁与非公平锁  
根据线程获取锁的抢占机制锁可以分为公平锁和非公平锁。  
公平锁表示线程获取锁的顺序是按照线程加锁的时间多少来决定的，也就是最早加锁的线程将最早获取锁，也就是先来先得的FIFO顺序。而非公平锁则运行闯入，也就是先来不一定先得。  

ReentrantLock提供了公平和非公平锁的实现：  
公平锁ReentrantLock pairLock = new ReentrantLock(true);  
非公平锁 Reen trantLock pairLock = new ReentrantLock(false);  
如果构造函数不传递参数，则默认是非公平锁。  
在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销。  

