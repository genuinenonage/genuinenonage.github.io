---
title: 并发编程基础
date: 2020/8/24 15:04:00
tags: 
- java
- 并发
categories:
- 并发
---

ArrayList线程不安全，他的读写方法没有同步策略，会导致脏数据和不可预期的结果。

## 原子性  
读-改-写操作，线程要么全部执行，要么全部不执行。  
使用Synchronized可以实现线程安全，即实现可见性和同步，但是Synchronized是独占锁，没有获得内部锁的线程会被阻塞掉。  

### 原子变量类  
原子变量类比锁更轻巧，比如AtomicLong代表了一个Long值，并提供了get,set方法，get，set方法语义和volatile相同，因为AtomicLong内部就是使用了volatile修饰的真正的Long变量。另外提供了原子性的自增自减操作。  
相比使用Synchronized的好处在于原子类操作不会导致线程的挂起和重新调度，内部使用的是cas的非阻塞算法。  
常用的原子类为：AtomicLong,AtomicInteger,AtomicBoolean,AtomicReference。  
## CAS  
CAS（CompareAndSet） 比较并设置。  
CAS有三个操作数：内存位置，旧的预期值，新的值。  
当内存位置的变量值为旧的预期值时，使用新的值替换旧的值，否则返回旧的值。这个处理器提供的一个原子性指令。  

	for (;;) {
        long current = get();（1）
        long next = current + 1;（2）
        if (compareAndSet(current, next))（3）
            return next;
    }

这里使用了无限循环使用CAS进行轮询检查，一定程度上浪费了cpu，但是相比锁避免了线程的上下文切换和调度。  

## 可重入锁  
一个线程要获取被其他线程占用的锁时，线程会被阻塞。  
可重入锁：当线程再次获取他自己已经获取的锁时，不会被阻塞。只要线程获得了该锁，可以无限制次数进入被该锁锁住的代码。 

如果内置锁不是可重入的那么该调用就会导致死锁了，因为线程持有并等待了锁。  
 
实际上内部锁是可重入锁，例如synchronized关键字管理的方法，可重入锁的原理是在锁内部维护了一个线程标示，标示该锁目前被那个线程占用，关联一个计数器，一开始计数器值为0，说明该锁没有被任何线程占用，当一个线程获取了该锁，计数器会变成1，其他线程在获取该锁时候发现锁的所有者不是自己所以被阻塞，但是当获取该锁的线程再次获取锁时候发现锁拥有者是自己会把计数器值+1， 当释放锁后计数器会-1，当计数器为0时候，锁里面的线程标示重置为null,这时候阻塞的线程会获取被唤醒来获取该锁。  
## Synchronized关键字  
synchronized块是Java提供的一种强制性内置锁，执行代码在进入synchronized代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时候会阻塞掉。拿到内部锁的线程会在正常退出同步代码块或者异常抛出后释放内部锁，这时候阻塞掉的线程才能获取内部锁进入同步代码块。  

线程A进入同步块修改变量值后，会在退出同步块前把值刷新到主内存，而线程B在进入同步块前会首先清空本地内存内容，从主内存重新获取变量值，所以实现了可见性。但是要注意一点所有线程使用的是同一个锁。  

注意 Synchronized关键字会引起线程上下文切换和线程调度。  

## ReentrantReadWriteLock  
Synchronized可以实现同步，但是只有一个线程访问共享变量。正常情况下，对于多个读操作时不需要同步。而大部分情况下读操作次数多于写操作，ReentrantReadWriteLock，可以实现读写分离，多个线程同时进行读取，但是最多一个写线程存在。  
##### 代码示例  
	public class ArrayList<E>
	{
		private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
		public E get(int index){
			Lock readLock = readWriteLock.readLock();
			readLock.lock();
			try{
				return list.get(index);
			}finally{
				readLock.unlock();
			}
		}
		public E set(int index, E element){
			Lock wirteLock = readWriteLock.writeLock();
			wirteLock.lock();
			try{
				return list.set(index, element);
			}finally{
				wirteLock.unlock();
			}
		}
	}

get方法readWriteLock.readLock()获取读锁，多个线程可获得。  
set方法readwriteLock.writeLock()获取写锁，一个线程可获得，其他线程会被阻塞。  
一个线程获得了读锁，要获得写锁需要等待释放读锁    
一个线程获得了写锁，要获取读锁需要等待释放写锁   
相比Synchronized来说运行多个读者同时存在，提高了并发量。  
** 注意：需要显示调用Lock与unlock操作。** 
 
## Volatile变量  
