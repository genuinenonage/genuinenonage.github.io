---
title: 并发编程基础
date: 2020/8/24 15:04:00
tags: 
- java
- 并发
categories:
- 并发
---

ArrayList线程不安全，他的读写方法没有同步策略，会导致脏数据和不可预期的结果。

## 原子性  
读-改-写操作，线程要么全部执行，要么全部不执行。  
使用Synchronized可以实现线程安全，即实现可见性和同步，但是Synchronized是独占锁，没有获得内部锁的线程会被阻塞掉。  

### 原子变量类  
原子变量类比锁更轻巧，比如AtomicLong代表了一个Long值，并提供了get,set方法，get，set方法语义和volatile相同，因为AtomicLong内部就是使用了volatile修饰的真正的Long变量。另外提供了原子性的自增自减操作。  
相比使用Synchronized的好处在于原子类操作不会导致线程的挂起和重新调度，内部使用的是cas的非阻塞算法。  
常用的原子类为：AtomicLong,AtomicInteger,AtomicBoolean,AtomicReference。  
## CAS  
CAS（CompareAndSet） 比较并设置。  
CAS有三个操作数：内存位置，旧的预期值，新的值。  
当内存位置的变量值为旧的预期值时，使用新的值替换旧的值，否则返回旧的值。这个处理器提供的一个原子性指令。  

	for (;;) {
        long current = get();（1）
        long next = current + 1;（2）
        if (compareAndSet(current, next))（3）
            return next;
    }

这里使用了无限循环使用CAS进行轮询检查，一定程度上浪费了cpu，但是相比锁避免了线程的上下文切换和调度。  

## 可重入锁  
一个线程要获取被其他线程占用的锁时，线程会被阻塞。  
可重入锁：当线程再次获取他自己已经获取的锁时，不会被阻塞。只要线程获得了该锁，可以无限制次数进入被该锁锁住的代码。 

如果内置锁不是可重入的那么该调用就会导致死锁了，因为线程持有并等待了锁。  
 
实际上内部锁是可重入锁，例如synchronized关键字管理的方法，可重入锁的原理是在锁内部维护了一个线程标示，标示该锁目前被那个线程占用，关联一个计数器，一开始计数器值为0，说明该锁没有被任何线程占用，当一个线程获取了该锁，计数器会变成1，其他线程在获取该锁时候发现锁的所有者不是自己所以被阻塞，但是当获取该锁的线程再次获取锁时候发现锁拥有者是自己会把计数器值+1， 当释放锁后计数器会-1，当计数器为0时候，锁里面的线程标示重置为null,这时候阻塞的线程会获取被唤醒来获取该锁。  
## Synchronized关键字  
