<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Powerdesigner使用</title>
    <url>/2021/04/14/20210414-Powerdesigner%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="E-R-CDM-PDM"><a href="#E-R-CDM-PDM" class="headerlink" title="E-R/CDM/PDM"></a>E-R/CDM/PDM</h3><p>概念数据模型也称信息模型，以实体-联系（entity-relationShip，简称E-R）理论为基础。从用户的观点出发对信息进行建模，主要用于数据库的概念级设计。</p>
<p>将现实世界中的客观对象抽象为实体和联系。它不依赖于具体的计算机系统或某个DBMS系统，这种模型就是CDM。</p>
<p>将CDM转换为计算机上某个DBMS所支持的数据库模型，即物理数据模型PDM。</p>
<h3 id="PDM模型和CDM模型之间的相互转换"><a href="#PDM模型和CDM模型之间的相互转换" class="headerlink" title="PDM模型和CDM模型之间的相互转换"></a>PDM模型和CDM模型之间的相互转换</h3><p>菜单Tool 里面的Generate to Conceptual Data Models上面也有快捷键：</p>
<ul>
<li><p>如果pdm转cdm：ctrl＋shift＋c </p>
</li>
<li><p>如果cdm转pdm：ctrl＋shift＋p</p>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>powerdesigner</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的使用</title>
    <url>/2020/07/15/Git/</url>
    <content><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p><img src="https://i.loli.net/2020/12/14/VyaOrLifJoc4Hth.png" alt="image.png"></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li>初始化本地仓库  <blockquote>
<p>git init git_work(仓库文件夹名称) &amp;&amp; cd git_work  </p>
</blockquote>
</li>
<li>将变化提交到暂存区  <blockquote>
<p>git add .  </p>
</blockquote>
</li>
<li>将本地暂存提交到版本库  <blockquote>
<p>git commit -m “提交说明”  </p>
</blockquote>
</li>
<li>本地推送到远端分支  <blockquote>
<p>git push origin dev(分支名)  </p>
</blockquote>
</li>
</ol>
<h3 id="git查看、切换用户"><a href="#git查看、切换用户" class="headerlink" title="git查看、切换用户"></a>git查看、切换用户</h3><p>查看用户名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure>

<p>查看用户邮箱：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config user.email</span><br></pre></td></tr></table></figure>

<p>修改命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git conifg --global user.name &quot;genuine&quot;</span><br></pre></td></tr></table></figure>

<p>修改用户邮箱</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;17828022605@163.com&quot;</span><br></pre></td></tr></table></figure>



<h3 id="分支使用"><a href="#分支使用" class="headerlink" title="分支使用"></a>分支使用</h3><ol>
<li><p>删除本地分支</p>
<blockquote>
<p>git branch -d dev(分支名)  </p>
</blockquote>
</li>
<li><p>取消目录的git初始化  </p>
<blockquote>
<p>rm -rf.git  </p>
</blockquote>
</li>
<li><p>克隆想要的分支到本地  </p>
<blockquote>
<p>git clone –branch dev(分支名) <a href="https://github.com/xx/xx.git">https://github.com/xx/xx.git</a>  </p>
</blockquote>
</li>
</ol>
<h4 id="拉去远程分支到本地"><a href="#拉去远程分支到本地" class="headerlink" title="拉去远程分支到本地"></a>拉去远程分支到本地</h4><ol>
<li><p>新建一个文件夹</p>
</li>
<li><p>初始化，在 git base 中输入</p>
<blockquote>
<p>git init</p>
</blockquote>
</li>
<li><p>与远端master建立链接</p>
<blockquote>
<p>git remote add origin 仓库链接地址<a href="https://github.com/xx/xx.git">https://github.com/xx/xx.git</a><br>//如果第一遍输入错误，可以输入 git remode rm origin ，删除上一步的操作之后重新输入  </p>
</blockquote>
</li>
<li><p>把远程分支拉到本地</p>
<blockquote>
<p>git fetch origin dev(dev为远程仓库的分支名)</p>
</blockquote>
</li>
<li><p>切换到分支</p>
<blockquote>
<p>git checkout dev(dev为远程仓库的分支名)</p>
</blockquote>
</li>
<li><p>以后每次使用时最好先：把分支的最新内容拉取到本地</p>
<blockquote>
<p>git pull origin dev(远程分支名)</p>
</blockquote>
</li>
</ol>
<h4 id="拉取远程分支单独文件或文件夹"><a href="#拉取远程分支单独文件或文件夹" class="headerlink" title="拉取远程分支单独文件或文件夹"></a>拉取远程分支单独文件或文件夹</h4><ol>
<li><p>选择放置git仓库的文件夹，创建并初始化git本地仓库  </p>
<blockquote>
<p>git init dev_work &amp;&amp; cd dev_work  </p>
</blockquote>
</li>
<li><p>关联远端地址</p>
<blockquote>
<p>git remote add -f origin <a href="https://github.com/xx/xx.git">https://github.com/xx/xx.git</a>  </p>
</blockquote>
</li>
<li><p>开启git的 Sparse Checkout 模式（该模式专门用于git检出指定目录或文件，在config中配置）  </p>
<blockquote>
<p>git config core.sparsecheckout true  </p>
</blockquote>
</li>
<li><p>设置需要拉取github上的文件目录</p>
<blockquote>
<p>//这些目录写在了.git/info/sparse-check文件中。<br>echo “source/posts(github上的目录或文件路径)” &gt;&gt; .git/info/sparse-check<br>echo “css/fonts(可以写多个)” &gt;&gt; .git/info/sparse-check </p>
</blockquote>
</li>
<li><p>从GitHub上拉取下来</p>
<blockquote>
<p>git pull origin dev(对应分支名)   </p>
</blockquote>
</li>
</ol>
<h3 id="已存在的项目提交到新的远程仓库"><a href="#已存在的项目提交到新的远程仓库" class="headerlink" title="已存在的项目提交到新的远程仓库"></a>已存在的项目提交到新的远程仓库</h3><ol>
<li><p>先初始化项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li>
<li><p>把文件添加到版本库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li>
<li><p>把文件提交到本地残酷</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;提交说明&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>关联远程库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rmmote add origin 远程仓库地址</span><br></pre></td></tr></table></figure></li>
<li><p>获取远程库与本地合并</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull --rebase origin master</span><br></pre></td></tr></table></figure></li>
<li><p>把本地库的内容推送到远程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Git配置SSH"><a href="#Git配置SSH" class="headerlink" title="Git配置SSH"></a>Git配置SSH</h3><ol>
<li>首先预装Git和OpenSSH，检查系统是否存在</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br><span class="line">ssh -V</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置Git用户的用户名和邮箱</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用ssh-kengen生成key pari</li>
</ol>
<p>“-t rsa”表示使用密钥的加密类型，还可以为dsa；-C设置注释文字，比如你的邮箱“YourEmail”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;你的邮箱&quot;</span></span><br><span class="line"><span class="comment"># 直接回车</span></span><br><span class="line"><span class="comment"># 输入该密钥的授权密码 可以不写为空，直接回车</span></span><br><span class="line"><span class="comment"># 确认该密钥的授权密码</span></span><br></pre></td></tr></table></figure>

<p>identification保存在~/.ssh/id_rsa</p>
<p>public key保存在~/.ssh/id_rsa.pub</p>
<ol start="4">
<li>拷贝输出的所有ssh公钥信息</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在github等代码托管平台上，为当前账号添加新的SSH公钥，相当于注册到github服务器的授信任列表中，该列表可以添加多个SSH客户端的公钥，title用于区分识别多个SSH Key</li>
</ol>
<h2 id="优雅操作"><a href="#优雅操作" class="headerlink" title="优雅操作"></a>优雅操作</h2><h3 id="Git-commit规范"><a href="#Git-commit规范" class="headerlink" title="Git commit规范"></a>Git commit规范</h3><p><img src="https://genuine-ipic.oss-cn-beijing.aliyuncs.com/2022-09-30-030911.png" alt="image-20220930110911697"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA的使用</title>
    <url>/2021/04/06/IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><h2 id="包围代码"><a href="#包围代码" class="headerlink" title="包围代码"></a>包围代码</h2><p><code>option + command + T</code>快速生成 try/catch/finally if/else do/while synchronized 等包围代码</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><p>例如 <code>_a</code> 替换成 <code>A</code> </p>
<h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><p>通过 <code>_([a-z])</code>选中 <code>_a</code> ，通过<code>\u$1</code>替换成<code>A</code></p>
<p>每一个<code>()</code>都代表一个捕获组，使用<code>$n</code>进行分组，注意下标不能乱</p>
<h4 id="大小写如何转换"><a href="#大小写如何转换" class="headerlink" title="大小写如何转换"></a>大小写如何转换</h4><p><code>\l</code>将一个字符更改为小写</p>
<p><code>\u</code>将一个字符更改为大写</p>
<p><code>\L</code>将所有字符更改为小写</p>
<p><code>\U</code>将所有字符更改为大写</p>
<h2 id="删除了iml文件怎么恢复"><a href="#删除了iml文件怎么恢复" class="headerlink" title="删除了iml文件怎么恢复"></a>删除了iml文件怎么恢复</h2><p>idea中项目服务的iml文件可以删除，想要重新生成，重新通过idea的maven插件加载对应服务的pom.xml文件就好了</p>
<h2 id="隐藏idea项目的文件"><a href="#隐藏idea项目的文件" class="headerlink" title="隐藏idea项目的文件"></a>隐藏idea项目的文件</h2><p>idea项目中的idea文件如何隐藏，以及不小心隐藏之后如何显示idea文件夹。</p>
<p>步骤：加入要隐藏.idea文件</p>
<ol>
<li>打开file–》settings–》editor—-&gt;file types</li>
<li>选择*.gitignore,在下面（Ignore Files and Folders:）一栏的后面输入  .idea;</li>
<li>点击应用，点击ok</li>
</ol>
<ol start="4">
<li>我们可以发现，idea文件被隐藏</li>
<li>想要文件夹再次显示出来，只需按原本步骤，找到那一栏，把 .idea;   删除掉就可以了，点击应用、点击ok。</li>
</ol>
<p>我添加了如下想要隐藏的文件</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">.idea;.mvn;*.iml;mvnw;mvnw.cmd;HELP.md;target;</span><br></pre></td></tr></table></figure>

<h2 id="遇到idea过期怎么办"><a href="#遇到idea过期怎么办" class="headerlink" title="遇到idea过期怎么办"></a>遇到idea过期怎么办</h2><p>打开<code>BetterIntelliJ</code>插件后，重启，点击插件reset功能，查看idea可使用截止日期在一个月以后，关闭插件即可。</p>
]]></content>
      <categories>
        <category>开发工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven知识点</title>
    <url>/2020/12/22/Maven/</url>
    <content><![CDATA[<h2 id="Maven以来中的scope的作用和用法"><a href="#Maven以来中的scope的作用和用法" class="headerlink" title="Maven以来中的scope的作用和用法"></a>Maven以来中的scope的作用和用法</h2><p>举例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="scope的值有以下五种："><a href="#scope的值有以下五种：" class="headerlink" title="scope的值有以下五种："></a>scope的值有以下五种：</h3><ol>
<li><p>compile（默认）</p>
<p>表示被依赖的项目需要参与当前项目的编译，包括后续的测试、运行周期。在部署的时候会打包到lib目录下，项目在编译、测试、运行阶段都需要。</p>
</li>
<li><p>test</p>
<p>仅仅在测试的时候才会使用。不会打包。</p>
</li>
<li><p>runtime</p>
<p>仅仅用于运行环境，在编译和测试环境下不会使用</p>
</li>
<li><p>privided</p>
<p>用于编译和测试环境，不会打包到lib目录中。</p>
</li>
<li><p>system</p>
<p>从参与度来说与provided相同，但是被依赖项不会从maven仓库获取，而是在本地文件系统中获取，一定需要配合systemPath属性使用。</p>
</li>
</ol>
<h3 id="为什么需要区分scope"><a href="#为什么需要区分scope" class="headerlink" title="为什么需要区分scope"></a>为什么需要区分scope</h3><p>用来限制dependency的范围，可以在不用环境打包不用的jar包，比如junit测试类的jar包不需要再编译运行的时候，就可以设置scope为test。</p>
<h2 id="optional标签为true什么意思"><a href="#optional标签为true什么意思" class="headerlink" title="optional标签为true什么意思"></a>optional标签为true什么意思</h2><p>举例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用optional标签的话，其他项目依赖此项目就不会进行传递，只能在本项目中使用。</p>
]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx使用</title>
    <url>/2020/11/28/Nginx/</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Nginx是一个高性能的HTTP和反向代理web服务器，也提供IMAP/POP3/SMTP服务。</p>
<p>是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMA/POP3）代理服务器。</p>
<p>BSD-like协议下发行</p>
<h3 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h3><p>占有内存少，并发能力强</p>
<p>支持热部署，可以支持7*24不间断运行。</p>
<h3 id="1-2-作为web服务器"><a href="#1-2-作为web服务器" class="headerlink" title="1.2 作为web服务器"></a>1.2 作为web服务器</h3><p>Nginx可以作为静态页面的web服务器，同时还支持CGI协议的动态语言，比如perl、php等。但是不支持Java。Java程序只能通过tomcat配合完成。</p>
<p>Nginx转为性能优化而开发，实现上非常注重效率。</p>
<p>能经受高负载的考验，有报告表明能支持高达50000个并发连接数。</p>
<h3 id="1-3-作为HTTP服务器"><a href="#1-3-作为HTTP服务器" class="headerlink" title="1.3 作为HTTP服务器"></a>1.3 作为HTTP服务器</h3><ul>
<li>处理静态文件，索引文件以及自动索引：打开文件描述符缓冲。</li>
<li>无缓冲的反向代理加速，简单的负载均衡和容错。</li>
<li>FastCGI，简单的负载均衡和容错。</li>
<li>模块化结构</li>
<li>支持SSL 和 TLSSNI</li>
</ul>
<h3 id="1-4-基本概念"><a href="#1-4-基本概念" class="headerlink" title="1.4 基本概念"></a>1.4 基本概念</h3><h4 id="1-4-1-正向代理"><a href="#1-4-1-正向代理" class="headerlink" title="1.4.1 正向代理"></a>1.4.1 正向代理</h4><p>Nginx能用作正向代理来进行上网等功能。</p>
<p>正向代理：如果把局域网外的Internet看作一个巨大的资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问（在客户端（浏览器）配置代理服务器），这种代理服务称为正向代理。</p>
<h4 id="1-4-2-反向代理"><a href="#1-4-2-反向代理" class="headerlink" title="1.4.2 反向代理"></a>1.4.2 反向代理</h4><p>由于客户端对代理是无感知的，客户端不需要任何配置就可以访问</p>
<p>我们只需要将请求发送到反向代理服务器，有反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p>
<h4 id="1-4-3-负载均衡"><a href="#1-4-3-负载均衡" class="headerlink" title="1.4.3 负载均衡"></a>1.4.3 负载均衡</h4><p><img src="https://i.loli.net/2020/11/28/MTJ29wsXSCfolZr.png" alt="image.png"></p>
<h4 id="1-4-4-动静分离"><a href="#1-4-4-动静分离" class="headerlink" title="1.4.4 动静分离"></a>1.4.4 动静分离</h4><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p>
<h2 id="2-Nginx安装"><a href="#2-Nginx安装" class="headerlink" title="2. Nginx安装"></a>2. Nginx安装</h2><p>镜像位置：/mydata/jingxiang/</p>
<p>版本：</p>
<p>pcre-8.37.tar.gz</p>
<p>openssl-1.0.1t.tar.gz</p>
<p>zlib-1.2.8.tar.gz</p>
<p>nginx-1.12.2.tar.gz</p>
<h3 id="1-安装pcre依赖"><a href="#1-安装pcre依赖" class="headerlink" title="1. 安装pcre依赖"></a>1. 安装pcre依赖</h3><p>下载压缩文件</p>
<p>解压压缩文件</p>
<p>进入目录执行 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure>

<p>使用命令编译和安装 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>查看版本号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pcre-config --version</span><br></pre></td></tr></table></figure>

<h3 id="2-安装openssl和zlib"><a href="#2-安装openssl和zlib" class="headerlink" title="2. 安装openssl和zlib"></a>2. 安装openssl和zlib</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure>

<h3 id="一键安装上面三个依赖"><a href="#一键安装上面三个依赖" class="headerlink" title="一键安装上面三个依赖"></a>一键安装上面三个依赖</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure>

<h3 id="3-安装nginx"><a href="#3-安装nginx" class="headerlink" title="3. 安装nginx"></a>3. 安装nginx</h3><p>下载压缩文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压压缩文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf nginx-1.12.2.tar.gz </span><br></pre></td></tr></table></figure>

<p>进入解压目录执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure>

<p>执行命令编译和安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>安装完成后，会在/usr/local/文件夹下自动创建一个nginx文件夹  </p>
<p>/usr/local/nginx/sbin 中有启动脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin/</span><br><span class="line">./nginx</span><br><span class="line">ps -ef | grep nginx</span><br><span class="line">会发现两个进程</span><br></pre></td></tr></table></figure>

<p>编辑配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/lcoal/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	server&#123;</span><br><span class="line">		listen			80; #端口号</span><br><span class="line">		server_name		localhost; #ip地址</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看开放的端口号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br><span class="line"></span><br><span class="line">设置开放端口号</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">firewall-cmd --add-service=http -permanent</span></span><br><span class="line">sudo firewall-cmd --add-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line">重启防火墙</span><br><span class="line">firewall-cmd -reload</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-Nginx常用命令"><a href="#3-Nginx常用命令" class="headerlink" title="3. Nginx常用命令"></a>3. Nginx常用命令</h2><p>前提条件：必须进入nginx的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin/</span><br><span class="line"></span><br><span class="line">查看ngins版本号</span><br><span class="line">./nginx -v</span><br><span class="line"></span><br><span class="line">启动nginx</span><br><span class="line">./nginx</span><br><span class="line">查看验证</span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"></span><br><span class="line">关闭nginx</span><br><span class="line">./nginx -s stop</span><br><span class="line">查看验证</span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"></span><br><span class="line">重新加载nginx命令，比如：需要重新加载nginx的配置文件</span><br><span class="line">cd /usr/local/nginx/sbin/</span><br><span class="line">./nginx -s reload</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-Nginx的配置文件"><a href="#4-Nginx的配置文件" class="headerlink" title="4. Nginx的配置文件"></a>4. Nginx的配置文件</h2><p>/usr/local/nginx/conf/</p>
<p>由三部分组成</p>
<h4 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h4><p>从配置文件开始到events块之间，设置一些影响nginx服务器整体运行的配置指令</p>
<p>主要包括配置运行Nginx服务器的用户（组）、允许生成的worker process数，进程PID存放路径、日志存放路径和类型以及配置文件的引入等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">worker_processes	1; # 值越大，可以支持的并发处理量也越多，不能超过cpu核数</span><br></pre></td></tr></table></figure>



<h3 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h3><p>影响Nginx服务器与用户的网络连接。</p>
<p>常用的设置包括 是否开启对多work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种时间驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">	worker_connections	1024; # 支持最大连接数 1024 对Nginx影响较大</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h3><p>Nginx服务器配置中最频繁的部分</p>
<p>代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。</p>
<p>http块也可以包括http全局快、server块。</p>
<h4 id="http全局块"><a href="#http全局块" class="headerlink" title="http全局块"></a>http全局块</h4><p>包括文件引入、MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上限等。</p>
<h4 id="server块"><a href="#server块" class="headerlink" title="server块"></a>server块</h4><p>和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，为了节约互联网服务器硬件成本。</p>
<p>每个http块可以包含多个server块，而每个server块相当于一个虚拟主机</p>
<p>每个server块可以分为全局server块，以及可以同时包含多个location块</p>
<h5 id="全局server块"><a href="#全局server块" class="headerlink" title="全局server块"></a>全局server块</h5><p>本虚拟主机的监听配置和本虚拟主机的名称或IP配置。</p>
<h5 id="location块"><a href="#location块" class="headerlink" title="location块"></a>location块</h5><p>一个server开可以配置多个localtion块。</p>
<p>主要作用是基于Nginx服务器接收到的请求字符串（例如server_name/uri-string），对虚拟主机名称（或IP别名）之外的字符串（例如/uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也可以在这里进行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	server &#123;</span><br><span class="line">		listen	80;</span><br><span class="line">		server_name	localhost;</span><br><span class="line">		location / &#123;</span><br><span class="line">  			root	html;</span><br><span class="line">  			index	index.html	index.html;</span><br><span class="line">		&#125;</span><br><span class="line">		error_page	500	502	503	504	/50x.html;</span><br><span class="line">		location = /50x.html &#123;</span><br><span class="line">			root	html;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Nginx配置实例"><a href="#Nginx配置实例" class="headerlink" title="Nginx配置实例"></a>Nginx配置实例</h1><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>实现效果</p>
<p>准备工作</p>
<p>安装tomcat，使用默认端口8080</p>
<p>下载tomcat压缩包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.bfsu.edu.cn/apache/tomcat/tomcat-7/v7.0.107/bin/apache-tomcat-7.0.107.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压tomcat</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf apache-tomcat-7.0.107.tar.gz</span><br></pre></td></tr></table></figure>

<p>安装JDK</p>
<p><a href="https://blog.csdn.net/weixin_44538107/article/details/88683530">Linux安装jdk详细步骤_农村小白的博客-CSDN博客_linux安装jdk</a></p>
<p>java -version</p>
<p>启动tomcat</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd apache-tomcat-xxx</span><br><span class="line">cd bin</span><br><span class="line">./startup.sh </span><br><span class="line"></span><br><span class="line">启动成功，进入日志</span><br><span class="line">cd ../logs</span><br><span class="line"></span><br><span class="line">查看日志</span><br><span class="line">tail -f catalina.out</span><br></pre></td></tr></table></figure>

<p>对外开放端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd -add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd -add-port=8081/tcp --permanent</span><br><span class="line">firewall-cmd -reload</span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure>

<p>再windwos中浏览器访问</p>
<p><a href="http://x.x.x.x:8080/">http://x.x.x.x:8080/</a></p>
<p><img src="https://i.loli.net/2020/11/28/qrwxmknuNspSYeV.png" alt="image.png"></p>
<p>小知识：浏览器请求url ：首先会再windows的host文件中找对应域名–》的对应ip地址。如果没有，会去网络的域名解析器查找。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>为了让请求更高效，把动态跟静态请求分开。</p>
<p>使用Nginx处理静态页面，tomcat处理动态页面。</p>
<p>实现方式有两种：</p>
<ol>
<li>把静态文件独立成单独的域名，放在独立的服务器上，也是主流的方案。</li>
<li>动态跟静态文件混合在一起发布，通过通过Nginx分开。</li>
</ol>
<p>通过location来指定不同的后缀名实现不同的请求转发。通过expires参数设置，可以是浏览器缓存过期时间，减少与服务器之前的请求和流量。</p>
<p>具体Expires定义：给一个资源设定一个过期时间，无需去服务端验证，直接</p>
<h1 id="Nginx原理"><a href="#Nginx原理" class="headerlink" title="Nginx原理"></a>Nginx原理</h1><h1 id="未来补充"><a href="#未来补充" class="headerlink" title="未来补充"></a>未来补充</h1><p>安装，常用命令和配置文件</p>
<p>在Linux系统中安装nginx</p>
<p>nginx配置实例</p>
<p>反向代理</p>
<p>nginx配置实例</p>
<p>负载均衡</p>
<p>nginx配置实例</p>
<p>动静分离</p>
<p>nginx配置高可用的集群</p>
<p>nginx原理</p>
]]></content>
  </entry>
  <entry>
    <title>MQ介绍</title>
    <url>/2020/09/17/MQ%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="MQ介绍"><a href="#MQ介绍" class="headerlink" title="MQ介绍"></a>MQ介绍</h2><p>消息队列，先进先出的数据结构。</p>
<p>发送方 –》 RPC –》 接受方<br>发送发 –》 消息发送MQ –》 有消息 –》 接受方</p>
<p>优点：</p>
<ul>
<li>应用解耦：不同系统之间通过 MQ存储消息 连接消息。</li>
<li>流量削峰：用户请求缓存到MQ中，系统在 MQ 中拉取支持的数量的请求。</li>
<li>数据分发：消息生产方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据即可。</li>
</ul>
<p>缺点：</p>
<ul>
<li>系统可用性降低：系统引入外部依赖越多，系统稳定性越差，一旦MQ宕机，会对业务造成影响。<ul>
<li>如何保证MQ的高可用？</li>
</ul>
</li>
<li>系统复杂度提高：MQ加入增加系统复杂度，以前系统间时同步的远程调用，现在是MQ进行异步调用。<ul>
<li>如何保证消息 没有被重复消费？怎么处理消息丢失情况？传递的顺序性？</li>
</ul>
</li>
<li>一致性问题？<ul>
<li>如何保证消息数据处理的一致性？</li>
</ul>
</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
  </entry>
  <entry>
    <title>tomcat问题</title>
    <url>/2020/10/12/Tomcat%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><h5 id="springmvc启动tomcate控制台乱码问题"><a href="#springmvc启动tomcate控制台乱码问题" class="headerlink" title="springmvc启动tomcate控制台乱码问题"></a>springmvc启动tomcate控制台乱码问题</h5><p>在tomcat文件夹中的conf包下的logging.properties中找到</p>
<p>java.util.logging.ConsoleHandler.encoding = UTF-8</p>
<p>将这行代码注销改为</p>
<p>java.util.logging.ConsoleHandler.encoding = GBK</p>
<p>重启tomcat即可！</p>
]]></content>
  </entry>
  <entry>
    <title>Poi的使用</title>
    <url>/2022/10/20/Poi%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Poi的使用"><a href="#Poi的使用" class="headerlink" title="Poi的使用"></a>Poi的使用</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- poi-ooxml是poi的升级版，直接使用poi-ooxm即可 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面是easypoi的依赖，同时引入不影响--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面是jxl的依赖，同时引入不影响--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sourceforge.jexcelapi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jxl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="POI和JXL"><a href="#POI和JXL" class="headerlink" title="POI和JXL"></a>POI和JXL</h3><p>excel流行的开发工具有两种：POI和JXL</p>
<p>如果Excel需求的功能比较复杂尽量使用Poi，</p>
<p>如果Excel有大量数据可以考虑使用Jxl，Jxl插入数据比Poi快。</p>
<h3 id="POI"><a href="#POI" class="headerlink" title="POI"></a>POI</h3><p>Poi提供03和07版本，两个区别如下：</p>
<ol>
<li><p>03优点：数据写在内存中，最后一次性写入磁盘，速度快</p>
</li>
<li><p>03缺点：最多只能处理65536行数据，否则会抛出异常</p>
</li>
<li><p>07优点：可以一次写大量数据，如20W条</p>
</li>
<li><p>07缺点：写数据慢，耗内存，可能会发生内存异常，如100W条数据</p>
</li>
</ol>
<h3 id="第三方类库"><a href="#第三方类库" class="headerlink" title="第三方类库"></a>第三方类库</h3><p>对Apache Poi的封装第三方库有EasyPoi和EasyExcel</p>
<p>SAX模式：一边扫描一边解析，不需要将数据存储在内存中。</p>
<p>EasyPoi 读写数据时，优先将数据写入内存，读写性能非常高，但是当数据量很大的时候，会出现OOM。也提供了SAX模式。</p>
<p>EasyExcel 基于SAX模式进行读写数据，不会出现OOM情况，程序运行比较稳定，相对于 EasyPoi 来说，读写性能稍慢。</p>
<p>EasyPoi 对定制化的导出支持更丰富，如果当前项目的需求，并发量不大、数据量也不大，但是需要导出 Excel 的文件样式千差万别，推荐用EasyPoi；反之，使用EasyExcel。</p>
<h3 id="My工具的使用"><a href="#My工具的使用" class="headerlink" title="My工具的使用"></a>My工具的使用</h3><p>PoiUtil工具类中有对单元格内容的提取，拷贝表、行、单元格的操作</p>
<p>ExcelUtils中有以前在项目中使用的基础的单表导入和导出功能</p>
]]></content>
      <categories>
        <category>Excel</category>
        <category>Poi</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>Poi</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2020/12/25/Vue/</url>
    <content><![CDATA[<h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><ol>
<li><p>创建Vue实例</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="comment">// 选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> Vue没有完全遵循MVVM模型。</p>
</li>
<li><p>数据与方法</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据对象</span></span><br><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入到Vue实例中</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: data	<span class="comment">//前面的data是vue对象的属性，后面的data是上面的数据对象。</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.<span class="property">a</span> == data.<span class="property">a</span></span><br><span class="line"></span><br><span class="line">vm.<span class="property">a</span> = <span class="number">2</span> <span class="comment">// data.a 也会同样改变</span></span><br></pre></td></tr></table></figure>

<p> 当这些数据改变时，视图会重渲染。注意：只有当实例被创建时就已经存在于data中的property才是<strong>响应式</strong>的。如果数据一开始不存在，是不会进行响应式的。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>() <span class="comment">//阻止修改现有Vue实例的property，表示相应系统无法再追踪。</span></span><br></pre></td></tr></table></figure>

<p> 比如：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: obj</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里的 `foo` 不会更新！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;</span>Change it<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> Vue实例有一些有用的property与方法。他们都有前缀$，与用于自定义的property分开。</p>
<p> 比如：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.<span class="property">$data</span> === data <span class="comment">// =》 true</span></span><br><span class="line">vm.<span class="property">$el</span> === <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;example&#x27;</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个回调在&#x27;vm.a&#x27;改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>实例生命周期钩子</p>
</li>
</ol>
<p>在实例生命周期的不同阶段被调用。如created、mounted（被挂载后调用）、updated、destroyed。生命周期钩子使用this上下文指向调用它的Vue实例。</p>
<p>不用在选项property或回调上使用箭头函数。箭头函数并没有this,this会作为变量一直向上级词法作用域查找，直至找到为止，经常导致。\</p>
<p><img src="https://i.loli.net/2020/12/24/uMRrPF1edjyDvS3.png" alt="生命周期图示"></p>
<h2 id="语法模板"><a href="#语法模板" class="headerlink" title="语法模板"></a>语法模板</h2><p>Vue.js使用基于HTML的模板语法。</p>
<h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p>数据绑定最常见的形式就是文本插值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过v-once指令，只能执行一次性的插值，当数据改变时，插值处的内容不会更更新。</p>
<h4 id="原始HTML"><a href="#原始HTML" class="headerlink" title="原始HTML"></a>原始HTML</h4><p>双大括号回将数据解释为普通文本，如果要输出真正的HTML，需要使用v-html指令：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 会输出原始的HTML代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：动态渲染的任意HTML可能有危险，很容易倒置XSS攻击。绝对不要对用户提供的内容使用插值。</p>
<h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h4><p>Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用v-bind 指令：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于布尔attribute（存在其值就为true），v-bind 工作起来略有不同。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:disabled</span>=<span class="string">&quot;isButtonDisabled&quot;</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>isButtonDisabled</code> 的值是 <code>null</code>、<code>undefined</code> 或 <code>false</code>，则 <code>disabled</code> attribute 甚至不会被包含在渲染出来的 <code>&lt;button&gt;</code> 元素中。</p>
<h4 id="使用JavaScript表达式"><a href="#使用JavaScript表达式" class="headerlink" title="使用JavaScript表达式"></a>使用JavaScript表达式</h4><p>对于所有的数据绑定，Vue.js提供包含单个JavaScript表达式。</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>指令（Directives）是带有v-前缀的特殊attribute。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>一些指令能接受一个”参数”，在指令名称之后以冒号表示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这里 <code>href</code> 是参数，告知 <code>v-bind</code> 指令将该元素的 <code>href</code> attribute 与表达式 <code>url</code> 的值绑定。</p>
<h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><blockquote>
<p>2.6.0新增</p>
</blockquote>
<p>可以用方括号的JavaScript表达式作为一个指令的参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>动态参数的要求约束：</p>
<ol>
<li><p>动态参数预期求出一个字符串，如果为 <code>null</code> 可以被显性的用于移除绑定。任何非字符串类型的值都将会触发一个警告。</p>
</li>
<li><p>某些字符，如空格和引号在HTML arrtibue名里是无效的。比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这会触发一个编译警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[&#x27;<span class="attr">foo</span>&#x27; + <span class="attr">bar</span>]=<span class="string">&quot;value&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写。</p>
</li>
</ol>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>修饰符 (modifier) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p>Vue仅仅为 <code>v-bind</code> 和 <code>b-on</code> 最常用的指令提供特定的简写。</p>
<h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a><code>v-bind</code></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a><code>v-on</code></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>在模板中放入太多的逻辑会让模板过重且难以维护。</p>
<p>对于任何复杂逻辑，应当使用<strong>计算属性</strong>。</p>
<h4 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="comment">// 计算属性的getter</span></span><br><span class="line">        <span class="attr">reversedmessage</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// this 指向vm实例</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>.<span class="title function_">sqlit</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Original message: &quot;Hello&quot;</span><br><span class="line">Computed reversed message: &quot;olleH&quot;</span><br></pre></td></tr></table></figure>

<p>当声明一个计算属性reverseMessage时，函数将用作property 的getter函数。</p>
<p>Vue知道vm。reversedMessage依赖于vm.message。当vm.message发生改变时，所以来vm.reversedMessage的绑定也会更新。</p>
<h4 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h4><p>在表达式中调用方法也可以达到相同的效果。（已验证，确实可以）</p>
<p>不同点：</p>
<ul>
<li><strong>计算属性</strong>基于<strong>响应式依赖进行缓存</strong>的。当响应式发生改变时才会重新求值。</li>
<li>每当重新渲染时，调用方法总会再次执行函数。</li>
</ul>
<p>比如：</p>
<p>下面的计算属性将不再更新，因为 <code>Date.now()</code> 不是响应式依赖：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">now</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计算属性vs侦听属性"><a href="#计算属性vs侦听属性" class="headerlink" title="计算属性vs侦听属性"></a>计算属性vs侦听属性</h4><p>侦听属性是 <code>watch</code>。</p>
<p>使用计算属性，代码更加简介易懂。</p>
<p>比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">    <span class="attr">fullName</span>: <span class="string">&#x27;Foo Bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">fullName</span> = val + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">fullName</span> = <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">fullName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="计算属性的setter"><a href="#计算属性的setter" class="headerlink" title="计算属性的setter"></a>计算属性的setter</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">fullName</span>: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">firstName</span> = names[<span class="number">0</span>]</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lastName</span> = names[names.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p>当需要在数据变化时，执行异步或开销较大的操作时，<code>watch</code> 方式时最有用的。</p>
<p>除了 <code>watch</code> 选项之外，还可以使用命令式的 <a href="https://cn.vuejs.org/v2/api/#vm-watch">vm.$watch API</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="line">    <span class="attr">question</span>: <span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;Waiting for you to stop typing...&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">debouncedGetAnswer</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Class与Style绑定"><a href="#Class与Style绑定" class="headerlink" title="Class与Style绑定"></a>Class与Style绑定</h2><p>HTML的class元素可以引入style样式。</p>
<h3 id="绑定HTML-Class"><a href="#绑定HTML-Class" class="headerlink" title="绑定HTML Class"></a>绑定HTML Class</h3><h4 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h4><ol>
<li><p><code>active</code> 这个 class 存在与否将取决于数据 property <code>isActive</code> 是否为真。</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;static&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">isActive</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">hasError</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 渲染的结果为：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;static active&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以将绑定的样式数据对象放在一个对象中。</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">classObject</span>: &#123;</span><br><span class="line">    <span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;text-danger&#x27;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>绑定一个返回对象的计算属性。这是一个常用且强大的模式：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">isActive</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">error</span>: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">classObject</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">active</span>: <span class="variable language_">this</span>.<span class="property">isActive</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="property">error</span>,</span><br><span class="line">      <span class="string">&#x27;text-danger&#x27;</span>: <span class="variable language_">this</span>.<span class="property">error</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">error</span>.<span class="property">type</span> === <span class="string">&#x27;fatal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h4><p>可以把一个数组传给 <code>v-bind:class</code> ，一应用一个class列表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[activeCalss, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">activeClass</span>: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">    <span class="attr">errorClass</span>: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据条件切换列表中的class，使用<strong>三元表达式</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以在数组语法中使用对象语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a>用在组件上</h4><p>自定义组件上使用 <code>class</code>时,class 将被添加到该组件的根元素上面。</p>
<p>如果声明了组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在使用时可以添加一些class：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">class</span>=<span class="string">&quot;baz boo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>HTML将被渲染为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;foo bar baz boo&quot;</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于带数据绑定 class 也同样适用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h3><h4 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">activeColor</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  <span class="attr">fontSize</span>: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接绑定一个样式对象，模板会更加清晰：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;styleObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">styleObject</span>: &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    <span class="attr">fontSize</span>: <span class="string">&#x27;13px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外还有：自动添加前缀、多重值的功能，再次不多做阐述。</p>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p><code>v-if</code> 指令用于条件性地渲染一块内容。只会在指令的表达式返回<code>truthy</code>值的时候被渲染。</p>
<p>也可以用<code>v-else</code>添加一个”else块”：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;awesome&quot;</span>&gt;</span>Vue is awesome!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>Oh no<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="在-lt-template-gt-元素上使用v-if条件渲染分组"><a href="#在-lt-template-gt-元素上使用v-if条件渲染分组" class="headerlink" title="在&lt;template&gt;元素上使用v-if条件渲染分组"></a>在<code>&lt;template&gt;</code>元素上使用v-if条件渲染分组</h3><p>如果想切换多个元素，可以把<code>&lt;template&gt;</code>元素当作包裹元素，在上面使用v-if。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;ok&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-else、v-else-if"><a href="#v-else、v-else-if" class="headerlink" title="v-else、v-else-if"></a><code>v-else</code>、<code>v-else-if</code></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-key-管理可复用的元素"><a href="#使用-key-管理可复用的元素" class="headerlink" title="使用 key 管理可复用的元素"></a>使用 key 管理可复用的元素</h3><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。</p>
<p>例如，允许用户在不同的登录方式之间切换：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果需要使，这两个元素完全独立，不要复用它们。只需添加一个具有唯一值的 <code>key</code> attribute 即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email-input&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>始终会被渲染并保留在 DOM 中。只是简单地切换元素的 CSS property <code>display</code>。</p>
<h3 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if  vs  v-show"></a>v-if  vs  v-show</h3><p>v-if：会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>
<p>v-if：<strong>惰性的</strong>，在初始渲染时条件为假，则什么也不做直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>v-show：不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>
<p>总结：</p>
<p><code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="v-for-结合列表"><a href="#v-for-结合列表" class="headerlink" title="v-for 结合列表"></a>v-for 结合列表</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.message&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装多种容器</title>
    <url>/2021/03/16/docker%E5%AE%89%E8%A3%85%E5%A4%9A%E7%A7%8D%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="kafka-es"><a href="#kafka-es" class="headerlink" title="kafka/es"></a>kafka/es</h2><ol>
<li><p>docker 安装kafka</p>
<ol>
<li><p>前置条件安装zookeeper</p>
<blockquote>
<p>docker run -d –name zookeeper -p 2181:2181 -v /etc/localtime:/etc/localtime wurstmeister/zookeeper</p>
</blockquote>
</li>
<li><p>安装kafka</p>
<blockquote>
<p>docker run  -d –name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=39.97.117.252:2181 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://39.97.117.252:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -t wurstmeister/kafka</p>
</blockquote>
</li>
<li><p>参数意义</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">-e KAFKA_BROKER_ID=0 在kafka集群中，每个kafka都有一个BROKER_ID来区分自己</span><br><span class="line"></span><br><span class="line">-e KAFKA_ZOOKEEPER_CONNECT=10.9.44.11:2181/kafka 配置zookeeper管理kafka的路径39.97.117.252:2181/kafka</span><br><span class="line"></span><br><span class="line">-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://10.9.44.11:9092 把kafka的地址端口注册给zookeeper</span><br><span class="line"></span><br><span class="line">-e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 配置kafka的监听端口</span><br><span class="line"></span><br><span class="line">-v /etc/localtime:/etc/localtime 容器时间同步虚拟机的时间</span><br></pre></td></tr></table></figure></li>
<li><p>验证kafka是否可以使用</p>
</li>
<li><p>失败</p>
</li>
</ol>
</li>
<li><p>docker安装elasticsearch</p>
<p>见商城4关于安装es的部分</p>
</li>
</ol>
<h2 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h2><p>拉取镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull nacos/nacos-server</span><br></pre></td></tr></table></figure>

<p>通过镜像创建容器（默认账号密码都是nacos），创建成功后自动启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8848:8848 --env MODE=standalone  --name nacos  nacos/nacos-server</span><br></pre></td></tr></table></figure>

<p>访问页面验证是否成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://xxx.xxx.xxx.xxx:8848/nacos</span><br></pre></td></tr></table></figure>

<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mobz/elasticsearch-head:5</span><br><span class="line">docker run -d -p 9100:9100 docker.io/mobz/elasticsearch-head:5</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript知识点</title>
    <url>/2020/12/24/javaScript%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="”-“与“-”的区别"><a href="#”-“与“-”的区别" class="headerlink" title="”==“与“===”的区别"></a>”==“与“===”的区别</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>== ： 两边值类型不同的时候，首先进行类型转换，再比较。</p>
<p>=== ： 不做类型转换，类型不同一定不等</p>
<h3 id="分别说明"><a href="#分别说明" class="headerlink" title="分别说明"></a>分别说明</h3><p>“===” 的规则：</p>
<ol>
<li>类型不同就不相等。</li>
<li>如果两个都是数值，同一个值，相等；如果其中至少一个是NaN，不相等（判断一个值是否为NaN，只能用isNaN()来判断）</li>
<li>两个都是字符串，每个位置的字符都一样，相等</li>
<li>两个值都是true，或者都是false，相等</li>
<li>两个值都引用同一个对象或函数，相等</li>
<li>两个值都是null，或者都是undefined，相等</li>
<li>否则不相等。</li>
</ol>
<p>“==” 的规则：如果两个值类型不同，他们可能相等。根据下面的规则进行类型转换再比较。</p>
<ol>
<li>如果一个是null、一个是undefined，那么相等</li>
<li>如果一个是字符串，一个是数值，把字符串转换成数值再进行比较</li>
<li>如果任一值是 true/false，把它转换成 1/0 再比较</li>
<li>如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值在比较。对象转换利用的是toString或者valueOf方法。js核心内酯类，会尝试valueOf先于toString。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>“==”它是值之间的比较；”===”是值和类型同时比较（要完全一直才相等）。</p>
<h2 id="Truthy（真值）是什么"><a href="#Truthy（真值）是什么" class="headerlink" title="Truthy（真值）是什么"></a>Truthy（真值）是什么</h2><p>在JavaScript中，truthy（真值）指的是在布尔值上下文中，转换后的值是真的值。所有值都是真值，除非被定义为假值（即除 <code>false</code>、<code>0</code>、<code>-0</code>、<code>0n</code>、<code>“”</code>、<code>null</code>、<code>undefined</code>、<code>Nall</code> 以外皆为真值）</p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>swagger配置</title>
    <url>/2021/02/24/swagger%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<ol>
<li><p>添加maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置swagger--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>添加swagger配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Swagger配置类.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableSwagger2</span>                <span class="comment">// Swagger的开关，表示已经启用Swagger</span></span><br><span class="line"><span class="meta">@Configuration</span>                 <span class="comment">// 声明当前配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;swagger.basePackage&#125;&quot;)</span>    </span><br><span class="line">    <span class="keyword">private</span> String basePackage;       <span class="comment">// controller接口所在的包</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;swagger.title&#125;&quot;)</span>    </span><br><span class="line">    <span class="keyword">private</span> String title;           <span class="comment">// 当前文档的标题</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;swagger.description&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String description;         <span class="comment">// 当前文档的详细描述</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;swagger.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String version;         <span class="comment">// 当前文档的版本</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">            .apiInfo(apiInfo())</span><br><span class="line">            .select()</span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(basePackage))</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">            .title(title)</span><br><span class="line">            .description(description)</span><br><span class="line">            .version(version)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>application.yml添加配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置swagger</span></span><br><span class="line">    <span class="attr">swagger:</span></span><br><span class="line">        <span class="attr">basePackage:</span> <span class="string">com.genuine.controller</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">swagger-API</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">详细描述</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">V1.0</span></span><br></pre></td></tr></table></figure></li>
<li><p>添加接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(value = &quot;接口介绍&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;yisheng&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I Love You。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">访问地址：http://localhost:端口号/项目名称/swagger-ui.html     </span><br></pre></td></tr></table></figure></li>
<li><p>beautiful UI</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">地址是 http://localhost:8080/doc.html</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180621154833310?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTc1OTg2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>swagger</tag>
        <tag>快速配置</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是脚手架</title>
    <url>/2020/09/21/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<h3 id="在我看来："><a href="#在我看来：" class="headerlink" title="在我看来："></a>在我看来：</h3><p>脚手架就是搭建的能直接从事业务开发的项目框架。比如整合并配置完成了：AOP/Swagger/Mybatis/Druid/通用工具类等。</p>
<h3 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h3><p>指的是两种技术：</p>
<ol>
<li>与某些MVC 框架中的数据库访问相关的代码生成技术</li>
<li>由各种工具支持的项目生成技术</li>
</ol>
<p>脚手架是一种由一些 model–view–controller 框架支持的技术，程序员可以在其中指定应用程序数据库的使用方式。该编译器或框架使用说明书中，与预先定义的代码模板在一起，产生最终代码的应用程序可以使用它来创建，读取，更新和删除数据库条目，有效治疗模板作为“ 支架 ”上建立更强大的应用程序。</p>
]]></content>
      <tags>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建hexo个人博客</title>
    <url>/2020/07/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="简要搭建hexo个人博客"><a href="#简要搭建hexo个人博客" class="headerlink" title="简要搭建hexo个人博客"></a>简要搭建hexo个人博客</h2><ul>
<li>首先电脑里要有Node.js(要选择安装upm)和git的应用程序。<br>接下来在cmd中操作即可。</li>
<li>cmd中输入<blockquote>
<p>npm install -g hexo-cli</p>
</blockquote>
</li>
<li>安装hexo  </li>
<li>选择合适的博客存放文件夹，输入<blockquote>
<p>hexo init blog </p>
</blockquote>
</li>
<li>等待初始化。<blockquote>
<p>cd blog<br>hexo s</p>
</blockquote>
</li>
<li>启动服务，可以在浏览器中看到个人博客，地址：localhost:4000/</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>清理一下，清理缓存和已生成的静态文件</p>
<blockquote>
<p>hexo clean</p>
</blockquote>
<p>生成一下</p>
<blockquote>
<p>hexo g  </p>
</blockquote>
<p>启动一下</p>
<blockquote>
<p>hexo s</p>
</blockquote>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><ul>
<li>在github创建仓库，命名有强制要求：<blockquote>
<p>//例如：nicheng.github.io<br>你的昵称+  .github.io</p>
</blockquote>
</li>
<li>更改_config.yml 文件<blockquote>
<p>deploy:</p>
<blockquote>
<p>type: git<br>repo: 仓库地址<br>branch: master</p>
</blockquote>
</blockquote>
</li>
<li>部署到github上,cmd输入:<blockquote>
<p>npm install –save hexo-deplover-git<br>hexo d</p>
</blockquote>
</li>
<li>输入昵称密码</li>
<li>部署成功，浏览器访问 你的昵称.github.io</li>
</ul>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><ul>
<li>卸载hexo<br>  npm uninstall hexo-cli -g<br>  然后再文件夹中的blog，手动卸载。<br>  注意：进行重装之前，如果还是在原来的位置上，必须手动清理了才能再次安装。</li>
</ul>
<h2 id="再次搭建博客"><a href="#再次搭建博客" class="headerlink" title="再次搭建博客"></a>再次搭建博客</h2><p>通过npm搭建博客</p>
<p>通过npm安装主题，选择的NexT</p>
<p>评论开始使用的手机号登录的畅言，后来换成了github的小插件 utterances</p>
<p>在next文档中，查看，添加本地缓存</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用NATAPP内网穿透</title>
    <url>/2022/12/09/%E4%BD%BF%E7%94%A8NATAPP%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="Mac使用NATAPP内网穿透"><a href="#Mac使用NATAPP内网穿透" class="headerlink" title="Mac使用NATAPP内网穿透"></a>Mac使用NATAPP内网穿透</h1><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>最近很多人居家办公，前后端联调需要一个能访问的公网环境。</p>
<p>内网穿透，也即 NAT 穿透，进行 NAT 穿透是为了使具有某一个特定源 IP 地址和源端口号的数据包不被 NAT 设备屏蔽而正确路由到内网主机。</p>
<p>能让其他人像访问公网一样访问你的内网。</p>
<h2 id="下载NATAPP"><a href="#下载NATAPP" class="headerlink" title="下载NATAPP"></a>下载NATAPP</h2><p>在官网下载地址：<a href="https://natapp.cn/">NATAPP官方网下载地址</a></p>
<p><img src="https://genuine-ipic.oss-cn-beijing.aliyuncs.com/markdown/image-20221209092234581.png" alt="image-20221209092234581"></p>
<p>下载完成解压后，就可以得到我们的资源文件。</p>
<p>官方文档也比较详细：<a href="https://natapp.cn/article/natapp_newbie">官方文档</a></p>
<h2 id="NATAPP配置与启动"><a href="#NATAPP配置与启动" class="headerlink" title="NATAPP配置与启动"></a>NATAPP配置与启动</h2><h3 id="NATAPP文件授权"><a href="#NATAPP文件授权" class="headerlink" title="NATAPP文件授权"></a>NATAPP文件授权</h3><p>下载解压完成后，这个安装包不能直接打开运行。需要给NATAPP文件授权：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 下载镜像文件所在目录</span><br><span class="line">chmod a+x natapp</span><br></pre></td></tr></table></figure>

<p>授权完成后，就能看到该文件被识别为Unix可执行文件。</p>
<h3 id="获取NATAPP的authtoken"><a href="#获取NATAPP的authtoken" class="headerlink" title="获取NATAPP的authtoken"></a>获取NATAPP的authtoken</h3><p>进入NATAPP官网：进行免费注册，注册成功后，选择左边菜单的购买隧道，如图：</p>
<p><img src="https://genuine-ipic.oss-cn-beijing.aliyuncs.com/markdown/image-20221209092854215.png" alt="image-20221209092854215"></p>
<p>选择第一个免费的就行，不过此处需要实名认证支付宝授权。我们进行实名授权，授权完成后，我们来到购买隧道页面：</p>
<p><img src="https://genuine-ipic.oss-cn-beijing.aliyuncs.com/markdown/image-20221209093052318.png" alt="image-20221209093052318"></p>
<p>此处的端口根据项目的端口来填，之后可以随时更改。就比如说你想让别人访问你本机的8080端口，那么这里就填写8080即可。点击免费购买完成购买。</p>
<p>购买完成后在我的隧道中可以看到刚才购买的隧道：</p>
<p><img src="https://genuine-ipic.oss-cn-beijing.aliyuncs.com/markdown/image-20221209093117648.png" alt="image-20221209093117648"></p>
<p>复制authtoken即可。</p>
<h3 id="启动NATAPP"><a href="#启动NATAPP" class="headerlink" title="启动NATAPP"></a>启动NATAPP</h3><p>来到终端，到该文件夹的目录运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./natapp -authtoken=你的authtoken</span><br></pre></td></tr></table></figure>

<p>运行成功后如图所示：</p>
<p><img src="https://genuine-ipic.oss-cn-beijing.aliyuncs.com/markdown/image-20221209093915899.png" alt="image-20221209093915899"></p>
<p>图中的Forwarding信息 <a href="http://xwimcg.natappfree.cc/">http://xwimcg.natappfree.cc</a> -&gt; <strong>127.0.0.1:8080</strong> 代表你访问 <a href="http://xwimcg.natappfree.cc/">http://xwimcg.natappfree.cc</a> 相当于访问本地的 <strong>127.0.0.1:8080</strong>。<br>到此内网穿透就完成了。</p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>组件，框架，中间件</title>
    <url>/2020/07/17/%E6%9E%B6%E6%9E%84%EF%BC%8C%E6%9E%84%E4%BB%B6%EF%BC%8C%E7%BB%84%E4%BB%B6%EF%BC%8C%E6%A1%86%E6%9E%B6%EF%BC%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="架构，构件，组件，框架，中间件"><a href="#架构，构件，组件，框架，中间件" class="headerlink" title="架构，构件，组件，框架，中间件"></a>架构，构件，组件，框架，中间件</h2><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>中间件是一种独立的系统软件或服务程序，分布式应用软件借助它在不同的技术之间 共享资源。<br>中间件位于客户机/服务器的操作系统上，管理计算机资源和网络通信。连接两个独立应用程序或独立系统的软件。<br>相连接的系统具有不同的接口也能交换信息。<br>执行中间件是介于操作系统和应用软件之间，为应用软件提供服务功能的软件，有消息中间件，交易中间件，应用服务器等。</p>
<h6 id="中间件是一种计算机软件连接了软件部件或应用程序。这种软件有一组服务构成，这些服务包括允许多进程运行在一个或多个机器上以达到在网络中互相交互的目的。"><a href="#中间件是一种计算机软件连接了软件部件或应用程序。这种软件有一组服务构成，这些服务包括允许多进程运行在一个或多个机器上以达到在网络中互相交互的目的。" class="headerlink" title="中间件是一种计算机软件连接了软件部件或应用程序。这种软件有一组服务构成，这些服务包括允许多进程运行在一个或多个机器上以达到在网络中互相交互的目的。"></a>中间件是一种计算机软件连接了软件部件或应用程序。这种软件有一组服务构成，这些服务包括允许多进程运行在一个或多个机器上以达到在网络中互相交互的目的。</h6><h6 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类"></a>中间件的分类</h6><p>IDC的分类：</p>
<ol>
<li>终端仿真/屏幕转换</li>
<li>数据访问</li>
<li>远程过程调用</li>
<li>消息中间件</li>
<li>交易中间件</li>
<li>对象中间件</li>
</ol>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>一个具备完备功能的服务接口，可以使用一个组件构建一个系统。</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>构成一类特定可复用设计的一组相互协作的类，框架规定了你的应用程序的体系结构。<br>它定义了整体结构，类和对象的分割，各部分的主要责任，类和对象怎么协作，以及控制流程。<br>实现者无需考虑框架层已经实现好的设计，只要按照开发的要求设计就可以了，然后把开发好的东西放到框架中就可以了。框架一般是成熟的，不断升级的软件。</p>
]]></content>
  </entry>
  <entry>
    <title>编程技巧</title>
    <url>/2020/11/25/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><h3 id="两个实体相同字段赋值"><a href="#两个实体相同字段赋值" class="headerlink" title="两个实体相同字段赋值"></a>两个实体相同字段赋值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanUtils.copyProperties(map, addEntity);</span><br></pre></td></tr></table></figure>

<h3 id="遍历实体非空传入map"><a href="#遍历实体非空传入map" class="headerlink" title="遍历实体非空传入map"></a>遍历实体非空传入map</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();</span><br><span class="line">Field[] fields = addEntity.getClass().getDeclaredFields();</span><br><span class="line">for (Field f: fields) &#123;</span><br><span class="line">    f.setAccessible(true);</span><br><span class="line">    f.getName();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object ob = f.get(addEntity);</span><br><span class="line">        if (null != ob)&#123;</span><br><span class="line">            properties.put(f.getName(), ob.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ParamsCheck &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此注解校验必传字段，判断需要字段是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">attributeName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实体调用接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@ParamsCheck(attributeName = &quot;用户名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ParamsCheck(attributeName = &quot;用户ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckPointParamsHandler</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Field[] fields;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CheckPointParamsHandler</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.clazz = t.getClass();</span><br><span class="line">        <span class="comment">//getDeclaredFields()返回Class中所有的字段，包括私有字段</span></span><br><span class="line">        <span class="comment">//getFields() 只返回公共字段，即有public修改的字段</span></span><br><span class="line">        <span class="built_in">this</span>.fields = t.getClass().getDeclaredFields();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断已经注解的字段是否为空</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">getParamChecksResults</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">R</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (Field field :</span><br><span class="line">                fields) &#123;</span><br><span class="line">            <span class="comment">// 使用注解的必要字段不能为空--如果没有注解直接跳过</span></span><br><span class="line">            <span class="type">ParamsCheck</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(ParamsCheck.class);</span><br><span class="line">            <span class="keyword">if</span> (annotation == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断使用注解的字段是否为空</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> field.getName();</span><br><span class="line">            <span class="type">char</span>[] tempChar = name.toCharArray();</span><br><span class="line">            tempChar[<span class="number">0</span>] -= <span class="number">32</span>;</span><br><span class="line">            <span class="comment">//获得方法名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">tempStr</span> <span class="operator">=</span> <span class="string">&quot;get&quot;</span> + String.valueOf(tempChar);</span><br><span class="line">            <span class="comment">//方法名为key，标签属性attributeName为value</span></span><br><span class="line">            map.put(tempStr, annotation.attributeName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry :</span><br><span class="line">                map.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获得方法的对象</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(key);</span><br><span class="line">                <span class="comment">// 运行方法 获得属性的值</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(t);</span><br><span class="line">                <span class="comment">// 校验属性的值是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (invoke == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(invoke)) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    sb.append(<span class="string">&quot;,&quot;</span>).append(value + <span class="string">&quot;不能为空&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">            res = <span class="keyword">new</span> <span class="title class_">R</span>(sb.toString().substring(<span class="number">1</span>), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="keyword">new</span> <span class="title class_">R</span>(<span class="string">&quot;校验成功&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap初始化多少"><a href="#HashMap初始化多少" class="headerlink" title="HashMap初始化多少"></a>HashMap初始化多少</h3><p>为避免扩容提高性能。</p>
<p>初始化的值为2的幂次方，并且需要注意负载因子（默认为0.75：如果输入7个，就不能初始化为8，应该为16）。</p>
<h2 id="Arango"><a href="#Arango" class="headerlink" title="Arango"></a>Arango</h2><h3 id="arange中查询数据"><a href="#arange中查询数据" class="headerlink" title="arange中查询数据"></a>arange中查询数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> organization</span><br><span class="line"><span class="keyword">filter</span> c.uuid<span class="operator">=</span><span class="operator">=</span>&quot;528971722846769152&quot;</span><br><span class="line"><span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>负载均衡</title>
    <url>/2020/08/17/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h3 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h3><p>Load balancing，即负载均衡，是一种计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。<br>负载均衡（Load Balance），意思是将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案。</p>
<p>参考： <a href="https://www.cnblogs.com/fanBlog/p/10936190.html">https://www.cnblogs.com/fanBlog/p/10936190.html</a></p>
]]></content>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级与重量级</title>
    <url>/2020/07/17/%E8%BD%BB%E9%87%8F%E7%BA%A7%E4%B8%8E%E9%87%8D%E9%87%8F%E7%BA%A7/</url>
    <content><![CDATA[<p>轻量级与重量级<br>两者是一个相对概念，主要是对应 应用框架的使用方便性和所提供的服务特性等方面作比较。<br>比如：<br>EJB是重量级框架：对编写的代码有限制，同时提供了分布式等复杂的功能。<br>Spring是轻量级框架：只需要普通的Java对象，提供中小应用使用的功能。</p>
<p>划分一个应用是否属于轻量级还是重量级，主要看使用了多少服务。<br>使用的服务越多，容器要为普通Java对象做的工作越多，必然会影响到应用的发布时间或运行性能。<br>对于spring容器，提供了很多服务，但这些服务不是默认打开的，应用需要某种服务，需指明使用该服务。如果应用使用的服务很少，如：只使用了spring核心服务，可以认为此时应用属于轻量级的；如果应用使用了spring提供的大部分服务，这是应用就属于重量级。EJB容器就因为他默认为应用提供了EJB规范中所有的功能，所以属于重量级。</p>
]]></content>
  </entry>
  <entry>
    <title>MyBatis-Plus的使用</title>
    <url>/2021/02/24/MyBatis/MyBatis-Plus%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="max、sum"><a href="#max、sum" class="headerlink" title="max、sum"></a>max、sum</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Bean&gt;().select(“max(level_sort) as levelSort”);</span><br></pre></td></tr></table></figure>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="表映射实体新增字段"><a href="#表映射实体新增字段" class="headerlink" title="表映射实体新增字段"></a>表映射实体新增字段</h3><p>需要在新增的冗余字段上增加注解<code>@TableField(exist = false)</code>,便不会再影响<code>MyBatis-Plus</code>查询方法的使用</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebsiteServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">WebsiteService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebsiteMapper websiteMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PageUtils <span class="title function_">list</span><span class="params">(Integer limit, Integer page)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用Mybatis-plus分页插件</span></span><br><span class="line">        Page&lt;WebsiteDto&gt; pageSet = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page, limit);</span><br><span class="line">        IPage&lt;WebsiteDto&gt; iPage = websiteMapper.list(pageSet);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageUtils</span>(iPage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据传输层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WebsiteMapper</span> <span class="keyword">extends</span> <span class="title class_">OsiiapWebsiteDao</span> &#123;</span><br><span class="line">    IPage&lt;WebsiteDto&gt; <span class="title function_">list</span><span class="params">(IPage&lt;WebsiteDto&gt; pageSet)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapping</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kedian.osiiap.console.dao.WebsiteMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;websiteDto&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.kedian.osiiap.console.dto.WebsiteDto&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;uuid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uuid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;originalName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;original_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;chineseName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;chinese_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;website&quot;</span> <span class="attr">column</span>=<span class="string">&quot;website&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;image&quot;</span> <span class="attr">column</span>=<span class="string">&quot;image&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;brief&quot;</span> <span class="attr">column</span>=<span class="string">&quot;brief&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;word&quot;</span> <span class="attr">column</span>=<span class="string">&quot;word&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;insertTime&quot;</span> <span class="attr">column</span>=<span class="string">&quot;insert_time&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;country&quot;</span> <span class="attr">column</span>=<span class="string">&quot;country&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;language&quot;</span> <span class="attr">column</span>=<span class="string">&quot;language&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;status&quot;</span> <span class="attr">column</span>=<span class="string">&quot;status&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sourceType&quot;</span> <span class="attr">column</span>=<span class="string">&quot;source_type&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kedian.osiiap.console.dto.WebsiteDto&quot;</span>&gt;</span></span><br><span class="line">        SELECT web.uuid, web.original_name,  web.chinese_name, web.website, web.word, web.source_type,</span><br><span class="line">            dict1.`value` country, dict2.`value` `language`, web.image, web.brief, web.`status`, web.insert_time</span><br><span class="line">        FROM `osiiap_website` web</span><br><span class="line">        LEFT JOIN osiiap_dictionary dict1 on web.country = dict1.uuid</span><br><span class="line">        LEFT JOIN osiiap_dictionary dict2 on web.`language` = dict2.uuid</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:/mapping/*.xml</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MyBatis</category>
        <category>MyBatis-Plus</category>
      </categories>
      <tags>
        <tag>MyBatis-Plus</tag>
        <tag>分页</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/2020/12/30/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>与：&amp;</p>
<p>或：|</p>
<p>非：~（输入1，返回0；输入0，返回1）</p>
<p>异或：^（两个不同返回1，相同返回0）</p>
<h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>左移位运算符：&lt;&lt;（运算对象向左移动指定位数，在低位补0）。</p>
<p>右移位运算符：&gt;&gt;（值为正，在高位插0；值为负，在高位插1）。</p>
<p>不分正负的右移位运算符：&gt;&gt;&gt;（无论正负，高位插0），这运算符C/C++没有。</p>
<p>二进制加减法：</p>
<p>加法直接两数二进制相加；</p>
<p>减法变为 加 负数。</p>
<p>负数二进制怎么求：正数二进制 先取反 然后 加1 求的负数。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis的使用</title>
    <url>/2020/08/19/MyBatis/MyBatis%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="注意一级缓存"><a href="#注意一级缓存" class="headerlink" title="注意一级缓存"></a>注意一级缓存</h3><p>在一个事务中，重复查询数据库，只会查询一次，其余走缓存，并且，如果数据进行了修改，将会把指向缓存的对象进行修改。导致，引用该对象的变量，发现数据莫名其妙的改变了。应该养成禁止修改数据库查询的数据后进行反复的修改和引用等操作，及时进行数据库修改操作，刷新缓存。</p>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>缓存可以极大的提高查询效率。</p>
<p>两级缓存：</p>
<h4 id="一级缓存：（本地缓存）"><a href="#一级缓存：（本地缓存）" class="headerlink" title="一级缓存：（本地缓存）"></a>一级缓存：（本地缓存）</h4><ol>
<li>默认作用域：sqlSession</li>
<li>与数据库一次会话期间查询到的数据会放到本地缓存中。以后如果需要获取相同的数据，直接从缓存中拿。</li>
</ol>
<h4 id="二级缓存：（全局缓存）"><a href="#二级缓存：（全局缓存）" class="headerlink" title="二级缓存：（全局缓存）"></a>二级缓存：（全局缓存）</h4><ol>
<li><p>默认不开启，需要手动配置</p>
</li>
<li><p>使用步骤</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">– 1、全局配置文件中开启二级缓存</span><br><span class="line"> <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">*</span>&quot;<span class="attr">cacheEnabled</span>&quot; <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>*</span><br><span class="line">– 2、需要使用二级缓存的映射文件处使用cache配置缓存</span><br><span class="line"> <span class="tag">&lt;<span class="name">cache</span> /&gt;</span></span><br><span class="line">– 3、注意：POJO需要实现Serializable接口</span><br></pre></td></tr></table></figure></li>
<li><p>缓存相关属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• eviction=“FIFO”：缓存回收策略：</span><br><span class="line">	• LRU – 最近最少使用的：移除最长时间不被使用的对象。</span><br><span class="line">    • FIFO – 先进先出：按对象进入缓存的顺序来移除它们。</span><br><span class="line">    • SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</span><br><span class="line">    • WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</span><br><span class="line">    • 默认的是 LRU。 </span><br><span class="line">• flushInterval：刷新间隔，单位毫秒</span><br><span class="line">	• 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</span><br><span class="line">• size：引用数目，正整数</span><br><span class="line">	• 代表缓存最多可以存储多少个对象，太大容易导致内存溢出</span><br><span class="line">• readOnly：只读，true/false</span><br><span class="line">    • true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。</span><br><span class="line">    • false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>延迟加载，也叫懒加载，但是懒加载往往与分布查询同时使用  </p>
<h3 id="分布查询"><a href="#分布查询" class="headerlink" title="分布查询"></a>分布查询</h3><p>先查询主表，通过主表的结果信息将作为参数传递给关联表，查询关联表的信息。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;MystudentStep&quot; type=&quot;com.tulun.bean.Student&quot;&gt;  </span><br><span class="line">    &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;  </span><br><span class="line">    &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt;  </span><br><span class="line">    &lt;result column=&quot;passward&quot; property=&quot;passward&quot;&gt;&lt;/result&gt;  </span><br><span class="line">    &lt;!--</span><br><span class="line">        association:定义关联对象的封装规则</span><br><span class="line">        select:表明当前属性是调用select 指定的方法查出的结果</span><br><span class="line">        column:指定将哪一列的值传给这个方法</span><br><span class="line">        流程：使用select 指定的方法（传入column 指定的这列参数的值）查出对象，</span><br><span class="line">                并封装给property 指定的属性</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;association property=&quot;dept&quot;</span><br><span class="line">                 select=&quot;com.tulun.dao.DeptMapper.getDeptById&quot;</span><br><span class="line">                 column=&quot;d_id&quot;&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;  </span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getStuByIdStep&quot; resultMap=&quot;MystudentStep&quot;&gt;</span><br><span class="line">    select * from student where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;select id=&quot;getDeptById&quot; resultType=&quot;com.tulun.bean.Dept&quot;&gt;</span><br><span class="line"> 	select * from dept where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="延迟加载-1"><a href="#延迟加载-1" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>MyBatis中的延迟加载，也称为懒加载，是指在进行关联查询时，按照设置延迟规则推迟对关联对象的select查询。延迟加载可以有效的减少数据库压力。</p>
<p>Mybatis 根据关联对象查询Select 语句的查询时机分为：直接加载、侵入式加载、深度延迟性加载。  </p>
<ol>
<li>直接加载<br>执行完主加载对象的select语句，马上执行关联对象的Select语句</li>
<li>侵入式加载<br>执行完主加载对象查询后不会马上执行关联对象查询，但是当访问主加载对象时，就会加载关联对象的查询。即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。  </li>
<li>深度延迟加载<br>执行主对象的查询时不会执行关联对象的执行，访问主对象详情时也不会执行关联对象的查询，只有当访问关联对象时才会对其进行查询 </li>
</ol>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>缓存机制</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-Plus的学习</title>
    <url>/2020/11/18/MyBatis/MyBatis-Plus%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MyBatis-Plus(简称MP)是一个MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用Mapper、通用Service，仅仅通过少量配置即可实现单表大部分CRUD操作，强大的条件构造器，满足各类使用需求</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li>。。。</li>
</ul>
<h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3><p><img src="https://baomidou.com/img/mybatis-plus-framework.jpg" alt="framework"></p>
<h3 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h3><ul>
<li><a href="https://www.imooc.com/learn/1130">MyBatis-Plus 入门 - 视频教程 - 慕课网</a></li>
<li><a href="https://www.imooc.com/learn/1171">MyBatis-Plus 进阶 - 视频教程 - 慕课网</a></li>
</ul>
<h2 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h2><p><a href="https://baomidou.com/guide/quick-start.html">快速开发链接</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全新的 <code>MyBatis-Plus</code> 3.0 版本基于 JDK8，提供了 <code>lambda</code> 形式的调用，所以安装集成 MP3.0 要求如下：</p>
<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>Maven：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>Maven:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Spring Boot 工程：</p>
<ul>
<li><p>配置 MapperScan 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.baomidou.mybatisplus.samples.quickstart.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Spring MVC 工程：</p>
<ul>
<li><p>配置 MapperScan</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.baomidou.mybatisplus.samples.quickstart.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>调整 SqlSessionFactory 为 MyBatis-Plus 的 SqlSessionFactory</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ul>
<li>@TableName</li>
<li>@TableId</li>
<li>@TableField</li>
<li>@Version</li>
<li>@EnumValue</li>
<li>@TableLogic</li>
<li>@SqlParser</li>
<li>@KeySequence</li>
</ul>
<h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h2><p>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</p>
<p><a href="https://baomidou.com/guide/generator.html">代码生成器使用教程链接</a></p>
<h2 id="CRUD接口"><a href="#CRUD接口" class="headerlink" title="CRUD接口"></a>CRUD接口</h2><p><a href="https://baomidou.com/guide/crud-interface.html">CRUD接口官方文档链接</a></p>
<ul>
<li>Service CRUD接口</li>
<li>Mapper CRUD 接口</li>
<li>mapper 层 选装件</li>
</ul>
<h2 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h2><p>说明：</p>
<blockquote>
<ul>
<li><p>出现的第一个入参<code>boolean condition</code>表示该条件<strong>是否</strong>加入最后生成的sql中</p>
</li>
<li><p>代码块内的多个方法均为从上往下补全个别<code>boolean</code>类型的入参,默认为<code>true</code></p>
</li>
<li><p>出现的泛型<code>Param</code>均为<code>Wrapper</code>的子类实例(均具有<code>AbstractWrapper</code>的所有方法)</p>
</li>
</ul>
</blockquote>
<h3 id="AbsractWrapper"><a href="#AbsractWrapper" class="headerlink" title="AbsractWrapper"></a>AbsractWrapper</h3><p>QueryWrapper(LambdaQueryWrapper) 和 UpdateWrapper(LambdaUpdateWrapper) 的父类<br>用于生成 sql 的 where 条件,entity属性也用于生成sql的where条件</p>
<p>注意：entity生成的where条件与使用各个api生成的where条件<strong>没有任何关联行为</strong></p>
<h4 id="allEq"><a href="#allEq" class="headerlink" title="allEq"></a>allEq</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allEq(Map&lt;R, V&gt; params)</span><br><span class="line">allEq(Map&lt;R, V&gt; params, <span class="type">boolean</span> null2IsNull)</span><br><span class="line">allEq(<span class="type">boolean</span> condition, Map&lt;R, V&gt; params, <span class="type">boolean</span> null2IsNull)</span><br></pre></td></tr></table></figure>

<ul>
<li>全部<a href="https://baomidou.com/guide/wrapper.html#eq">eq</a>(或个别<a href="https://baomidou.com/guide/wrapper.html#isnull">isNull</a>)</li>
</ul>
<blockquote>
<p>个别参数说明:</p>
<p><code>params</code> : <code>key</code>为数据库字段名,<code>value</code>为字段值<br><code>null2IsNull</code> : 为<code>true</code>则在<code>map</code>的<code>value</code>为<code>null</code>时调用 <a href="https://baomidou.com/guide/wrapper.html#isnull">isNull</a> 方法,为<code>false</code>时则忽略<code>value</code>为<code>null</code>的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params)</span><br><span class="line">allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params, <span class="type">boolean</span> null2IsNull)</span><br><span class="line">allEq(<span class="type">boolean</span> condition, BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params, <span class="type">boolean</span> null2IsNull) </span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params)</span><br><span class="line">allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params, <span class="type">boolean</span> null2IsNull)</span><br><span class="line">allEq(<span class="type">boolean</span> condition, BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params, <span class="type">boolean</span> null2IsNull) </span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="eq"><a href="#eq" class="headerlink" title="eq"></a>eq</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eq(R column, Object val)</span><br><span class="line">eq(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>等于 =</li>
<li>例: <code>eq(&quot;name&quot;, &quot;老王&quot;)</code>—&gt;<code>name = &#39;老王&#39;</code></li>
</ul>
<h4 id="ne"><a href="#ne" class="headerlink" title="ne"></a>ne</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ne(R column, Object val)</span><br><span class="line">ne(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>不等于 &lt;&gt;</li>
<li>例: <code>ne(&quot;name&quot;, &quot;老王&quot;)</code>—&gt;<code>name &lt;&gt; &#39;老王&#39;</code></li>
</ul>
<h4 id="gt"><a href="#gt" class="headerlink" title="gt"></a>gt</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">gt(R column, Object val)</span><br><span class="line">gt(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>大于 &gt;</li>
<li>例: <code>gt(&quot;age&quot;, 18)</code>—&gt;<code>age &gt; 18</code></li>
</ul>
<h4 id="ge"><a href="#ge" class="headerlink" title="ge"></a>ge</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ge(R column, Object val)</span><br><span class="line">ge(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>大于等于 &gt;=</li>
<li>例: <code>ge(&quot;age&quot;, 18)</code>—&gt;<code>age &gt;= 18</code></li>
</ul>
<h4 id="lt"><a href="#lt" class="headerlink" title="lt"></a>lt</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lt(R column, Object val)</span><br><span class="line">lt(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>小于 &lt;</li>
<li>例: <code>lt(&quot;age&quot;, 18)</code>—&gt;<code>age &lt; 18</code></li>
</ul>
<h4 id="le"><a href="#le" class="headerlink" title="le"></a>le</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">le(R column, Object val)</span><br><span class="line">le(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>小于等于 &lt;=</li>
<li>例: <code>le(&quot;age&quot;, 18)</code>—&gt;<code>age &lt;= 18</code></li>
</ul>
<h4 id="between"><a href="#between" class="headerlink" title="between"></a>between</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">between(R column, Object val1, Object val2)</span><br><span class="line">between(<span class="type">boolean</span> condition, R column, Object val1, Object val2)</span><br></pre></td></tr></table></figure>

<ul>
<li>BETWEEN 值1 AND 值2</li>
<li>例: <code>between(&quot;age&quot;, 18, 30)</code>—&gt;<code>age between 18 and 30</code></li>
</ul>
<h4 id="…"><a href="#…" class="headerlink" title="…."></a>….</h4><ul>
<li>notBetween</li>
<li>like</li>
<li>notLike</li>
<li>likeLeft</li>
<li>likeRight</li>
<li>isNull</li>
<li>isNotNull</li>
<li>in</li>
<li>notIn</li>
<li>inSql</li>
<li>notInSql</li>
<li>groupBy</li>
<li>orderByAsc</li>
<li>orderByDesc</li>
<li>orderBy</li>
<li>having</li>
<li>func</li>
<li>or</li>
<li>and</li>
<li>nested</li>
<li>apply</li>
<li>last</li>
<li>exists</li>
<li>notExists</li>
</ul>
<h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h3><blockquote>
<p>说明：</p>
<p>继承自 AbstractWrapper ,自身的内部属性 entity 也用于生成 where 条件及 LambdaQueryWrapper, 可以通过 new QueryWrapper().lambda() 方法获取</p>
</blockquote>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select(String... sqlSelect)</span><br><span class="line">select(Predicate&lt;TableFieldInfo&gt; predicate)</span><br><span class="line">select(Class&lt;T&gt; entityClass, Predicate&lt;TableFieldInfo&gt; predicate)</span><br></pre></td></tr></table></figure>

<ul>
<li>设置查询字段</li>
</ul>
<blockquote>
<p>说明:</p>
<p>以上方法分为两类.<br>第二类方法为:过滤查询字段(主键除外),入参不包含 class 的调用前需要<code>wrapper</code>内的<code>entity</code>属性有值! 这两类方法重复调用以最后一次为准</p>
</blockquote>
<ul>
<li>例: <code>select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;)</code></li>
<li>例: <code>select(i -&gt; i.getProperty().startsWith(&quot;test&quot;))</code></li>
</ul>
<h3 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h3><blockquote>
<p>说明：</p>
<p>继承自 <code>AbstractWrapper</code> ,自身的内部属性 <code>entity</code> 也用于生成 where 条件及 <code>LambdaUpdateWrapper</code>, 可以通过 <code>new UpdateWrapper().lambda()</code> 方法获取</p>
</blockquote>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set(String column, Object val)</span><br><span class="line">set(<span class="type">boolean</span> condition, String column, Object val)</span><br></pre></td></tr></table></figure>

<ul>
<li>SQL SET 字段</li>
<li>例: <code>set(&quot;name&quot;, &quot;老李头&quot;)</code></li>
<li>例: <code>set(&quot;name&quot;, &quot;&quot;)</code>—&gt;数据库字段值变为<strong>空字符串</strong></li>
<li>例: <code>set(&quot;name&quot;, null)</code>—&gt;数据库字段值变为<code>null</code></li>
</ul>
<h4 id="setSql"><a href="#setSql" class="headerlink" title="setSql"></a>setSql</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setSql(String sql)</span><br></pre></td></tr></table></figure>

<ul>
<li>设置 SET 部分 SQL</li>
<li>例: <code>setSql(&quot;name = &#39;老李头&#39;&quot;)</code></li>
</ul>
<h4 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h4><ul>
<li>获取 <code>LambdaWrapper</code><br>在<code>QueryWrapper</code>中是获取<code>LambdaQueryWrapper</code><br>在<code>UpdateWrapper</code>中是获取<code>LambdaUpdateWrapper</code></li>
</ul>
<h3 id="使用Wrapper自定义SQL"><a href="#使用Wrapper自定义SQL" class="headerlink" title="使用Wrapper自定义SQL"></a>使用Wrapper自定义SQL</h3><blockquote>
<p>需求来源:</p>
<p>在使用了<code>mybatis-plus</code>之后, 自定义SQL的同时也想使用<code>Wrapper</code>的便利应该怎么办？ 在<code>mybatis-plus</code>版本<code>3.0.7</code>得到了完美解决 版本需要大于或等于<code>3.0.7</code>, 以下两种方案取其一即可</p>
</blockquote>
<h4 id="Service-java"><a href="#Service-java" class="headerlink" title="Service.java"></a>Service.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysqlMapper.getAll(Wrappers.&lt;MysqlData&gt;lambdaQuery().eq(MysqlData::getGroup, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h4 id="方案一-注解方式-Mapper-java"><a href="#方案一-注解方式-Mapper-java" class="headerlink" title="方案一 注解方式 Mapper.java"></a>方案一 注解方式 Mapper.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from mysql_data $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">List&lt;MysqlData&gt; <span class="title function_">getAll</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper wrapper)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="方案二-XML形式-Mapper-xml"><a href="#方案二-XML形式-Mapper-xml" class="headerlink" title="方案二 XML形式 Mapper.xml"></a>方案二 XML形式 Mapper.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;MysqlData&quot;</span>&gt;</span></span><br><span class="line">	SELECT * FROM mysql_data $&#123;ew.customSqlSegment&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="kotlin使用wrapper"><a href="#kotlin使用wrapper" class="headerlink" title="kotlin使用wrapper"></a>kotlin使用wrapper</h4><blockquote>
<p>kotlin 可以使用 <code>QueryWrapper</code> 和 <code>UpdateWrapper</code> 但无法使用 <code>LambdaQueryWrapper</code> 和 <code>LambdaUpdateWrapper</code><br>如果想使用 lambda 方式的 wrapper 请使用 <code>KtQueryWrapper</code> 和 <code>KtUpdateWrapper</code></p>
</blockquote>
]]></content>
      <categories>
        <category>MyBatis</category>
        <category>Mybatis-Plus</category>
      </categories>
      <tags>
        <tag>MyBatis-Plus</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-未完成</title>
    <url>/2020/08/12/java/JVM-%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
    <content><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>java 跨平台语言就是因为JVM<br>JVM 跨语言的平台：Kotlin,Clojure,Groovy(需各自的编译器)…<br>趋向于 多语言混合编程<br>如何搞懂JVM，自己动手编写一个JVM虚拟机。  </p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>虚拟机（Virtual Machine）虚拟的计算机，分为系统虚拟机和程序虚拟机（专门执行单个计算机程序而设计）。</p>
<h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><p>Java技术的核心就是Java虚拟机（二进制字节码的运行环境）。<br>特点： </p>
<ul>
<li>一次编译，到处运行  </li>
<li>自动内存管理  </li>
<li>自动垃圾回收功能  <h3 id=""><a href="#" class="headerlink" title=""></a></h3>Java源文件 - 编译器 - 字节码文件 .class - 类加载器 - 字节码校验器 - 翻译字节码、JIT编译器（解释执行即时编译）  <h3 id="Java架构模型"><a href="#Java架构模型" class="headerlink" title="Java架构模型"></a>Java架构模型</h3>Java编译器上输入的指令流是基于栈的指令集架构。（另一种指令集架构是基于寄存器的指令集架构）<br>跨平台性、指令集小、指令多；执行性能比寄存器差。 <h3 id="反编译操作"><a href="#反编译操作" class="headerlink" title="反编译操作"></a>反编译操作</h3>cd out/production/java<br>javap -v StackStruTest.class    <h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h3></li>
</ul>
<ol>
<li><p>启动：引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成。这个类有虚拟机的具体实现来指定的。  </p>
</li>
<li><p>执行：执行Java，真正是执行程序jvm虚拟机的进程。（jps查看进程）  </p>
</li>
<li><p>退出：程序正常执行结束；遇到异常或错误；线程盗用exit()或halt()方法（Runtime()是单例的）。  </p>
<h3 id="JVM的发展历程"><a href="#JVM的发展历程" class="headerlink" title="JVM的发展历程"></a>JVM的发展历程</h3><p>（san）classic VM 、 Exact VM 、 hotspot VM<br>（BEA）JRockit：专注于服务器端，纯即时编译器<br>（IBM）J9：IBM Technology for Java Virtual Machine 简称IT4J。<br>KVM：面向更低端的设备（如：智能控制器，传感器）<br>Azul VM和BEA Liquid VM 与特定硬件平台绑定、软硬件配合的专有虚拟机。<br>Apache Harmony<br>Microsoft JVM<br>TaobaoJVM<br>（非Java，应用Android系统）Dalvik VM<br>（Oracle发展中 跨语言全栈虚拟机）Graal VM  </p>
<h1 id="类加载器与类加载子系统"><a href="#类加载器与类加载子系统" class="headerlink" title="类加载器与类加载子系统"></a>类加载器与类加载子系统</h1><p>类加载子系统 加载class文件，class文件在文件开头有特殊的标识。<br>ClassLoader只负责class文件的加载，是否能运行有ExecutionEngine决定。<br>加载的类信息存放于方法区的内存空间。方法去还有存放运行时常量池信息。  </p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p>开始 - 装载类HelloLoader - （是否装载顺利，否则抛出异常） - 链接 - 初始化HelloLoader - 调用 HelloLoader.main() - 结束  </p>
</li>
<li><p>加载Loading：</p>
<ol>
<li>通过类的全限定名获取此类的二进制字节流。</li>
<li>静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法去这个类的各种数据的访问对象。</li>
</ol>
</li>
<li><p>链接：</p>
<ol>
<li>验证Verify：确保class文件中的字节流中包含的信息符合当前虚拟机要求，保证被加载类的正确性。<ol>
<li>主要四种验证：文件格式，元数据，字节码，符号引用验证。</li>
</ol>
</li>
<li>准备Prepare：为类变量分配内存并赋值默认初始值，如零值。（后初始化）  <ol>
<li>这里不包含final修饰的static，因为final在编译时就会分配，准备阶段会显式初始化；</li>
<li>不会为实例变量分配初始化。类变量会分配在方法区中，而实例变量会随着对象一起分配到Java堆中。</li>
</ol>
</li>
<li>解析Resolve：符号引用转换为直接引用。</li>
</ol>
</li>
<li><p>初始化Initialization：</p>
<ol>
<li><p> 初始化阶段就是执行类构造器方法<clinit>()的过程。</p>
</li>
<li><p> 不需定义，javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p>
</li>
<li><p> 构造器方法中指令按语句在源文件中出现的顺序执行。</p>
</li>
<li><p> <clinit>()不同于类的构造器。</p>
</li>
<li><p> 类中有构造方法会出现<init>的结构</p>
</li>
<li><p> 该类有父类，加载Father类，其次加载Son类。</p>
</li>
<li><p> 虚拟机保证一个类的<clinit>()方法在多线程下被同步加锁（一个类只会被加载一次 ）。  </p>
<h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p>自定义类，系统类，扩展类，引导类加载器（四者是包含关系）<br>两种类型：  </p>
</li>
<li><p>引导类加载器（Java的核心类库使用引导类加载器进行加载的 .class.getClassLoader() 获取不到。C和C++编写的）</p>
</li>
<li><p>自定义类加载器（继承了ClassLoader的类，如系统，扩展类）</p>
</li>
</ol>
</li>
</ol>
<p>为什么要自定义类加载器：</p>
<pre><code>1. 隔离加载类：使用中间件时，隔离不冲突。  
2. 修改类加载的方式：需要的是狗动态加载。  
3. 扩展加载源  
4. 防止源码泄露  
</code></pre>
<ol>
<li><p>启动类加载器（引导类加载器，Bootstrap classLoader）  </p>
<ol>
<li>没有父加载器</li>
<li>加载Java的核心库</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>
<li>C/C++语言实现的，嵌套在JVM内部。  </li>
</ol>
</li>
<li><p>扩展类加载器（Extension ClassLoader）</p>
<ol>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li>
</ol>
</li>
</ol>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>有父类加载器向上委托。父类加载器失败交由子加载器自己处理。</p>
<p>优势：<br>    1. 避免类的重复加载。<br>    2. 保护程序安全，防止核心API被篡改。  </p>
<p>沙箱安全机制：保护引导类加载器不被破坏。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>JVM中两个class对象是否一个类名：</p>
<pre><code>1. 类的完整类名一直，包括包名。  
2. 加载这个类的ClassLoader必须相同。  
</code></pre>
<p>Java程序对类的使用方式：主动使用和被动使用   </p>
<p>被动使用：不会初始化。  </p>
<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>（run data area）方法区（堆外内存）、堆、虚拟机栈、本地方法栈、程序计数器。<br>不同的JVM对内存的划分方式和管理机制存在部分差异。<br>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）。<br>每个线程：独立包括程序计数器、栈、本地栈。  </p>
<h4 id="Class-Runtime"><a href="#Class-Runtime" class="headerlink" title="Class Runtime"></a>Class Runtime</h4><p>一个JVM对应着一个Runtime实例  </p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>每个线程都与操作系统的本地线程直接映射。<br>后台系统线程主要有：</p>
<ul>
<li>虚拟机线程</li>
<li>周期任务线程</li>
<li>GC线程</li>
<li>编译线程</li>
<li>信号调度线程  </li>
</ul>
<h2 id="程序计数寄存器（PC寄存器）"><a href="#程序计数寄存器（PC寄存器）" class="headerlink" title="程序计数寄存器（PC寄存器）"></a>程序计数寄存器（PC寄存器）</h2><p>(Program Counter Register) ,类似CPU的寄存器。  </p>
<p><img src="https://i.loli.net/2020/09/17/aAQRoLHXIhnO54K.png" alt="程序计数寄存器.PNG"></p>
<p>PC寄存器：用来存储当前JVM线程指向下一条指令的地址。由执行引擎读取。</p>
<p><img src="https://i.loli.net/2020/09/17/Fwsekfu6RhMy7cH.png" alt="程序计数寄存器执行过程.PNG"></p>
<h2 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h2><p>CPU分配给各个程序的时间，一个时间段只有一个线程执行。</p>
<p>并行：同时执行 vs串行</p>
<p>并发：一个核执行，快速切换。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java的指令是根据栈设计的。</p>
<p>优点：跨平台，指令集小，编译器容易实现。</p>
<p>栈是运行时的单位（如何运行，如何处理数据），堆是存储时的单位（数据怎么放，放在那里）。</p>
<p>线程私有虚拟机栈，内部保存一个个的栈帧（对应一个个Java方法）。栈中的数据都是以栈帧（Stack Frame）格式存储的。</p>
<p>栈帧：是一个内存区块，维系着方法执行过程中的各种数据信息。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>保存方法的局部变量（8中基本数据类型、对象的引用地址）、部分结果、参与方法的调用和返回</p>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>开发中遇到的异常有哪些？<br>固定大小虚拟机栈，栈容量不足，栈溢出StackOverfowError异常<br>虚拟机可以动态扩展，内存不足，内存溢出OutOfMemoryError异常</p>
<h4 id="设置虚拟机栈的大小"><a href="#设置虚拟机栈的大小" class="headerlink" title="设置虚拟机栈的大小"></a>设置虚拟机栈的大小</h4><pre><code>// 调优：参数调优。
-Xss size
</code></pre>
<h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接（指向运行时常量池的方法引用）</li>
<li>方法返回地址（方法正常退出或异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p>局部变量表<br>操作数栈<br>代码追踪<br>栈顶缓存 技术<br>动态链接<br>方法的调用：解析与分派<br>方法返回地址<br>附加信息</p>
<p>当前线程-Java栈-当前栈帧-局部变量表、操作数栈、动态链接、方法返回值。</p>
<h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><ol>
<li><p>PC寄存器为什么记录当前线程的执行地址？</p>
<p> CPU 切换不同的线程，要知道接着从哪里开始执行。</p>
</li>
<li><p>PC寄存器为什么要设置成线程私有？</p>
<p> 各个线程，各自PC寄存器记录自己线程的当前字节码指令地址。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java EE 与 J2EE 一样吗？有什么关系？</title>
    <url>/2021/04/16/java/20210416-JavaEE%E4%B8%8EJ2EE%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="J2EE的由来"><a href="#J2EE的由来" class="headerlink" title="J2EE的由来"></a>J2EE的由来</h2><p>1998年12月4日，工程代号名为<strong>Playground</strong>（竞技场）的<strong>JDK1.2</strong>发布了，该版本<strong>Sun</strong>公司把<strong>Java</strong>技术体系拆分为三个方向：</p>
<ol>
<li>面向桌面应用开发的<strong>J2SE</strong>（Java 2 Platform，Standard Edition）</li>
<li>面向企业级开发的<strong>J2EE</strong>（Java 2 Platform， Enterprise Edition）</li>
<li>面向手机等移动终端的<strong>J2ME</strong>（Java 2 Platform， Micro Edition）</li>
</ol>
<h2 id="Java-EE-由来"><a href="#Java-EE-由来" class="headerlink" title="Java EE 由来"></a>Java EE 由来</h2><p>2006年12月11日，工程代号为<strong>Mustang</strong>（野马）的<strong>JDK6</strong>发布了，Sun公司终结了从JDK1.2开始已有八年历史的<strong>J2EE</strong>、<strong>J2SE</strong>、<strong>J2ME</strong>的产品线命名，启用了<strong>Java EE 6</strong>、<strong>Java SE 6</strong>、<strong>Java ME 6</strong>的新命名来代替。</p>
<h2 id="Java-EE-被废弃"><a href="#Java-EE-被废弃" class="headerlink" title="Java EE 被废弃"></a>Java EE 被废弃</h2><p>2018年3月，<strong>Oracle</strong>正式宣告<strong>Java EE</strong> 成为历史名词。</p>
<p>虽然JavaEE曾经无比辉煌过，现在其中还持有JDBC、JMS、Servlet等使用极为广泛的基础组件，<strong>Oracle</strong>还是选择把它“扫地出门”。</p>
<p>所有权直接赠送给<strong>Eclipse</strong>基金会，唯一条件是以后不准再使用“Java”这个商标，所以取而代之的将是<strong>Jakarta EE</strong>。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8的新特性</title>
    <url>/2020/09/21/java/Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>新增了非常多的特性，主要有：</p>
<ul>
<li><strong>Lambad表达式</strong>：Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li>
<li><strong>方法引用</strong>：可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合，使语言的构造更紧凑简洁，减少冗余代码。</li>
<li><strong>默认方法</strong>：默认方法就是一个在接口里面有了一个实现的方法。</li>
<li><strong>StreamAPI</strong>：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li>
<li><strong>DateTimeAPI</strong>：加强对日期与时间的处理。</li>
<li><strong>Optional类</strong>：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li><strong>Nashorn，JavaScript引擎</strong>：Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li>
</ul>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p>
<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>
<ol>
<li><p>接收2个int型整数,返回他们的和<br>(int x, int y) -&gt; x + y  </p>
</li>
<li><p>接受2个参数(数字),并返回他们的差值<br>(x, y) -&gt; x – y  </p>
</li>
<li><p>接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)<br>(String s) -&gt; System.out.print(s)</p>
<pre><code> public class Java8Tester &#123;
    public static void main(String args[])&#123;
       Java8Tester tester = new Java8Tester();
         
       // 类型声明
       MathOperation addition = (int a, int b) -&gt; a + b;
         
       // 不用类型声明
       MathOperation subtraction = (a, b) -&gt; a - b;
         
       // 大括号中的返回语句
       MathOperation multiplication = (int a, int b) -&gt; &#123; return a * b; &#125;;
         
       // 没有大括号及返回语句
       MathOperation division = (int a, int b) -&gt; a / b;
         
       System.out.println(&quot;10 + 5 = &quot; + tester.operate(10, 5, addition));
       System.out.println(&quot;10 - 5 = &quot; + tester.operate(10, 5, subtraction));
       System.out.println(&quot;10 x 5 = &quot; + tester.operate(10, 5, multiplication));
       System.out.println(&quot;10 / 5 = &quot; + tester.operate(10, 5, division));
         
       // 不用括号
       GreetingService greetService1 = message -&gt;
       System.out.println(&quot;Hello &quot; + message);
         
       // 用括号
       GreetingService greetService2 = (message) -&gt;
       System.out.println(&quot;Hello &quot; + message);
         
       greetService1.sayMessage(&quot;Runoob&quot;);
       greetService2.sayMessage(&quot;Google&quot;);
    &#125;
     
    interface MathOperation &#123;
       int operation(int a, int b);
    &#125;
     
    interface GreetingService &#123;
       void sayMessage(String message);
    &#125;
     
    private int operate(int a, int b, MathOperation mathOperation)&#123;
       return mathOperation.operation(a, b);
    &#125;
 &#125;
</code></pre>
</li>
</ol>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用通过方法的名字来指向一个方法。</p>
<p>方法引用使用一对冒号 :: 。</p>
<ul>
<li><p>构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new</p>
<ul>
<li>实例如下：<br>final Car car = Car.create( Car::new );<br>final List&lt; Car &gt; cars = Arrays.asList( car );</li>
</ul>
</li>
<li><p>静态方法引用：它的语法是Class::static_method</p>
<ul>
<li>实例如下：<br>cars.forEach( Car::collide );</li>
</ul>
</li>
<li><p>特定类的任意对象的方法引用：它的语法是Class::method</p>
<ul>
<li>实例如下：<br>cars.forEach( Car::repair );</li>
</ul>
</li>
<li><p>特定对象的方法引用：它的语法是instance::method</p>
<ul>
<li><p>实例如下：<br>final Car police = Car.create( Car::new );<br>cars.forEach( police::follow );</p>
<pre><code>  public class Java8Tester &#123;
     public static void main(String args[])&#123;
        List names = new ArrayList();
          
        names.add(&quot;Google&quot;);
        names.add(&quot;Runoob&quot;);
        names.add(&quot;Taobao&quot;);
        names.add(&quot;Baidu&quot;);
        names.add(&quot;Sina&quot;);
          
        names.forEach(System.out::println);
     &#125;
  &#125;
  实例中我们将 System.out::println 方法作为静态方法来引用。
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>
<p>函数式接口可以被隐式转换为 lambda 表达式。</p>
<pre><code>@FunctionalInterface
interface GreetingService 
&#123;
    void sayMessage(String message);
&#125;
</code></pre>
<p>使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：</p>
<pre><code>GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message);
</code></pre>
<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>新增了接口的默认方法。</p>
<p>接口可以有实现方法，不需要实现类去实现其方法。</p>
<p>只需在方法名前面加个 default 关键字即可实现默认方法。</p>
<h4 id="静态默认方法"><a href="#静态默认方法" class="headerlink" title="静态默认方法"></a>静态默认方法</h4><p>Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。</p>
<pre><code>public interface Vehicle &#123;
   default void print()&#123;
      System.out.println(&quot;我是一辆车!&quot;);
   &#125;
    // 静态方法
   static void blowHorn()&#123;
      System.out.println(&quot;按喇叭!!!&quot;);
   &#125;
&#125;
</code></pre>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p>
<p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p>
<h4 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h4><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作。</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
<li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>
</ul>
<h4 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h4><p>在 Java 8 中, 集合接口有两个方法来生成流：</p>
<ul>
<li>stream()  为集合创建串行流。</li>
<li>parallelStream()  为集合创建并行流。</li>
</ul>
<h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><ul>
<li>一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</li>
<li>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。 </li>
<li>Optional 类的引入很好的解决空指针异常。</li>
</ul>
<h3 id="日期时间API"><a href="#日期时间API" class="headerlink" title="日期时间API"></a>日期时间API</h3><p>通过发布新的Date-Time API  加强对日期与时间的处理。 </p>
<p>旧版日期时间API问题：</p>
<ul>
<li>非线程安全：java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</li>
<li>设计很差：Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字。</li>
<li>时区处理麻烦：日期类并不提供国际化，没有时区支持。</li>
</ul>
<p>Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：</p>
<ul>
<li>Local(本地) − 简化了日期时间的处理，没有时区的问题。</li>
<li>Zoned(时区) − 通过制定的时区处理日期时间。</li>
</ul>
<h4 id="本地化日期时间API"><a href="#本地化日期时间API" class="headerlink" title="本地化日期时间API"></a>本地化日期时间API</h4><p>LocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况。</p>
<h4 id="时区的时间日期API"><a href="#时区的时间日期API" class="headerlink" title="时区的时间日期API"></a>时区的时间日期API</h4><p>需要考虑到时区，就可以使用时区的日期时间API。</p>
<pre><code>public void testZonedDateTime()&#123;
    
  // 获取当前时间日期
  ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);
  System.out.println(&quot;date1: &quot; + date1);
    
  ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);
  System.out.println(&quot;ZoneId: &quot; + id);
    
  ZoneId currentZone = ZoneId.systemDefault();
  System.out.println(&quot;当期时区: &quot; + currentZone);
</code></pre>
<p>   }</p>
<h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>在Java 8中，Base64编码已经成为Java类库的标准。</p>
<p>Java 8 内置了 Base64 编码的编码器和解码器。</p>
<p>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p>
<ul>
<li>基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。</li>
<li>URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。</li>
<li>MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。</li>
</ul>
<h4 id="内嵌类"><a href="#内嵌类" class="headerlink" title="内嵌类"></a>内嵌类</h4><ol>
<li>static class Base64.Decoder  该类实现一个解码器用于，使用 Base64 编码来解码字节数据。</li>
<li>static class Base64.Encoder  该类实现一个编码器，使用 Base64 编码来编码字节数据。</li>
</ol>
<p>有多个get方法使用。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2020/09/12/java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="实现多线程"><a href="#实现多线程" class="headerlink" title="实现多线程"></a>实现多线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>正在运行的程序。  </p>
<ul>
<li>系统进行资源分配和调用的独立单位。</li>
<li>有自己的内存空间和系统资源。</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>进程中的单个顺序控制流，是一条执行路径。</p>
<ul>
<li>单线程：一个进程只有一条执行路径，成为单线程程序。</li>
<li>多线程：一个进程有多条执行路径，成为多线程程序。</li>
</ul>
<p>举例：</p>
<ul>
<li>单线程：记事本设置没有完成，不能使用编辑文本。</li>
<li>多线程：扫雷程序，时间在运行，同时可以游玩。</li>
</ul>
<h3 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h3><p>两种方法。</p>
<h4 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h4><pre><code>* 定义一个类MyThread继承Thread类
* 在MyThread类中重写run()方法
* 创建MyThread类对象
* 启动线程
</code></pre>
<h6 id="Thread方法"><a href="#Thread方法" class="headerlink" title="Thread方法"></a>Thread方法</h6><ol>
<li>public void start()</li>
<li>public void run()</li>
<li>public final void setName(String name)</li>
<li>public final void setPriority(int priority)</li>
<li>public final void setDaemon(boolean on)</li>
<li>public final void join(long millisec)  等待该线程终止的时间最长为 millis 毫秒。</li>
<li>public void interrupt()   中断线程。</li>
<li>public final boolean isAlive()</li>
</ol>
<p>静态方法</p>
<ol>
<li>public static void yield()  暂停当前正在执行的线程对象，并执行其他线程。</li>
<li>public static void sleep(long millisec)</li>
<li>public static Thread currentThread()  返回对当前正在执行的线程对象的引用。</li>
</ol>
<h4 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h4><pre><code>* 定义一个类MyRunnable实现Runnable接口。
* 重写run()方法。
* 创建MyRunnable类对象。
* 创建Thread类的对象，把MyRunnable对象作为构造方法的参数。
* 启动线程。
</code></pre>
<h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><ul>
<li>为什么要重写run()方法？<ul>
<li>应为run()用来封装被线程执行的代码。</li>
</ul>
</li>
<li>run()方法和start()方法的区别？<ul>
<li>run()：封装线程执行的代码，直接调用，相当于普通方法的调用。</li>
<li>start()：启动线程，然后由JVM调用此线程的run()方法。</li>
</ul>
</li>
<li>实现Runnable接口的好处：<ul>
<li>避免了Java单继承的局限性，可以继承想要的父类。</li>
<li>适合多个相同的程序代码去处理同一个资源，把线程和程序代码、数据有效分离，较好的体现了面向对象的设计思想。</li>
</ul>
</li>
</ul>
<h5 id="设置和获取线程名称"><a href="#设置和获取线程名称" class="headerlink" title="设置和获取线程名称"></a>设置和获取线程名称</h5><p>Thread类中设置和获取线程名称的方法：</p>
<ul>
<li>void setName(String name)：将此线程的名称更改为参数name。</li>
<li>String getName()：返回此线程的名称。</li>
<li>通过构造方法可以设置线程名称。</li>
</ul>
<p>如何获取main()方法所在的线程名称？</p>
<ul>
<li>public static Thread currentThread()：返回对当前正在执行的线程对象的引用</li>
</ul>
<h4 id="3-Callable和Future创建线程"><a href="#3-Callable和Future创建线程" class="headerlink" title="3. Callable和Future创建线程"></a>3. Callable和Future创建线程</h4><pre><code>1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。
2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。
</code></pre>
<h3 id="创建线程的三种方式对比"><a href="#创建线程的三种方式对比" class="headerlink" title="创建线程的三种方式对比"></a>创建线程的三种方式对比</h3><ol>
<li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
<li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li>
</ol>
<h5 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h5><p>线程有两种调度模型  </p>
<ul>
<li>分时调度模型：</li>
<li>抢占式调度模型：</li>
</ul>
<p>Java使用的是抢占式调度模型</p>
<p>Thread类中设置和获取线程优先级的方法（默认线程优先级都为5）</p>
<ul>
<li>public final int getPriority()：返回此线程的优先级。</li>
<li>public findl void setPriority(int newPriority)：更改此线程的优先级。  </li>
</ul>
<p>注意事项：</p>
<ul>
<li>线程优先级是有范围的（MAX_PRIORITY=10,MIN_PRIORITY=1,NORM_PRIORITY=5）</li>
<li>线程优先级高，仅仅是获取CPU时间片的几率高。</li>
</ul>
<h5 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h5><ul>
<li>static void sleep(long mmillis)：是当前正在执行的线程停留（暂停执行）指定的毫秒数。</li>
<li>void join()：等待这个线程死亡，join()之后的线程才能执行</li>
<li>void setDaemon(Boolean on)：此线程标记为守护线程，当运行的线程都是守护线程是，Java虚拟机退出。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>主线程运行完，守护线程不会立即消失，所以JVM不会立即停止运行。</li>
<li>join()之后的线程，只有join()对应的线程运行完才会执行。</li>
</ul>
<h5 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h5><p><img src="https://i.loli.net/2020/09/21/hXj6CeZJkxdfHu4.png" alt="Java集合框架图.PNG"></p>
<ol>
<li>新建：创建线程对象。</li>
<li>就绪（仅有执行资格）：start()；其他线程抢走CPU的执行权；sleep()方法时间到/阻塞方式结束。</li>
<li>运行：抢到CPU的执行权。</li>
<li>死亡：run()结束；stop()。</li>
<li>阻塞：sleep()/其他阻塞式方法。</li>
</ol>
<h2 id="线程的几个主要概念"><a href="#线程的几个主要概念" class="headerlink" title="线程的几个主要概念"></a>线程的几个主要概念</h2><p>在多线程编程时，你需要了解以下几个概念：</p>
<ul>
<li>线程同步</li>
<li>线程间通信</li>
<li>线程死锁</li>
<li>线程控制：挂起、停止和恢复</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>equals 与 == 的区别</title>
    <url>/2020/07/29/java/equals%20%E4%B8%8E%20==/</url>
    <content><![CDATA[<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>equals方法对于字符串来说是比较内容的，对于非字符串来说是比较 其指向的对象是否相同。  </li>
<li>== 比较的 其指向的对象是否相同，也就是对象在内存中的首地址。（Java中对象的首地址是 它的内存中存放的起始地址，后面的地址是用来存放他所包含的各个属性的地址，内存中会用多个内存块来存放对象的各个参数，而通过这个首地址就可以找到该对象，进而可以找到该对象的各个属性。）<br>String类中重新定义了equals方法，比较的是值。  </li>
<li>如果比较基本类型，只能用 == 比较，不能用equals  </li>
<li>对于基本类型的包装类型， == 比较地址，equals比较内容。<br>（Object类中的equals方法使用来比较地址的，其他对象需要重写equals方法。）</li>
</ol>
<h3 id="如何重写对象的equals方法和hashCode方法"><a href="#如何重写对象的equals方法和hashCode方法" class="headerlink" title="如何重写对象的equals方法和hashCode方法"></a>如何重写对象的equals方法和hashCode方法</h3><h4 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a>1. 需求</h4><p>对比两个对象是否相等对比下面的User对象，只需姓名和年龄相等则认为是同一个对象</p>
<h4 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h4><p>需要重写对象的 equals 方法和 hashCode 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户实体</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yule</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/6 21:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String id, String name, String age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(String age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//地址相等</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//非空性：对于任意非空引用x，x.equals(null)应该返回false。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">other</span> <span class="operator">=</span> (User) obj;</span><br><span class="line">            <span class="comment">//需要比较的字段相等，则这两个对象相等</span></span><br><span class="line">            <span class="keyword">if</span>(equalsStr(<span class="built_in">this</span>.name, other.name)</span><br><span class="line">                    &amp;&amp; equalsStr(<span class="built_in">this</span>.age, other.age))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">equalsStr</span><span class="params">(String str1, String str2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(str1) &amp;&amp; StringUtils.isEmpty(str2))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(str1) &amp;&amp; str1.equals(str2))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">17</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + (name == <span class="literal">null</span> ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">        result = <span class="number">31</span> * result + (age == <span class="literal">null</span> ? <span class="number">0</span> : age.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><p>Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</p>
<p>正例：”test”.equals(object);</p>
<p>说明：推荐使用 java.util.Objects#equals（JDK7 引入的工具类）。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程基础</title>
    <url>/2020/08/24/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-%E6%9C%AA%E5%AE%8C%E6%88%90/</url>
    <content><![CDATA[<p>ArrayList线程不安全，他的读写方法没有同步策略，会导致脏数据和不可预期的结果。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>读-改-写操作，线程要么全部执行，要么全部不执行。<br>使用Synchronized可以实现线程安全，即实现可见性和同步，但是Synchronized是独占锁，没有获得内部锁的线程会被阻塞掉。  </p>
<h3 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a>原子变量类</h3><p>原子变量类比锁更轻巧，比如AtomicLong代表了一个Long值，并提供了get,set方法，get，set方法语义和volatile相同，因为AtomicLong内部就是使用了volatile修饰的真正的Long变量。另外提供了原子性的自增自减操作。<br>相比使用Synchronized的好处在于原子类操作不会导致线程的挂起和重新调度，内部使用的是cas的非阻塞算法。<br>常用的原子类为：AtomicLong,AtomicInteger,AtomicBoolean,AtomicReference。  </p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS（CompareAndSet） 比较并设置。<br>CAS有三个操作数：内存位置，旧的预期值，新的值。<br>当内存位置的变量值为旧的预期值时，使用新的值替换旧的值，否则返回旧的值。这个处理器提供的一个原子性指令。  </p>
<pre><code>for (;;) &#123;
    long current = get();（1）
    long next = current + 1;（2）
    if (compareAndSet(current, next))（3）
        return next;
&#125;
</code></pre>
<p>这里使用了无限循环使用CAS进行轮询检查，一定程度上浪费了cpu，但是相比锁避免了线程的上下文切换和调度。  </p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>一个线程要获取被其他线程占用的锁时，线程会被阻塞。<br>可重入锁：当线程再次获取他自己已经获取的锁时，不会被阻塞。只要线程获得了该锁，可以无限制次数进入被该锁锁住的代码。 </p>
<p>如果内置锁不是可重入的那么该调用就会导致死锁了，因为线程持有并等待了锁。  </p>
<p>实际上内部锁是可重入锁，例如synchronized关键字管理的方法，可重入锁的原理是在锁内部维护了一个线程标示，标示该锁目前被那个线程占用，关联一个计数器，一开始计数器值为0，说明该锁没有被任何线程占用，当一个线程获取了该锁，计数器会变成1，其他线程在获取该锁时候发现锁的所有者不是自己所以被阻塞，但是当获取该锁的线程再次获取锁时候发现锁拥有者是自己会把计数器值+1， 当释放锁后计数器会-1，当计数器为0时候，锁里面的线程标示重置为null,这时候阻塞的线程会获取被唤醒来获取该锁。  </p>
<h2 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h2><p>synchronized块是Java提供的一种强制性内置锁，执行代码在进入synchronized代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时候会阻塞掉。拿到内部锁的线程会在正常退出同步代码块或者异常抛出后释放内部锁，这时候阻塞掉的线程才能获取内部锁进入同步代码块。  </p>
<p>线程A进入同步块修改变量值后，会在退出同步块前把值刷新到主内存，而线程B在进入同步块前会首先清空本地内存内容，从主内存重新获取变量值，所以实现了可见性。但是要注意一点所有线程使用的是同一个锁。  </p>
<p>注意 Synchronized关键字会引起线程上下文切换和线程调度。  </p>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>Synchronized可以实现同步，但是只有一个线程访问共享变量。正常情况下，对于多个读操作时不需要同步。而大部分情况下读操作次数多于写操作，ReentrantReadWriteLock，可以实现读写分离，多个线程同时进行读取，但是最多一个写线程存在。  </p>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><pre><code>public class ArrayList&lt;E&gt;
&#123;
    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    public E get(int index)&#123;
        Lock readLock = readWriteLock.readLock();
        readLock.lock();
        try&#123;
            return list.get(index);
        &#125;finally&#123;
            readLock.unlock();
        &#125;
    &#125;
    public E set(int index, E element)&#123;
        Lock wirteLock = readWriteLock.writeLock();
        wirteLock.lock();
        try&#123;
            return list.set(index, element);
        &#125;finally&#123;
            wirteLock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p>get方法readWriteLock.readLock()获取读锁，多个线程可获得。<br>set方法readwriteLock.writeLock()获取写锁，一个线程可获得，其他线程会被阻塞。<br>一个线程获得了读锁，要获得写锁需要等待释放读锁<br>一个线程获得了写锁，要获取读锁需要等待释放写锁<br>相比Synchronized来说运行多个读者同时存在，提高了并发量。<br>** 注意：需要显示调用Lock与unlock操作。** </p>
<h2 id="Volatile变量"><a href="#Volatile变量" class="headerlink" title="Volatile变量"></a>Volatile变量</h2><p>注意 volatile关键字不会引起线程上下文切换和线程调度。另外volatile还用来解决重排序问题。  </p>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>指数据被外界修改持保守态度(悲观)，在数据处理过程中，数据处于锁定状态。悲观锁的实现依靠数据库的锁机制。<br>数据库中实现对数据记录操作前，先给记录加排它锁，如果获取锁失败，则说明数据正在被其他线程修改，则等待或者抛出异常。如果加锁成功，则获取记录，对其修改，然后事务提交后释放排它锁。<br>一个例子：select * from 表 where .. for update;</p>
<p>悲观锁是先加锁再访问策略，处理加锁会让数据库产生额外的开销，还有增加产生死锁的机会，另外在多个线程只读情况下不会产生数据不一致行问题，没必要使用锁，只会增加系统负载，降低并发性，因为当一个事务锁定了该条记录，其他读该记录的事务只能等待。</p>
<h4 id="悲观锁详细操作"><a href="#悲观锁详细操作" class="headerlink" title="悲观锁详细操作"></a>悲观锁详细操作</h4><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁是相对悲观锁来说的，它认为数据一般情况下不会造成冲突，所以在访问记录前不会加排他锁，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，具体说根据update返回的行数让用户决定如何去做。乐观锁并不会使用数据库提供的锁机制，一般在表添加version字段或者使用业务状态来做。  </p>
<p>乐观锁直到提交的时候才去锁定，所以不会产生任何锁和死锁。  </p>
<h4 id="乐观锁详细操作"><a href="#乐观锁详细操作" class="headerlink" title="乐观锁详细操作"></a>乐观锁详细操作</h4><h2 id="独占锁与共享锁"><a href="#独占锁与共享锁" class="headerlink" title="独占锁与共享锁"></a>独占锁与共享锁</h2><p>根据锁能够被单个线程还是多个线程共同持有，锁又分为独占锁和共享锁。<br>独占锁保证任何时候都只有一个线程能读写权限，ReentrantLock就是以独占方式实现的互斥锁。<br>共享锁则可以同时有多个读线程，但最多只能有一个写线程，读和写是互斥的，例如ReadWriteLock读写锁。  </p>
<p>独占锁是一种悲观锁，每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据一致性，而独占锁只允许同时一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。</p>
<p>共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。  </p>
<h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>根据线程获取锁的抢占机制锁可以分为公平锁和非公平锁。<br>公平锁表示线程获取锁的顺序是按照线程加锁的时间多少来决定的，也就是最早加锁的线程将最早获取锁，也就是先来先得的FIFO顺序。而非公平锁则运行闯入，也就是先来不一定先得。  </p>
<p>ReentrantLock提供了公平和非公平锁的实现：<br>公平锁ReentrantLock pairLock = new ReentrantLock(true);<br>非公平锁 Reen trantLock pairLock = new ReentrantLock(false);<br>如果构造函数不传递参数，则默认是非公平锁。<br>在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销。  </p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（策略与单例）</title>
    <url>/2020/09/17/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="为什么需要设计模式"><a href="#为什么需要设计模式" class="headerlink" title="为什么需要设计模式"></a>为什么需要设计模式</h2><p>设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。</p>
<p>新增功能（可扩展性），维护（可读性，规范性）项目变得容易<br>程序可靠，代码可重用。 </p>
<h2 id="为什么学习设计模式"><a href="#为什么学习设计模式" class="headerlink" title="为什么学习设计模式"></a>为什么学习设计模式</h2><p>如今程序员门槛越来越高。</p>
<p>在实际模式中使用过什么设计模式，怎样使用的，解决了什么问题。</p>
<h2 id="设计模式在软件的哪里"><a href="#设计模式在软件的哪里" class="headerlink" title="设计模式在软件的哪里"></a>设计模式在软件的哪里</h2><p>面向对象（OO）=&gt; 功能模块[设计模式+算法（数据结构）] =&gt; 框架[使用到多种设计模式] =&gt; 架构[服务器集群]</p>
<p>项目的某个功能用到设计模式，</p>
<h2 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h2><p>应用场景 -&gt; 设计模式 -&gt; 刨析原理 -&gt; 分析实现步骤步骤（图解） -&gt; 代码实现（对比） -&gt; 框架或项目源码分析（找到使用的地方）</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><ol>
<li><strong>代码重用性</strong>（相同功能的代码，不用多次编写）</li>
<li><strong>可读性高</strong>（编程规范性）</li>
<li><strong>可扩展性</strong>（增加新功能时，非常的方便）</li>
<li><strong>可靠性</strong>（增加功能，对原功能没有影响）</li>
<li><strong>程序高内聚，低耦合</strong>（AB模块的依赖性低）</li>
</ol>
<h3 id="金句"><a href="#金句" class="headerlink" title="金句"></a>金句</h3><p>懂了设计模式：就懂了面向对象分析和设计（OOA/D）的精要</p>
<h2 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h2><ol>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转原则</li>
<li>里氏替换原则</li>
<li>开闭原则</li>
<li>迪米特法则（最少知道原则）</li>
<li>复用合成原则</li>
</ol>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类应该只负责<strong>一项职责</strong>。如果负责两个不同的职责，职责1需求变更改变类时，可能造成职责2执行错误。</p>
<p>在类或方法上遵守单一职责原则。</p>
<h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol>
<li>降低类的复杂度</li>
<li>提高类的可读性，可维护性</li>
<li>降低变更的风险</li>
<li>通常应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法足够少，才可以在方法级别保持单一职责原则。</li>
</ol>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖建立在最小的接口上。</p>
<p>改进：将接口Interface1 <strong>拆分成为独立的几个接口</strong>，类与他们需要的接口建立依赖关系，也就是采用接口隔离原则。</p>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><ol>
<li>高层模块不应该依赖底层模块，都应该依赖其抽象。</li>
<li>抽象不因该依赖细节，细节应该依赖抽象。</li>
<li>依赖倒转（倒置）的中心思想时<strong>面向接口编程</strong>。</li>
<li><strong>设计理念：相对于细节（实现类）的多变性，抽象（接口或抽象类）的东西要稳定的多</strong>。</li>
<li>使用接口或抽象类的目的是<strong>指定好规范</strong>，不涉及任何具体操作，把展现细节的任务交给实现类去完成。</li>
</ol>
<h4 id="注意事项与细节"><a href="#注意事项与细节" class="headerlink" title="注意事项与细节"></a>注意事项与细节</h4><ol>
<li>底层模块尽量要有抽象类或接口，或者两者都有，程序稳定性更好。</li>
<li>变量的声明类型尽量都是抽象类或接口，这样变量引用和实际对象间，存在一个缓冲层，利于程序扩展和优化。</li>
<li>继承时遵循里氏替换原则。</li>
</ol>
<h4 id="依赖关系传递的三种方式"><a href="#依赖关系传递的三种方式" class="headerlink" title="依赖关系传递的三种方式"></a>依赖关系传递的三种方式</h4><ol>
<li>接口传递：方法参数声明类型尽量都是抽象类或接口，实现类实现方法。</li>
<li>构造方法传递：（创建一个接口成员）构造器给接口声明类型传递对象。</li>
<li>setter方法传递：（创建一个接口成员）setter给接口声明类型传递对象。</li>
</ol>
<h4 id="应用实例分析"><a href="#应用实例分析" class="headerlink" title="应用实例分析"></a>应用实例分析</h4><ol>
<li>如果我们获取的对象是微信，短信等等，则新增类，同时Perons也要增加相应的接受方法</li>
<li>解决思路，引入一个抽象的接口IReceiver，表示接收者，这样Person类与接口发送，因为Email，WeiXin 等等属于接受的范围，他们各自实现IReceiver接口就ok，这样我们就符合依赖倒转原则。</li>
</ol>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><h4 id="继承的弊端"><a href="#继承的弊端" class="headerlink" title="继承的弊端"></a>继承的弊端</h4><ol>
<li>父类中已经实现好的方法，是在设定规范和契约，如果子类对这些方法任意修改，可能会对整个继承体系造成破环。</li>
<li>继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，父类修改，必须考虑到所有的子类。</li>
</ol>
<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</p>
<p>继承实际上让两个类耦合性增强，在适当的情况下，可以通过<strong>聚合，组合，依赖</strong>来解决问题。</p>
<pre><code>如果父类A 子类B B 继承自 A
如果要修改父类A中的方法
让A类 与 B类 都继承刚高级的 C类。在C类中创建新方法
</code></pre>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>编程中最基础，最重要的设计原则</p>
<p>扩展开放，修改关闭。</p>
<p><strong>当软件需要变化时，扩展软件实体的行为来变化。而不是通过修改已有的代码。</strong></p>
<p>编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>别名：直接朋友原则，最少知道原则</p>
<p>一个类<strong>对自己依赖的类知道的越少越好</strong>，被依赖的类不管多麽复杂，都尽量将逻辑封装在类的内部，对外除了提供public方法，不对外泄露任何信息。</p>
<p><strong>直接朋友</strong>：每个对象都会与其他对象有耦合关系即为朋友关系。耦合的方式有很多，依赖，关联，组合，聚合等。我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，出现在局部变量中的类不是直接朋友，不是直接朋友最好不要以局部变量的形式出现在类的内部。</p>
<p><strong>不要再其他类中的方法中使用自己的类构造的对象，可以在自己类中设计出这个方法。</strong></p>
<h4 id="注意事项和细节-1"><a href="#注意事项和细节-1" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol>
<li>核心：降低类之间的耦合。</li>
<li>每个类都减少了不必要的依赖。（必要的依赖为直接的朋友）</li>
</ol>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>尽量使用合成/聚合的方式，而不是使用继承。</p>
<p>依赖（类似合成）：B类中方法使用A类作为参数。<br>组合：B类成员变量直接newA类<br>聚合：B类成员变量setA类</p>
<h2 id="设计原则的核心思想"><a href="#设计原则的核心思想" class="headerlink" title="设计原则的核心思想"></a>设计原则的核心思想</h2><ol>
<li>找出应用中可能需要变化之处独立出来。</li>
<li>针对接口编程。</li>
<li>为了交互对象之间的松耦合设计而努力。</li>
</ol>
<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li>UML–unified modeling language(统一建模语言)是一种用于软件系统分析和设计的语言工具。</li>
<li>UML本身是一套符号的规定，用于描述软件模型中的各个元素和他们之间的关系，比如类，接口，实现，泛化，依赖，组合，聚合等。</li>
</ol>
<p><img src="https://i.loli.net/2020/09/27/mpQvHI34kNJ9q7X.jpg" alt="UML类图的符号意义.jpg"> </p>
<h3 id="UML图分类"><a href="#UML图分类" class="headerlink" title="UML图分类"></a>UML图分类</h3><ol>
<li>用例图</li>
<li>静态结构图：类图，对象图，包图，组件图，部署图</li>
<li>动态行为图：交互图（时序图与协作图），状态图，活动图</li>
</ol>
<h2 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h2><ol>
<li>用于描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系。</li>
<li>类之间的关系：依赖，泛化（继承），实现，关联，聚合与组合</li>
</ol>
<h3 id="依赖关系-Dependence"><a href="#依赖关系-Dependence" class="headerlink" title="依赖关系(Dependence)"></a>依赖关系(Dependence)</h3><ol>
<li>类中用到了对方，就存在依赖关系。</li>
<li>可以是类的成员属性</li>
<li>可以是方法的返回类型</li>
<li>可以是方法接收的参数类型</li>
<li>方法中使用到</li>
</ol>
<h3 id="泛化关系（Generalization）"><a href="#泛化关系（Generalization）" class="headerlink" title="泛化关系（Generalization）"></a>泛化关系（Generalization）</h3><p>其实就是继承关系，是依赖关系的特例。</p>
<h3 id="实现关系（Implementation，Realization）"><a href="#实现关系（Implementation，Realization）" class="headerlink" title="实现关系（Implementation，Realization）"></a>实现关系（Implementation，Realization）</h3><p>A类实现B类，是依赖关系的特例。</p>
<h3 id="关联关系（Association）"><a href="#关联关系（Association）" class="headerlink" title="关联关系（Association）"></a>关联关系（Association）</h3><p>是类与类之间的联系，是依赖关系的特例。</p>
<p>关联具有到航性：即双向关系或单项关系</p>
<p>关系具有多重性：1表示有且仅有一个，0…表示0个或多个，“0，1”表示0个多一个，“n…m”表示n到m个都可以，“m…”表示至少m个。</p>
<h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>表示的是整体和部分的关系，整体与部分是可以分开的。是关联关系的特例，具有关联的导航性与多重性。</p>
<p>类似定义成员变量和set方法。</p>
<h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>整体和部分是不可分离的，升级为组合关系。</p>
<p>类似成员变量new对象。</p>
<h1 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的概述"><a href="#设计模式的概述" class="headerlink" title="设计模式的概述"></a>设计模式的概述</h2><p>设计模式分三种类型，共23种设计模式。</p>
<h3 id="掌握设计模式的层次"><a href="#掌握设计模式的层次" class="headerlink" title="掌握设计模式的层次"></a>掌握设计模式的层次</h3><p><img src="https://i.loli.net/2020/09/28/lfCRadB4TONp9bG.jpg" alt="掌握设计模式的层次.jpg"></p>
<h3 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h3><ol>
<li>创建型模式：单例模式，抽象工厂模式，原型模式，建造者模式，工厂模式。</li>
<li>结构型模式：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。</li>
<li>行为型模式：模板方法模式，命令模式，访问者模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式（责任链模式）</li>
</ol>
<h2 id="单例模式-看study-java的面试题部分"><a href="#单例模式-看study-java的面试题部分" class="headerlink" title="单例模式-看study-java的面试题部分"></a>单例模式-看study-java的面试题部分</h2><p>保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。</p>
<h3 id="单例模式有八种方式"><a href="#单例模式有八种方式" class="headerlink" title="单例模式有八种方式"></a>单例模式有八种方式</h3><ol>
<li><strong>饿汉式（静态常量）</strong></li>
<li><strong>饿汉式（静态代码块）</strong></li>
<li>懒汉式（线程不安全）</li>
<li>懒汉式（线程安全，同步方法）</li>
<li>懒汉式（线程安全，同步代码块）</li>
<li><strong>双重检查</strong></li>
<li><strong>静态内部类</strong></li>
<li><strong>枚举</strong></li>
</ol>
<h3 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>构造器私有化（防止new）</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/lwTHAduB6DvfpZK.jpg" alt="饿汉式-静态变量.jpg"></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>优点：写法简单，在类装载是完成实例化。避免了线程公布问题</li>
<li>缺点：在类装载时完成实例化，没有达到懒加载（Lazy Loading）的效果。如果从始至终从未使用过实例，会造成内存的浪费。</li>
<li>结论：可用，但是可能会造成内存浪费。</li>
</ol>
<h3 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h3><ol>
<li>构造器私有化（防止new）</li>
<li>类的内部创建对象变量</li>
<li>在静态代码块中，实例化对象</li>
<li>向外暴露一个静态的公共方法</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/28DIqLhlwWSpyEe.jpg" alt="饿汉式-静态代码块.jpg"></p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>与上面方式类似，只不过将类的实例化放在静态代码块中，也是在类装载时执行静态代码块中的代码，初始化类的实例。优缺点与上面相同。</li>
<li>结论：可用，但是可能内存浪费。</li>
</ol>
<h3 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h3><ol>
<li>构造器私有化</li>
<li>本类内部创建变量</li>
<li>共有的静态方法，当使用到该方法时，才去创建instance，返回实例对象</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/swJWAPpTCrdvgbz.jpg" alt="懒汉式-线程不安全.jpg"></p>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>起到了Lazy Loading的效果，但是只能在单线程下使用。</li>
<li>结论：在实际开发中，不要使用这种方式。</li>
</ol>
<h3 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h3><ol>
<li>构造私有化</li>
<li>本类内部创建变量</li>
<li>共有的静态方法，加入同步处理的代码，当使用到该方法时，才去创建instance，返回实例对象</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/Zhz2mljsDw1iRCJ.jpg" alt="懒汉式-线程安全同步方法.jpg"></p>
<h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>解决了线程不安全问题</li>
<li>效率太低，每次执行getInstance()方法都要同步。</li>
<li>结论：在实际开发中，不推荐使用这种方式。</li>
</ol>
<h3 id="懒汉式（线程安全，同步代码块）"><a href="#懒汉式（线程安全，同步代码块）" class="headerlink" title="懒汉式（线程安全，同步代码块）"></a>懒汉式（线程安全，同步代码块）</h3><ol>
<li>构造私有化</li>
<li>本类内部创建变量</li>
<li>共有的静态方法，加入同步处理的代码块，当使用到该方法时，才去创建instance，返回实例对象</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/qxPXbRVd4sa9kDG.jpg" alt="懒汉式-同步代码块.jpg"></p>
<h4 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>这种同步比更不能起到线程同步的作用。假如一个线程进入了if判断语句块，另一个线程通过了这个判断语句，便会产生多个实例。</li>
<li>结论：在实际开发中，不能使用这种方式。</li>
</ol>
<h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><ol>
<li>构造私有化</li>
<li>本类内部创建变量，使用volatile修饰，有修改直接到主存里面</li>
<li>共有的静态方法，双重检查，解决线程安全，同时解决懒加载。</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/f3aWYZM5xbEV1go.jpg" alt="双重检查.jpg"></p>
<p>使用volatile修饰成员变量。</p>
<h4 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>Double-Check概念是多线程开发中常使用到的。可以保证线程安全。</li>
<li>线程安全，延迟加载，效率较高。</li>
<li>结论：在实际开发中，推荐使用这种单例设计模式。</li>
</ol>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><ol>
<li>构造私有化</li>
<li>静态内部类，一个静态属性Singleton</li>
<li>静态共有方法直接返回SingletonInstance.INSTANCE。</li>
</ol>
<p><img src="https://i.loli.net/2020/09/28/CVc3qFDhETH9pO1.jpg" alt="单例-静态内部类.jpg"></p>
<p>类装载的时候，内部类不会被装载。只有调用内部类的时候才会装载一次。</p>
<h4 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>采用类装载机制保证初始化实例时只有一个线程。</li>
<li>类的静态属性只会在第一次加载类的时候初始化，JVM保证线程安全。</li>
<li>优点：线程安全，利用静态内部类实现延迟加载，效率高。</li>
<li>结论：推荐使用。</li>
</ol>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="https://i.loli.net/2020/09/28/leuQHjMXGkDYF2A.jpg" alt="单例-枚举.jpg"></p>
<h4 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h4><ol>
<li>借助JDK1.5中添加的枚举来实现单例模式，避免多线程同步，还能防止反序列化才重新创建新的对象。</li>
<li>结论：推荐使用。</li>
</ol>
<h3 id="单例模式注意事项"><a href="#单例模式注意事项" class="headerlink" title="单例模式注意事项"></a>单例模式注意事项</h3><ol>
<li>单例模式保证了系统内存中，该类只存在一个对象。对于一些频繁创建销毁的对象，单例模式可以提高系统性能。</li>
<li>实例化单例类时，要使用相应的获取对象的方法。</li>
<li>单例模式使用场景：频繁的进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多（重量级对象），但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）</li>
</ol>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>定义一个创建对象的类，来封装实例化对象的行为。</p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式：将可变的部分从程序中抽象出来分离成算法接口，在该接口下分别封装一系列算法实现。</p>
<p><img src="https://i.loli.net/2020/09/17/N4b3qvGBMWDZoLu.jpg" alt="策略模式.jpg"></p>
<h3 id="设计策略模式："><a href="#设计策略模式：" class="headerlink" title="设计策略模式："></a>设计策略模式：</h3><p>Hero抽象类：</p>
<pre><code>public abstract class Hero &#123;
    //英雄的名称
    private String heroName;
    //英雄的召唤师技能的接口（组合关系,需要使用时，需要传入一个具体的技能对象）
    private ISkill iSkill;

    //自我介绍的方法
    public abstract void display();
    //普通攻击的方法
    public abstract void normalAttack();
    //召唤师技能的使用方法
    public void skill()&#123;
        iSkill.useSkill();
    &#125;
</code></pre>
<p>HouYi实现类：</p>
<pre><code>public class HouYi extends Hero&#123;
    //编写构造方法
    public HouYi() &#123;
        super.setHeroName(&quot;后羿&quot;);
    &#125;
</code></pre>
<p>ISkill接口：</p>
<pre><code>public interface ISkill &#123;
    //使用召唤师技能的方法
    public abstract void useSkill();
&#125;
</code></pre>
<p>JiPao接口实现类：</p>
<pre><code>public class JiPao implements ISkill &#123;
    @Override
    public void useSkill() &#123;
        System.out.println(&quot;疾跑技能。增加移速。&quot;);
    &#125;
&#125;
</code></pre>
<p>调用：</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol>
<li>找出需要变化的部分，独立出来做成算法接口。</li>
<li>面向接口编程，而不是面向实现。</li>
<li>多用组合，少用继承。</li>
</ol>
<p>优点：</p>
<ol>
<li><strong>使用组合</strong>，而不单单继承，使得架构更加灵活。</li>
<li>富有弹性，<strong>可以较好的应对未来的变化</strong>。（开-闭原则）</li>
<li>更好的代码复用性。（相对于继承）</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加了对象的数量（每个接口都做成一个对象）。</li>
</ol>
<p>​    </p>
]]></content>
  </entry>
  <entry>
    <title>《Java编程思想》知识点总结</title>
    <url>/2021/05/31/%E4%B9%A6%E7%B1%8D/20210531-%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="第9章-接口"><a href="#第9章-接口" class="headerlink" title="第9章 接口"></a>第9章 接口</h2><h3 id="9-4-Java中的多重继承"><a href="#9-4-Java中的多重继承" class="headerlink" title="9.4 Java中的多重继承"></a>9.4 Java中的多重继承</h3><h4 id="使用接口的核心原因："><a href="#使用接口的核心原因：" class="headerlink" title="使用接口的核心原因："></a>使用接口的核心原因：</h4><ol>
<li>提高灵活性：能够向上转型为多个基类型。</li>
<li>与抽象基类相同：防止客户程序员创建该类，确保这仅仅是一个接口。</li>
</ol>
<h3 id="9-5-通过继承来扩展接口"><a href="#9-5-通过继承来扩展接口" class="headerlink" title="9.5 通过继承来扩展接口"></a>9.5 通过继承来扩展接口</h3><p>在打算组合的不同接口中，使用相同的方法名，通常会造成代码可读性的混乱。并且重载方法仅通过返回类型是无法区分并且会报错的。</p>
<h3 id="9-6-适配接口"><a href="#9-6-适配接口" class="headerlink" title="9.6 适配接口"></a>9.6 适配接口</h3><p>让方法接受接口类型，是一种让任何类都可以对该方法进行适配的方法。这就是使用接口而不是使用类的强大之处。（可以使用适配器模式）</p>
<h3 id="9-7-接口中的域"><a href="#9-7-接口中的域" class="headerlink" title="9.7 接口中的域"></a>9.7 接口中的域</h3><p>接口中的任何域都是static和final的，自动public的。会在类第一次加载时进行初始化。</p>
<h3 id="9-8-嵌套接口"><a href="#9-8-嵌套接口" class="headerlink" title="9.8 嵌套接口"></a>9.8 嵌套接口</h3><p>接口可以被实现为private的。实现private接口，不允许向上转型。它不可以用作返回值类型，将返回值交给有权使用它的对象。</p>
<h3 id="9-9-接口与工厂"><a href="#9-9-接口与工厂" class="headerlink" title="9.9 接口与工厂"></a>9.9 接口与工厂</h3><p>接口是实现多重继承的途径。生成遵循某个接口的对象的典型方式：工厂方法设计模式。</p>
<p>工厂方法会添加额外级别的间接性。一个创建的原因是想要创建框架。</p>
<h3 id="9-10-总结"><a href="#9-10-总结" class="headerlink" title="9.10 总结"></a>9.10 总结</h3><h4 id="什么时候使用类？抽象类？接口？。"><a href="#什么时候使用类？抽象类？接口？。" class="headerlink" title="什么时候使用类？抽象类？接口？。"></a>什么时候使用类？抽象类？接口？。</h4><p>如果创建不带任何方法定义和成员变量的基类：选择接口。</p>
<p>如果某事物应该称为一个基类，第一选择使它成为接口。</p>
<p>优先选择类而不是接口。从类开始，如果明确接口的必需性，进行重构。</p>
<p>构建一个通用接口，不同的子类用不同的方式表示此接口。可以使用抽象类。（在抽象类中，实现通用方法，不同的方式的方法构造成抽象方法有子类实现）</p>
<h2 id="第10章-内部类"><a href="#第10章-内部类" class="headerlink" title="第10章 内部类"></a>第10章 内部类</h2><h3 id="（普通的）内部类"><a href="#（普通的）内部类" class="headerlink" title="（普通的）内部类"></a>（普通的）内部类</h3><p>如何创建内部类：把类的定义置于外围类的里面。</p>
<p>需要以该方式指明内部类对象的类型：OuterClassName.InnerClassName。</p>
<p>内部类的用处：</p>
<ol>
<li>内部类是一种名字隐藏和组织代码的模式。</li>
<li>内部类有其外部类所有元素的访问权。</li>
</ol>
<p>使用 <code>.this</code> 与 <code>.new</code>？</p>
<p>需要外部类的引用，使用<code>外部类名字.this</code></p>
<p>如何创建普通内部类对象：必须使用外部类对象来创建内部类对象。例如：<code>dn.new Inner()</code>   （在拥有外部类对象之前，不可能创建内部类对象，因为内部类对象会暗暗地连接到创建它的外部类对象上。除了嵌套类(静态内部类)）</p>
<h3 id="在方法和作用域内的内部类"><a href="#在方法和作用域内的内部类" class="headerlink" title="在方法和作用域内的内部类"></a>在方法和作用域内的内部类</h3><p>在定义的作用域之外，它是不可用的；除此之外，它与普通的类一样。</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>何为匿名内部类？</p>
<p>语法表明：创建一个继承自某个类的匿名类的对象。通过new表达式返回的引用被自动向上转型为对那个类的引用。</p>
<p>匿名内部类，使用一个在其外部定义的对象，要求其参数引用是final的。否则编译时错误。</p>
<p>匿名内部类没有命名构造器（没有名字），通过实例初始化，达到为匿名内部类创建一个构造器的效果。</p>
<p>匿名内部类可以扩展类或实现一个接口。</p>
<h3 id="嵌套类（静态内部类）"><a href="#嵌套类（静态内部类）" class="headerlink" title="嵌套类（静态内部类）"></a>嵌套类（静态内部类）</h3><p>如果不需要内部类对象与其外围类之间有联系，可以将内部类声明为static。常称为嵌套类（静态内部类）。</p>
<p>嵌套类可以作为接口的一部分。放在接口中的任何类都自动是public和static的。</p>
<p>如果想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么用接口内部的嵌套类会显得很方便。</p>
<h3 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h3><p>外围类继承接口，并不能总享受到接口的方便，有时需要用到接口的实现。</p>
<p><strong>使用内部类最吸引人的原因是</strong>：<strong>每个内部类都能独立地继承自一个（接口的）实现，对于内部类都没有影响。</strong></p>
<p>（<strong>多重继承</strong>）如果拥有抽象的类或具体的类，而不是接口，只能使用内部类才能实现多重继承。</p>
<p>使用内部类的一些<strong>其他特性</strong>：</p>
<ol>
<li>内部类对象可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。</li>
</ol>
<h4 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h4><p>闭包是一个可调用的对象，记录了一些信息，信息来源于它的作用域。（内部类就是Java的闭包）</p>
<p>回调，类似于指针的机制。在运行时动态的决定调用什么方法。</p>
<h4 id="内部类与控制框架"><a href="#内部类与控制框架" class="headerlink" title="内部类与控制框架"></a>内部类与控制框架</h4><ol>
<li>控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。内部类用来表示解决问题做必须的各种不同的行为。</li>
<li>内部类能够很容易的访问外围类的任意成员。</li>
</ol>
<h3 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h3><p>内部类的构造器必须连接外围类对象的引用。必须在内部类构造器内，需要使用语法 <code>enclosingClassReference.super();</code> 才能提供必要的引用，程序才能编译通过。</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>可以在代码块里创建内部类，可以访问当前代码块内的常量，以及外围类的所有成员。</p>
<p>为何不用匿名内部类？局部内部类可以使用构造器，匿名内部类只能使用实例初始化。</p>
<h2 id="第11章-持有对象"><a href="#第11章-持有对象" class="headerlink" title="第11章 持有对象"></a>第11章 持有对象</h2><h3 id="添加一组元素"><a href="#添加一组元素" class="headerlink" title="添加一组元素"></a>添加一组元素</h3><p>在<code>java.util</code>包中的<code>Arrays和Collections</code>类中都有很多使用方法，可以在Collection中添加一组元素。</p>
<p><code>Arrays.asList()</code> 方法接受一个数组或是一个用逗号分隔的元素列表（使用可变参数）将其转换为一个List对象。</p>
<p><code>Collections.addAll()</code> 方法接受一个Collection对象，以及一个数组或是一个用逗号分隔的元素列表，将元素添加到Collection中。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一个对象，遍历并选择序列中的对象，客户端程序员不必知道或关心该序列底层的结构。（轻量级对象：创建它的代价小）</p>
<h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p>Java的<strong>Iterator</strong>只能单项移动。</p>
<ol>
<li>使用<code>iterator()</code>要求容器返回一个<code>Iterator</code>。Iterator将准备好返回第一个元素。</li>
<li>使用<code>next()</code>获得序列中的下一个元素。</li>
<li>使用<code>hasNext()</code>检查序列中是否还有元素。</li>
<li>使用<code>remove()</code>将迭代器新近元素删除。</li>
</ol>
<h4 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h4><p>ListIterator是一个更强大的Iterator的子类型，它只能用于各种List类的访问。ListIterator可以双向移动。并且可以使用set()方法替换它访问过的最后一个元素。</p>
<ol>
<li>使用<code>provious()</code>获取序列中的前一个元素。</li>
<li>使用<code>hasPrevious()</code>检查序列是否还有前一个元素。</li>
<li>使用<code>set()</code>替换访问过的最后一个元素。</li>
</ol>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList也像ArrayList一样实现了基本的List接口。还添加了可以使其用作栈、队列或双端队列（实现双端队列接口）的方法。</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>栈是指后进先出（LIFO）的容器。有时栈也称为叠加栈。LinkedList具有能够直接实现栈的所有功能方法，因此可以直接将LInkedList作为栈使用。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>保存不重复的元素。</p>
<p>TreeSet将元素存储在红-黑树数据结构中。HashSet使用散列函数。LinkedHashList使用散列和链表。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>将对象与对象相关联的设计。HashMap，TreeMap，LinkedHashMap。</p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>队列是一个先进先出（FIFO）的容器。</p>
<p>在并发编程中特别重要。</p>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>优先级队列。默认的排序将使用对象在队列中的自然顺序。可以通过自己提供的Comparator来修改这个顺序。</p>
<h3 id="Collection和Iterator"><a href="#Collection和Iterator" class="headerlink" title="Collection和Iterator"></a>Collection和Iterator</h3><p>Collection是描述所有序列容器的共性的根接口。</p>
<p>java.util.AbstractCollection类提供了Collection的默认实现，可以创建AbstractCollection的子类型。</p>
<p>java中用迭代器表示容器之间的共性。</p>
<p>继承AbstractCollection只需实现iterator()和size()方法。</p>
<p>创建一个Collection的实现，必须实现所有的Collection方法。</p>
<h3 id="Foreach与迭代器"><a href="#Foreach与迭代器" class="headerlink" title="Foreach与迭代器"></a>Foreach与迭代器</h3><p>创建了任何实现Iterator的类，都可以将它用于foreach语句中。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>新程序中不应该使用过时的Vector、Hashtable和Stack。</p>
<h2 id="第12章-异常处理错误"><a href="#第12章-异常处理错误" class="headerlink" title="第12章 异常处理错误"></a>第12章 异常处理错误</h2><p>当抛出异常后，发生了什么？</p>
<ol>
<li>将使用<strong>new</strong>在堆上创建异常对象。</li>
<li>当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用。</li>
<li>异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。（恰当的地方就是异常处理程序：任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去）</li>
</ol>
<p>终止与恢复</p>
<p>异常处理理论上有两种基本模型。</p>
<ol>
<li>Java支持<strong>终止模型</strong>。一旦异常被抛出，就表明错误已无法挽回，也不能回来继续执行。</li>
<li><strong>恢复模型</strong>。通常希望异常被处理后能继续执行程序。（遇见错误调用方法修正该错误，或者，把try块放在while循环里，直到得到满意的结果）</li>
</ol>
<h4 id="捕获所有异常"><a href="#捕获所有异常" class="headerlink" title="捕获所有异常"></a>捕获所有异常</h4><h5 id="栈轨迹"><a href="#栈轨迹" class="headerlink" title="栈轨迹"></a>栈轨迹</h5><p><code>printStackTrace()</code> 打印<strong>Throwable和Throwable的调用栈</strong>轨迹（由栈轨迹中的元素所构成的数组，栈顶元素时调用序列中的最后一个方法调用，即<strong>Throwable</strong>被创建和抛出之处）。</p>
<h5 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h5><p>捕获异常的时候，表示已经得到了对当前异常对象的引用，可以直接把他重新抛出。printStackTrace()方法显示的是原来异常抛出点的调用栈信息。想要更新这个信息，可以调用<code>fillInStackTrace()</code>方法。（返回一个Throwable对象，通过把当前调用栈信息填入原来那个异常对象而建立的。调用<code>fillInStackTrace()</code>的那一行就成了异常的新发生地了。）</p>
<h5 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h5><p>捕获一个异常后抛出另一个异常，把原始异常的信息保存下来，称为异常链。</p>
<p>把其他类型的异常连接起来使用<code>initCause()</code>方法而不是构造器。</p>
<p>Java标准异常</p>
<ol>
<li>Error用来表示编译时和系统错误。</li>
<li>Execption是可以被抛出的基本类型。</li>
</ol>
<h2 id="第13章字符串"><a href="#第13章字符串" class="headerlink" title="第13章字符串"></a>第13章字符串</h2>]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>优先队列</title>
    <url>/2021/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20210428-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="什么是优先队列"><a href="#什么是优先队列" class="headerlink" title="什么是优先队列"></a>什么是优先队列</h1><p>在数据队列中，数据是有优先权的。优先权高得数据，先从队列中出来。</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>优先队列的数据结构至少有两种操作：insert（插入）和deleteMin（删除最小者）。</p>
<p>等价于enqueu（入队）和dequeue（出队）操作。</p>
<h2 id="简单的实现"><a href="#简单的实现" class="headerlink" title="简单的实现"></a>简单的实现</h2><p>使用基本链表实现：</p>
<ol>
<li>简单链表：在表头已O(1)插入，并遍历链表以O(N)删除最小元。</li>
<li>排序的链表：以O(N)排序插入，以O(1)删除最小元。</li>
</ol>
<p>基于删除不多于插入的实现，实现1比较好。</p>
<p>使用二叉查找树实现：两个操作的平均时间都是O(log N)。不过反复操作可能会毁坏树的平衡，并且过分的是它有支持好多不需要的操作。</p>
<p>下面使用的基本的数据结构实现优先队列，不需要链，以最坏情形时间O(log N)支持两种操作。插入操作将花费常数时间。</p>
<p>在后面的使用链接的结构实现优先队列的合并。</p>
<h1 id="二叉堆（堆）"><a href="#二叉堆（堆）" class="headerlink" title="二叉堆（堆）"></a>二叉堆（堆）</h1><h3 id="堆具有两个性质："><a href="#堆具有两个性质：" class="headerlink" title="堆具有两个性质："></a>堆具有两个性质：</h3><ol>
<li>结构性：堆是一个完全二叉树，一颗被完全填满的二叉树，只有其底层上的元素从左到右填入。<ol>
<li>由于完全二叉树有规律，可以用一个数组表示，不需要使用链。</li>
<li>数组在任一位置i上的元素，左儿子在位置2i上，右儿子在其左儿子的下一个位置（2i+1）上，它的父亲在位置[i/2]上。</li>
<li>堆结构由一个数组和一个记录堆大小的整数 组成。</li>
<li>数组中从下标1处开始存储数据。位置0处存放暂时的可替换数据（用于插入删除操作）。</li>
</ol>
</li>
</ol>
<ol start="2">
<li>堆序性：最小元应该在堆的根上。即数组下标1处。</li>
</ol>
<h3 id="基本的堆操作"><a href="#基本的堆操作" class="headerlink" title="基本的堆操作"></a>基本的堆操作</h3><p>见代码：<a href="https://gitee.com/qi_wave/study_java/blob/37fac214e5307fbaa94a4ad58905c670e59acc9f/java/src/main/java/DataStructures_and_AlgorithmAnalysis_in_Java/z06/BinaryHeap.java">https://gitee.com/qi_wave/study_java/blob/37fac214e5307fbaa94a4ad58905c670e59acc9f/java/src/main/java/DataStructures_and_AlgorithmAnalysis_in_Java/z06/BinaryHeap.java</a></p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>新元素插入堆中，暂时放到数组位置1处，在下一个可用位置创建一个空穴。通过上滤策略（空穴与父节点交换为位置），在堆中知道找到正确的位置。再将输入放到对应的空穴位置。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除根节点（即数组位置1处），出现一个空穴，将数组中末尾的值放到数组位置1处。通过下滤找到，该空穴合适的位置，再把末尾的值放到空穴处。</p>
<h3 id="其他堆操作"><a href="#其他堆操作" class="headerlink" title="其他堆操作"></a>其他堆操作</h3><ol>
<li><p>decreaseKey(降低关键字的值)：decrease(p, ▲)。降低在位置p处的项的值，降低的幅度为▲。</p>
</li>
<li><p>increaseKey(增加关键字的值)</p>
</li>
<li><p>delete(删除)：首先执行降低关键字的值，再执行删除最小元操作。</p>
<p>举例：进程为用户手动终止，必须从优先队列中除去。</p>
</li>
<li><p>buildHeap(构建堆)</p>
</li>
</ol>
<h2 id="d-堆"><a href="#d-堆" class="headerlink" title="d-堆"></a>d-堆</h2><p>d-堆是二叉堆的简单推广。</p>
<p>只是所有的节点都有d个儿子。</p>
<h1 id="可合并的堆"><a href="#可合并的堆" class="headerlink" title="可合并的堆"></a>可合并的堆</h1><p>堆的实现，不能实施find操作，最明显的缺点是：两个堆合成一个堆是困难的。下面介绍三种复杂程度不一的数据结构使得一次merge操作的运行时间是O(log N)。</p>
<h2 id="左式堆"><a href="#左式堆" class="headerlink" title="左式堆"></a>左式堆</h2><p>见代码</p>
<p><a href="https://gitee.com/qi_wave/study_java/blob/37fac214e5307fbaa94a4ad58905c670e59acc9f/java/src/main/java/DataStructures_and_AlgorithmAnalysis_in_Java/z06/LeftistHeap.java">https://gitee.com/qi_wave/study_java/blob/37fac214e5307fbaa94a4ad58905c670e59acc9f/java/src/main/java/DataStructures_and_AlgorithmAnalysis_in_Java/z06/LeftistHeap.java</a></p>
<p>左式堆与二叉堆具有相同的堆序性。不过有自己的结构性。且是非常不平衡的。</p>
<h3 id="零路径长"><a href="#零路径长" class="headerlink" title="零路径长"></a>零路径长</h3><p>任一节点X的零路径长（null path length）np(X) 定义为：从X到一个不具有两个儿子的节点的最短路径的长。</p>
<p>因此，具有0个或1个儿子节点的npl为0。而 npl = -1。</p>
<h3 id="左式堆的性质"><a href="#左式堆的性质" class="headerlink" title="左式堆的性质"></a>左式堆的性质</h3><ol>
<li>满足堆序性</li>
<li>结构性质：左式堆中的每一个节点X，左儿子的零路径长至少与右儿子的零路径长相等。（左npl &gt;= 右npl）</li>
</ol>
<h2 id="斜堆"><a href="#斜堆" class="headerlink" title="斜堆"></a>斜堆</h2><p>斜堆是对左式堆的自调节形式。</p>
<p>斜堆具有堆序性的二叉树，但不存在对树的结构限制。</p>
<h2 id="二项队列"><a href="#二项队列" class="headerlink" title="二项队列"></a>二项队列</h2><p>见代码：<a href="https://gitee.com/qi_wave/study_java/blob/37fac214e5307fbaa94a4ad58905c670e59acc9f/java/src/main/java/DataStructures_and_AlgorithmAnalysis_in_Java/z06/BinomialQueue.java">https://gitee.com/qi_wave/study_java/blob/37fac214e5307fbaa94a4ad58905c670e59acc9f/java/src/main/java/DataStructures_and_AlgorithmAnalysis_in_Java/z06/BinomialQueue.java</a></p>
<p>虽然左式堆和斜堆都在每次操作以O(log N)时间有效值支持合并、插入和删除最小元。但还是有改进的余地。</p>
<p>二项队列均支持这三种操作，每次操作的最坏情形运行时间为O(log N)，而插入操作平均时间花费常数时间。</p>
<h3 id="二项队列的结构"><a href="#二项队列的结构" class="headerlink" title="二项队列的结构"></a>二项队列的结构</h3><p>二项队列与其他优先对立的实现的区别在于：一个二项队列不是一颗堆序的树，而是堆序的树的集合，称为森林（forest）。</p>
<p>每一颗堆序树都有约束的形式叫做二项树。</p>
<h3 id="二项队列的实现"><a href="#二项队列的实现" class="headerlink" title="二项队列的实现"></a>二项队列的实现</h3><p>二项队列是：二项树的数组。（数组存放各个二项树的根）</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构与算法分析</tag>
        <tag>优先队列</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>get和post请求区别</title>
    <url>/2021/04/13/%E7%BD%91%E7%BB%9C/20210413-get%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="get与post区别"><a href="#get与post区别" class="headerlink" title="get与post区别"></a>get与post区别</h3><h4 id="浏览器的get和post"><a href="#浏览器的get和post" class="headerlink" title="浏览器的get和post"></a>浏览器的get和post</h4><p>get反复读取不应该对访问的数据有副作用。没有副作用被称为“幂等”。</p>
<p>get是读取，可对get请求的数据做缓存。缓存可以做到浏览器本身（避免在发送请求），也可以做到代理上（如nginx）。</p>
<p>post请求让服务器做一件事。往往是有副作用的，不幂等的。页面<form>标签会定义一个表单。点击其中的submit元素会发送post请求。</p>
<p>不幂等意味着不能多次执行，不能做缓存。</p>
<p><strong>并不是说get不能有body，posturl不能放querystring。</strong></p>
<h4 id="接口中的get和post"><a href="#接口中的get和post" class="headerlink" title="接口中的get和post"></a>接口中的get和post</h4><p>rest风格只是为了统一可以随意使用的请求方式，规定get参数放在url，post参数放在body中。这样使用，只是为了前后端方便。</p>
<h4 id="关于安全性"><a href="#关于安全性" class="headerlink" title="关于安全性"></a>关于安全性</h4><p>POST用body传输数据，而GET用url传输，更加容易看到。</p>
<p>但从攻击的角度，get和post都不够安全，因为HTTP本身是明文协议。每个http请求和响应的每个byte都会在网络上明文传输，不管是url、header还是body。完全不是一个“是否容易在浏览器地址栏上看到”的问题。</p>
<p>为避免传输中数据被窃取，<strong>必须做从客户端到服务器的端端加密。业界的通行做法就是https</strong>。</p>
<p>如果请求要经过不信任的公网，避免泄密的<strong>唯一手段就是https</strong>。</p>
<h4 id="关于编码"><a href="#关于编码" class="headerlink" title="关于编码"></a>关于编码</h4><p>url只能支持ASCII编码，body能支持任意binary。</p>
<p>所以，rest风格下，get的参数只能支持ASCII编码，post能支持任意binary。</p>
<p>浏览器发出的POST请求就是表单提交，application/x-www-form-urlencoded针对简单的key-value场景；multipart/form-data，针对只有文件提交，或者同时有文件和key-value的混合提交表单的场景。</p>
<h4 id="浏览器的POST需要发两个请求吗？"><a href="#浏览器的POST需要发两个请求吗？" class="headerlink" title="浏览器的POST需要发两个请求吗？"></a>浏览器的POST需要发两个请求吗？</h4><p>比如一个上传文件的服务，请求url中包含了文件名称，请求体中是个尺寸为几百兆的压缩二进制流。服务器端接收到请求后，就可以先拿到请求头部，查看用户是不是有权限上传，文件名是不是符合规范等。如果不符合，就不再处理请求体的数据了，直接丢弃。而不用等到整个请求都处理完了再拒绝。</p>
<p>为了进一步优化，客户端可以利用HTTP的Continued协议来这样做：客户端总是先发送所有请求头给服务器，让服务器校验。如果通过了，服务器回复“100 - Continue”，客户端再把剩下的数据发给服务器。如果请求被拒了，服务器就回复个400之类的错误，这个交互就终止了。这样，就可以避免浪费带宽传请求体。但是代价就是会多一次Round Trip。如果刚好请求体的数据也不多，那么一次性全部发给服务器可能反而更好。</p>
<p>基于此，客户端就能做一些优化，比如内部设定一次POST的数据超过1KB就先只发“请求头”，否则就一次性全发。客户端甚至还可以做一些Adaptive的策略，统计发送成功率，如果成功率很高，就总是全部发等等。不同浏览器，不同的客户端（curl，postman）可以有各自的不同的方案。不管怎样做，优化目的总是在提高数据吞吐和降低带宽浪费上做一个折衷。</p>
<p>因此到底是发一次还是发N次，客户端可以很灵活的决定。因为不管怎么发都是符合HTTP协议的，因此我们应该视为这种优化是一种实现细节，而不用扯到GET和POST本身的区别上。更不要当个什么世纪大发现。</p>
<h4 id="什么算请求体"><a href="#什么算请求体" class="headerlink" title="什么算请求体"></a>什么算请求体</h4><h4 id="关于url的长度"><a href="#关于url的长度" class="headerlink" title="关于url的长度"></a>关于url的长度</h4><p>常说的“GET数据有长度限制“其实是指”URL的长度限制“。</p>
<p>HTTP协议本身对URL长度并没有做任何规定。实际的限制是由客户端/浏览器以及服务器端决定的。</p>
<p>比如我们常说的2048个字符的限制，其实是IE8的限制。并且原始文档的说的其实是“URL的最大长度是2083个字符，path的部分最长是2048个字符“。新的IE已经开始使用Chrome的内核了，也就意味着“浏览器端URL的长度限制为2048字符”这种说法会慢慢成为历史。</p>
<p>其他的客户端，比如Java的，js的http client大多数也并没有限制URL最大有多长。</p>
<p>apache实际上限制的是HTTP请求第一行“Request Line“的长度，即<METHOD><URL> <VERSION>那一行。</p>
<p>Tomcat的限制是web.xml里maxHttpHeaderSize来设置的，控制的是整个“请求头”的总长度。</p>
<h5 id="为啥要限制呢？"><a href="#为啥要限制呢？" class="headerlink" title="为啥要限制呢？"></a>为啥要限制呢？</h5><p>如果写过解析一段字符串的代码就能明白，解析的时候要分配内存。对于一个字节流的解析，必须分配buffer来保存所有要存储的数据。而URL这种东西必须当作一个整体看待，无法一块一块处理，于是就处理一个请求时必须分配一整块足够大的内存。如果URL太长，而并发又很高，就容易挤爆服务器的内存；同时，超长URL的好处并不多，我也只有处理老系统的URL时因为不敢碰原来的逻辑，又得追加更多数据，才会使用超长URL。</p>
<p>对于开发者来说，使用超长的URL完全是给自己埋坑，需要同时要考虑前后端，以及中间代理每一个环节的配置。此外，超长URL会影响搜索引擎的爬虫，有些爬虫甚至无法处理超过2000个字节的URL。这也就意味着这些URL无法被搜到，坑爹啊。</p>
<p>原文地址：<a href="https://www.zhihu.com/question/28586791">https://www.zhihu.com/question/28586791</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>网络</tag>
        <tag>get</tag>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手和四次挥手</title>
    <url>/2021/04/02/%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>建立客户端与服务器的tcp连接。</p>
<ol>
<li>建立连接，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li>
<li>服务器收到syn包，确认客户端的SYN(ack=j+1)，同时也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。</li>
<li>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，词包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手 。</li>
</ol>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>终止客户端与服务器的tcp连接</p>
<ol>
<li>TCP客户端发送一个FIN（带有FIN附加标记的报文段），用来关闭客户到服务器的数据传送。</li>
<li>服务器收到FIN，发挥一个ACK，确认序号为收到序号加1。和SYN一样，一个FIN将占用一个序号。（先发送ACK的目的是为了防止这段时间内，对方重传FIN报文段）</li>
<li>服务器关闭客户端的连接，发送一个FIN给客户端。</li>
<li>客户端发送ACK报文确认，并将确认序号设置为序号加1。</li>
</ol>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>https、公钥、私钥、数字证书</title>
    <url>/2020/12/29/%E7%BD%91%E7%BB%9C/https%E3%80%81%E5%85%AC%E9%92%A5%E3%80%81%E7%A7%81%E9%92%A5%E3%80%81%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h3 id="https通信的完整流程"><a href="#https通信的完整流程" class="headerlink" title="https通信的完整流程"></a>https通信的完整流程</h3><p>浏览器请求服务器，首先发送请求，服务器返回数字证书，数字证书中有3个东西（证书内容、加密密文、加密算法），当证书内容转变为hash值与密文通过CA机构的公钥解密获得的hash值相同时，表明该证书合法，并且从数字证书的证书内容中获得服务器端公钥。由于非对称密钥的加解密耗时，所以客户端会使用自己的对称密钥通过服务器公钥加密后发送给服务器，之后服务器通过自己的私钥进行解密，获得对称密钥，之后服务器和客户端通过对称密钥进行通信</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>两把密匙：公钥和私钥</p>
<p>使用公钥加密时，用私钥解密。</p>
<p>使用私钥加密时，用公钥解密。</p>
<p>私钥：由服务器保留。</p>
<p>公钥：服务器发送给客户端使用 。</p>
]]></content>
      <tags>
        <tag>https</tag>
        <tag>公钥</tag>
        <tag>私钥</tag>
        <tag>数字证书</tag>
      </tags>
  </entry>
  <entry>
    <title>商城项目（二）</title>
    <url>/2020/12/23/%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE2/</url>
    <content><![CDATA[<h1 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h1><p>用到的技术：</p>
<p>VSCode，ES6（ECMAScript6.0，JavaScript语言的下一代版本），Node.js，Vue，Babel，Webpack（自动化项目构建工具）</p>
<h2 id="ES6基础学习"><a href="#ES6基础学习" class="headerlink" title="ES6基础学习"></a>ES6基础学习</h2><ol>
<li>创建新的文件夹</li>
<li>创建let.html</li>
<li>！+ 回车</li>
</ol>
<h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><ol>
<li><p>let</p>
<ol>
<li>var声明的变量会越域；let声明的变量有严格的局部作用域。</li>
<li>var可以声明多次；let只能声明一次。</li>
<li>var会变量提升；let不存在变量提升。</li>
<li>const声明常量</li>
</ol>
</li>
<li><p>解构表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = arr;</span><br><span class="line"><span class="comment">//对象解构</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">name</span>: <span class="string">&quot;jack&quot;</span>, <span class="attr">age</span>: <span class="number">21</span>&#125;</span><br><span class="line"><span class="keyword">const</span>&#123;name, age&#125; = person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">name</span>: <span class="string">&quot;jack&quot;</span>, <span class="attr">age</span>: <span class="number">21</span>&#125;;</span><br><span class="line"><span class="keyword">const</span>&#123;<span class="attr">name</span>:abc, age&#125; = person;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(abc, age);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>字符串扩展</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串新增了一些方法</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>字符串模板</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ss = <span class="string">`</span></span><br><span class="line"><span class="string">	&lt;div&gt;</span></span><br><span class="line"><span class="string">		&lt;span&gt;hello world&lt;span&gt;</span></span><br><span class="line"><span class="string">	&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>字符串可以插入变量、表达式和方法。变量名等写在${}中。</p>
</li>
</ol>
</li>
<li><p>函数优化</p>
<ol>
<li>传默认值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以前的写法</span></span><br><span class="line">b = b || <span class="number">1</span>; <span class="comment">// 判断b是否为空，为空就给默认值1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b = <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>不定参数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(values.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="title function_">fun</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>箭头函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以前声明一个方法</span></span><br><span class="line"><span class="keyword">var</span> print = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在的写法</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">print</span> = obj =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"><span class="title function_">print</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    a + b;</span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">11</span>, <span class="number">12</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义变量</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//箭头函数+解构</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">hello</span> = (<span class="params">&#123;name&#125;</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line"><span class="title function_">hello</span>(person);  <span class="comment">// person中的name属性，解构到入参中的name中</span></span><br></pre></td></tr></table></figure></li>
<li><p>对象优化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 新增Object的方法</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(person)); <span class="comment">// [&quot;name&quot;, &quot;age&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(person)); <span class="comment">// [&quot;jack&quot;, 21]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 声明对象的简写方式</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"><span class="comment">// 以前的写法 对象属性age赋值变量age，对象属性name赋值变量name</span></span><br><span class="line"><span class="keyword">const</span> person1 = &#123;<span class="attr">age</span>: age, <span class="attr">name</span>: name&#125;;</span><br><span class="line"><span class="comment">// 现在的写法 如果对象的属性名与要赋值的变量名相同，就可以简写</span></span><br><span class="line"><span class="keyword">const</span> person2 = &#123;age, name&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对象函数属性简写</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    <span class="comment">//以前对象函数的写法</span></span><br><span class="line">    <span class="attr">eat</span>: <span class="keyword">function</span>(<span class="params">food</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;在吃&quot;</span> + food);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//现在可以使用箭头函数  在箭头函数中this不能使用，不要用 对象.属性</span></span><br><span class="line">    <span class="attr">eat2</span>: <span class="function"><span class="params">food</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span> + <span class="string">&quot;在吃&quot;</span> + food),</span><br><span class="line">    <span class="title function_">eat3</span>(<span class="params">food</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;在吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">eat</span>(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">person.<span class="title function_">eat2</span>(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">person.<span class="title function_">eat3</span>(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 对象扩展运算符</span></span><br><span class="line"><span class="comment">//拷贝对象（深拷贝）</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&quot;wanyu&quot;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="keyword">let</span> someon = &#123;...person&#125; <span class="comment">//&#123;name: &quot;wanyu&quot;, age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//合并对象</span></span><br><span class="line"><span class="keyword">let</span> age = &#123;<span class="attr">age</span>: <span class="number">21</span>&#125;</span><br><span class="line"><span class="keyword">let</span> name = &#123;<span class="attr">name</span>: <span class="string">&quot;wanyu&quot;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&quot;QB&quot;</span>&#125;</span><br><span class="line">person = &#123;...age, ...name&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person)  <span class="comment">// 相同的属性，新的数据的会覆盖之前的。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>map和reduce</p>
<p>数组中新增了map和reduce方法</p>
<p>map()：接受一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;-5&#x27;</span>, <span class="string">&#x27;3&#x27;</span>];</span><br><span class="line"></span><br><span class="line">arr = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item*<span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//也可以写成</span></span><br><span class="line">arr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item*<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<p>reduce()：为数组中的每一个元素依次执行回调函数，不包括数组中被删除或未被赋值的元素。</p>
<p>语法：arr.reduce(callback,[initialValue])</p>
<p>callback–回调函数（执行数组中每个值的函数），接受四个参数：</p>
<ol>
<li>previousValue 初始值（或者上一次回调函数的返回值）</li>
<li>currentValue 当前元素值</li>
<li>index 当前索引</li>
<li>array 调用reduce的数组</li>
</ol>
<p>initialValue–初始值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a：初始值或上次回调函数的返回值 b：当前元素值 100：初始值</span></span><br><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;上一次处理的值：&quot;</span> + a);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;当前正处理的值：&quot;</span> + a);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;,<span class="number">100</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Promise</strong></p>
<p>可以封装异步操作</p>
<p>学习敲代码。</p>
</li>
</ol>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>什么是模块化：</p>
<p>模块化是把代码进行拆分，方便重复利用。</p>
<p>类似Java中的导包，而JS中没有包的概念，换来的是模块。</p>
<p>模块的功能主要由两个命令构成：export 和 import</p>
<p>export：用于规定模块的对外接口（导出：<strong>基本类型，变量，函数</strong>）</p>
<p>import：用于导入其他模块提供的功能（导入 ）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> util <span class="keyword">from</span> <span class="string">&quot;./hello.js&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123;name, add&#125; <span class="keyword">from</span> <span class="string">&quot;./user.js&quot;</span>  <span class="comment">//导入多个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导出名为util和abc的函数或变量</span></span><br><span class="line"><span class="keyword">export</span>&#123;util, abc&#125;</span><br><span class="line"><span class="comment">// 导出util函数 都用util.sum(x,x)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> util = &#123;</span><br><span class="line">    <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出没有为函数命名，导入可以随意命名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="MVVM思想"><a href="#MVVM思想" class="headerlink" title="MVVM思想"></a>MVVM思想</h3><p>M：Model模型，包括数据和一些基本操作</p>
<p>V：View视图，页面渲染结果</p>
<p>VM：View-Model，模型与视图间的双向操作（无序开发人员干涉）</p>
<p>使用Model发生了变化，View上自然表现出来。</p>
<p>当用户修改了View，Model中的数据也会跟着改变。</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>VSCode 安装Vue 2 Snippets 插件，提供语法提示</p>
<p>浏览器安装 Vue-Devtools</p>
<h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><ol>
<li><p>打开新的文件夹，在终端运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>文件夹会出先一个package.json文件，表明是由npm来管理的项目</p>
<p>安装Vue</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install vue</span><br></pre></td></tr></table></figure>

<p>文件都放在了node_modules中。</p>
<p>在文件中引入vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Vue功能"><a href="#Vue功能" class="headerlink" title="Vue功能"></a>Vue功能</h4><ol>
<li><p>Vue声明式渲染</p>
</li>
<li><p>双向绑定：模型变化-》视图变化；视图变化-》模型变化</p>
</li>
<li><p>事件处理</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 由Vue管控&#123;&#123;&#125;&#125;中的内容，在运行时，命令行中修改vm.name的值，页面中数据会动态改变。</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;num&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;num++&quot;</span> &gt;</span>点赞<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;cancle&quot;</span> &gt;</span>取消<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;name&#125;&#125;，点赞数：&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">name</span>: <span class="string">&quot;刘洋&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">num</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">cancle</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            	<span class="variable language_">this</span>.<span class="property">num</span> --;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Vue操作的基础"><a href="#Vue操作的基础" class="headerlink" title="Vue操作的基础"></a>Vue操作的基础</h3><ol>
<li><p>创建Vue实例，关联页面的模板，将数据(data)响应式渲染到关联的模板。</p>
</li>
<li><p>指令来简化对dom的一些操作。</p>
</li>
<li><p>声明方法来做更复杂的操作。methods里面可以封装方法。</p>
</li>
</ol>
<h4 id="需要学习Vue的基础和生命周期钩子函数。来进行接下来的Vue开发。"><a href="#需要学习Vue的基础和生命周期钩子函数。来进行接下来的Vue开发。" class="headerlink" title="需要学习Vue的基础和生命周期钩子函数。来进行接下来的Vue开发。"></a>需要学习Vue的基础和生命周期钩子函数。来进行接下来的Vue开发。</h4><p>去官方文档，把基础篇全部看完，即可。</p>
<h3 id="Vue模块化开发"><a href="#Vue模块化开发" class="headerlink" title="Vue模块化开发"></a>Vue模块化开发</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><ol>
<li><p>全局安装webpack （cmd中即全局安装）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install webpack -g</span><br></pre></td></tr></table></figure></li>
<li><p>全局安装vue脚手架</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br></pre></td></tr></table></figure></li>
<li><p>初始化vue项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue init webpack vueName</span><br></pre></td></tr></table></figure></li>
<li><p>进入到项目，然后运行项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure></li>
<li><p>学习了解一下Vue项目各个文件的作用。</p>
</li>
</ol>
<h4 id="Vue整合ElementUI快速开发"><a href="#Vue整合ElementUI快速开发" class="headerlink" title="Vue整合ElementUI快速开发"></a>Vue整合ElementUI快速开发</h4><p>项目安装ElementUI组件库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i element-ui</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入ElementUI</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="comment">// 导入ElementUI的样式文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>)</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>商城</tag>
        <tag>ES6</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>商城项目（三）</title>
    <url>/2020/12/25/%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE3/</url>
    <content><![CDATA[<h1 id="功能实现一"><a href="#功能实现一" class="headerlink" title="功能实现一"></a>功能实现一</h1><p>先启动前端项目，然后启动Nacos，然后启动</p>
<h2 id="三级分类"><a href="#三级分类" class="headerlink" title="三级分类"></a>三级分类</h2><p>数据库导入数据。</p>
<p>打开categoryContoller</p>
<p>查出所有分类以及子分类，以树形结构组装起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//控制类</span></span><br><span class="line">List&lt;CategoryEntity&gt;categoryService.listWithTree();</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类 使用beseMapper，renren-fast使用的bao层自动继承baseMapper</span></span><br><span class="line">baseMapper == Dao</span><br><span class="line">    </span><br><span class="line"><span class="comment">//1. 查出所有分类</span></span><br><span class="line">entities = baseMapper.selectList(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//2. 组装成所有的父子分类</span></span><br><span class="line"><span class="comment">//2.1. 找到所有的一级分类</span></span><br><span class="line">entities。stream().filter((categoryEntity) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> categoryEntity.getParentCid == <span class="number">0</span>;</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>在实体中添加属性children</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表明在数据表中不存在</span></span><br><span class="line"><span class="meta">@TableField(exist=false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;CategoryEntity&gt; children;</span><br></pre></td></tr></table></figure>



<h4 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h4><ol>
<li><p>新建product/category.vue文件，使菜单知道新建的vue文件下。</p>
</li>
<li><p>在ElementUI中使用树形组件</p>
</li>
<li><p>前端向后端发送请求</p>
</li>
</ol>
<h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><ol>
<li><p>在gateway服务中编写配置类，在网关里面配置统一跨域</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallCorsConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 加入到容器中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsWebFilter <span class="title function_">corsWebFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        <span class="comment">//配置跨域  头，方法，来源，携带cookie</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 任意路径</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,corsConfiguration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写配置文件，使用filter</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://gulimall-product</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api/product/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">RewritePath=/api/(?&lt;segment&gt;.*),/$\&#123;segment&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">admin_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://renren-fast</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">RewritePath=/api/(?&lt;segment&gt;.*),/renren-fast/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>取消renren-fast项目的跨域配置类的设置。</p>
</li>
<li><p>确认后端返回的参数，准确接收。</p>
</li>
</ol>
<h3 id="删除-添加菜单"><a href="#删除-添加菜单" class="headerlink" title="删除/添加菜单"></a>删除/添加菜单</h3><h4 id="页面效果"><a href="#页面效果" class="headerlink" title="页面效果"></a>页面效果</h4><ol>
<li><p>使用ElementUI的自定义节点内容功能，使用其中的scoped slot功能。</p>
</li>
<li><p>导入需要的组件</p>
<p>node-key:唯一主键</p>
<p>show-checkbox:是否显示复选框</p>
<p>expand-on-click-node:点击非箭头位置，是否展开关闭树</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-tree</span><br><span class="line">    :data=&quot;menus&quot;</span><br><span class="line">    :props=&quot;defaultProps&quot;</span><br><span class="line">    show-checkbox=&quot;true&quot;</span><br><span class="line">    node-key=&quot;catId&quot;</span><br><span class="line">    :expand-on-click-node=&quot;false&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;!-- vue slot 的插槽机制 --&gt;</span><br><span class="line">    &lt;span class=&quot;custom-tree-node&quot; slot-scope=&quot;&#123; node, data &#125;&quot;&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123; node.label &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;span&gt;</span><br><span class="line">        &lt;el-button</span><br><span class="line">          v-if=&quot;node.level &lt;= 2&quot;</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          size=&quot;mini&quot;</span><br><span class="line">          @click=&quot;() =&gt; append(data)&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Append</span><br><span class="line">        &lt;/el-button&gt;</span><br><span class="line">        &lt;el-button</span><br><span class="line">          v-if=&quot;node.childNodes.length == 0&quot;</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          size=&quot;mini&quot;</span><br><span class="line">          @click=&quot;() =&gt; remove(node, data)&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Delete</span><br><span class="line">        &lt;/el-button&gt;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/el-tree&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h4><ol>
<li><p>对逻辑删除字段使用@TableLogic(value = “1”, delval = “0”) 注解，并表明删除规则。</p>
</li>
<li><p>编写删除方法。</p>
</li>
<li><p>下载postman模拟前端调用删除接口。</p>
</li>
</ol>
<h4 id="删除效果细化-添加菜单"><a href="#删除效果细化-添加菜单" class="headerlink" title="删除效果细化/添加菜单"></a>删除效果细化/添加菜单</h4><p>实现以下几点功能：</p>
<ol>
<li>点击delete，有确认提示框</li>
<li>删除菜单后，tree状态还是展开的</li>
<li>点击append(添加)，弹出可输入提示框。</li>
<li>将输入的数据和默认数据保存到data中</li>
<li>通过发送请求实现保存功能。</li>
</ol>
<h3 id="修改-批量删除菜单"><a href="#修改-批量删除菜单" class="headerlink" title="修改/批量删除菜单"></a>修改/批量删除菜单</h3><h4 id="基本修改效果"><a href="#基本修改效果" class="headerlink" title="基本修改效果"></a>基本修改效果</h4><ol>
<li>添加修改按钮</li>
<li>设置点击提示框</li>
<li>给提示开给你添加需要修改项可输入框</li>
<li>发送请求，修改数据。</li>
<li>注意在点击修改的时候，需要获得数据库最新的数据。</li>
<li>请求修改成功后，刷新页面时要回显数据（查询一次数据库，将数据给到缓存中的data），防止与数据库字段不同。</li>
<li>注意在不同操作，对缓存区的数据的修改。必要时，使数据归于默认值。</li>
</ol>
<h4 id="修改拖拽效果"><a href="#修改拖拽效果" class="headerlink" title="修改拖拽效果"></a>修改拖拽效果</h4><ol>
<li>实现可拖拽效果</li>
<li>实现switch选择按钮</li>
<li>记录拖拽菜单的id和父id</li>
<li>记录菜单的id和子id</li>
<li>实现批量拖动的点击按钮</li>
<li>菜单移动，设置限制，不允许超过3级菜单</li>
<li>检查，菜单拖动还有什么问题</li>
</ol>
<h4 id="批量删除菜单"><a href="#批量删除菜单" class="headerlink" title="批量删除菜单"></a>批量删除菜单</h4><ol>
<li><p>使用Element-UI的设置，获得批量选中的菜单id</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-tree</span> <span class="attr">ref</span>=<span class="string">&quot;menuTree&quot;</span></span></span><br><span class="line"><span class="tag">         &gt;</span><span class="tag">&lt;/<span class="name">el-tree</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选中的菜单的node</span></span><br><span class="line"><span class="keyword">let</span> checkedNodes = <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">menuTree</span>.<span class="title function_">getCheckedNodes</span>();</span><br></pre></td></tr></table></figure></li>
<li><p>发送请求处理</p>
</li>
<li><p>设置批量删除的确认按钮</p>
</li>
</ol>
<h2 id="品牌管理"><a href="#品牌管理" class="headerlink" title="品牌管理"></a>品牌管理</h2><h3 id="逆向生成的代码完成前端"><a href="#逆向生成的代码完成前端" class="headerlink" title="逆向生成的代码完成前端"></a>逆向生成的代码完成前端</h3><ol>
<li>添加品牌管理菜单</li>
<li>将生成的前端代码放到对应位置。</li>
<li>运行程序</li>
</ol>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol>
<li><p>显示状态 使用switch按钮</p>
</li>
<li><p>图片上传使用OSS对象存储</p>
</li>
<li><p>表格图片显示，使用原生img</p>
</li>
<li><p>前端数据校验使用 vue rule</p>
</li>
<li><p>后端数据校验使用JSR303</p>
<ol>
<li><p>使用javax.validation.constraints包下的多个校验注解</p>
</li>
<li><p>如果要开启校验功能，必须再接口上使用@Valid注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> R <span class="title function_">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> BrandEntity brand)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>给校验的bean后紧跟BindingResult，封装了校验结果。</p>
</li>
<li><p>数据校验与分组校验</p>
<ol>
<li>创建标识接口</li>
<li>@Valid注解更改为@Valided(对应的标识接口)注解</li>
<li>在校验注解上添加groups={对应的标识接口}</li>
<li>注意：只要使用了分组校验，未添加 groups 的校验注解将无效。</li>
</ol>
</li>
</ol>
</li>
<li><p>自定义校验</p>
<ol>
<li>编写自定义的校验注解</li>
<li>编写自定义的校验器</li>
<li>关联自定义的校验器和自定义的校验注解</li>
</ol>
</li>
<li><p>做统一异常处理</p>
</li>
</ol>
<h1 id="取消vue的报错提示"><a href="#取消vue的报错提示" class="headerlink" title="取消vue的报错提示"></a>取消vue的报错提示</h1><p>编写文件并没有错误，是vue的错误检查要求太高了，在build/webpack.base.conf.js文件中的createLintingRule方法中的方法提全部注释掉，重启就可以了。</p>
<h1 id="OSS-阿里云对象存储"><a href="#OSS-阿里云对象存储" class="headerlink" title="OSS 阿里云对象存储"></a>OSS 阿里云对象存储</h1><ol>
<li>Bucket：存储空间</li>
<li>Object：对象/文件</li>
<li>Rejion：地域</li>
<li>Endpoint：访问域名</li>
<li>AccessKey：密钥（包括钥匙id和密码：AccessKeyId，AccessKeySecret）</li>
</ol>
<p>使用步骤：</p>
<ol>
<li>引入oss-starter</li>
<li>配置key、endpoint相关信息</li>
<li>使用OSSClient 自动注入，进行相关操作</li>
<li>使用web签名获得相应的签名传给前端。</li>
</ol>
<h1 id="功能实现二"><a href="#功能实现二" class="headerlink" title="功能实现二"></a>功能实现二</h1><h2 id="SPU与SKU"><a href="#SPU与SKU" class="headerlink" title="SPU与SKU"></a>SPU与SKU</h2><p>规格属性（不变）与销售属性（可变）</p>
<h3 id="属性分组"><a href="#属性分组" class="headerlink" title="属性分组"></a>属性分组</h3><ol>
<li><p>将category的分类菜单，提取为组件</p>
</li>
<li><p>在attrgroup.vue中使用，导入组件</p>
</li>
<li><p>将自动生成的attrgroup.vue的前端代码导入到自己编写的vue中。</p>
</li>
<li><p>使用Vue 高级功能–父子组件传递数据（子给父数据，通过 <strong>事件机制</strong>，子给父发送事件，携带数据）</p>
<ol>
<li><p>在子组件中使用 @node-click=”事件方法名”</p>
</li>
<li><p>在methods中，实现方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">nodeclick</span>(<span class="params">data,node,component</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.$emit(<span class="string">&quot;tree-node-click&quot;</span>,data,node,component) <span class="comment">// 发送事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在父组件调用事件名 @tree-node-click=”treenodeclick”</p>
</li>
<li><p>编写方法获得数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">treenodeclick</span>(<span class="params">data,node,component</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;attrgroup感知到节点被点击&quot;</span>,data,node,component)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;被点击的菜单id&quot;</span>,data.<span class="property">catId</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <tags>
        <tag>商城</tag>
      </tags>
  </entry>
  <entry>
    <title>商城项目四</title>
    <url>/2021/02/04/%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE4/</url>
    <content><![CDATA[<h1 id="商城项目高级篇"><a href="#商城项目高级篇" class="headerlink" title="商城项目高级篇"></a>商城项目高级篇</h1><h2 id="1-ElasticSearch"><a href="#1-ElasticSearch" class="headerlink" title="1. ElasticSearch"></a>1. ElasticSearch</h2><p>所有数据都是json格式的文档( &lt;- 类型 &lt;- 索引)</p>
<h3 id="安装ElasticSearch和Kibana"><a href="#安装ElasticSearch和Kibana" class="headerlink" title="安装ElasticSearch和Kibana"></a>安装ElasticSearch和Kibana</h3><p>步骤一：docker安装：ElasticSearch和Kibana</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:7.4.2</span><br><span class="line">docker pull kibana:7.4.2</span><br><span class="line"></span><br><span class="line">mkdir -p /mydata/elasticsearch/config</span><br><span class="line">mkdir -p /mydata/elasticsearch/date</span><br><span class="line"></span><br><span class="line">docker run --name elasticsearch -p 9222:9200 -p 9333:9300 \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \</span><br><span class="line">-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.4.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">docker logs elasticsearch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋权限</span></span><br><span class="line">chmod -R 777 /mydata/elasticsearch/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装Kibana</span></span><br><span class="line">docker run --name kibana -e ELASTICSEARCH_HOSTS=http://81.70.204.157:9222 -p 5601:5601 \</span><br><span class="line">-d kibana:7.4.2</span><br></pre></td></tr></table></figure>



<h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><p>批量导入数据</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">GET _search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /customer/<span class="keyword">external</span>/_bulk</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;John Doe&quot;</span> &#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_id&quot;</span>:<span class="string">&quot;2&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Jane Doe&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">POST /_bulk</span><br><span class="line">&#123;<span class="string">&quot;delete&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;website&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;blog&quot;</span>,<span class="string">&quot;_id&quot;</span>:<span class="string">&quot;123&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;create&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;website&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;blog&quot;</span>,<span class="string">&quot;_id&quot;</span>:<span class="string">&quot;123&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;My first blog post&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;website&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;blog&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;My second blog post&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;update&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;website&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;blog&quot;</span>,<span class="string">&quot;_id&quot;</span>:<span class="string">&quot;123&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;doc&quot;</span>:&#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;My updated blog post&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">POST /bank/account/_bulk</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;account_number&quot;</span>:<span class="number">1</span>,<span class="string">&quot;balance&quot;</span>:<span class="number">39225</span>,<span class="string">&quot;firstname&quot;</span>:<span class="string">&quot;Amber&quot;</span>,<span class="string">&quot;lastname&quot;</span>:<span class="string">&quot;Duke&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">32</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;M&quot;</span>,<span class="string">&quot;address&quot;</span>:<span class="string">&quot;880 Holmes Lane&quot;</span>,<span class="string">&quot;employer&quot;</span>:<span class="string">&quot;Pyrami&quot;</span>,<span class="string">&quot;email&quot;</span>:<span class="string">&quot;amberduke@pyrami.com&quot;</span>,<span class="string">&quot;city&quot;</span>:<span class="string">&quot;Brogan&quot;</span>,<span class="string">&quot;state&quot;</span>:<span class="string">&quot;IL&quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>进阶检索</p>
<p>查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## 查询</span><br><span class="line"><span class="keyword">GET</span> bank<span class="operator">/</span>_search?q<span class="operator">=</span><span class="operator">*</span><span class="operator">&amp;</span>sort<span class="operator">=</span>account_number:<span class="keyword">asc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> bank<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;account_number&quot;: &quot;asc&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;balance&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> bank<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;balance&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;from&quot;: <span class="number">5</span>,</span><br><span class="line">  &quot;size&quot;: <span class="number">5</span>,</span><br><span class="line">  &quot;_source&quot;: [&quot;balance&quot;,&quot;firstname&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## <span class="keyword">match</span> 模糊匹配，条件分词，用于文本字段 字段.keyword精确匹配，精确查找不会分词</span><br><span class="line"><span class="keyword">GET</span> bank<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;address&quot;: &quot;mill lane&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> bank<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;address.keyword&quot;: &quot;789 Madison Street&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 全文检索根据评分排序，会对检索条件进行分词匹配</span><br><span class="line"></span><br><span class="line">## match_phrase 短语匹配，条件不分词</span><br><span class="line"><span class="keyword">GET</span> bank<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;address&quot;: &quot;mill lane&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## multi_match 多字段匹配，条件分词，谁匹配都行</span><br><span class="line"><span class="keyword">GET</span> bank<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;mill movico&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;address&quot;,&quot;city&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## bool 复合查询 must必须满足 must_not必须不满足 should可不满足，满足了得分高</span><br><span class="line"><span class="keyword">GET</span> bank<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;&quot;match&quot;: &#123;</span><br><span class="line">          &quot;gender&quot;: &quot;M&quot;</span><br><span class="line">        &#125;&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;address&quot;: &quot;mill&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123;&quot;match&quot;: &#123;</span><br><span class="line">          &quot;age&quot;: &quot;18&quot;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;&quot;match&quot;: &#123;</span><br><span class="line">          &quot;lastname&quot;: &quot;Wallace&quot;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## <span class="keyword">filter</span> 结果过滤 使用与must相同，但不会计算得分</span><br><span class="line"><span class="keyword">GET</span> bank<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;&quot;range&quot;: &#123;</span><br><span class="line">          &quot;age&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: <span class="number">18</span>,</span><br><span class="line">            &quot;lte&quot;: <span class="number">30</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> bank<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;age&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: <span class="number">18</span>,</span><br><span class="line">            &quot;lte&quot;: <span class="number">30</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## term与<span class="keyword">match</span>相同，用于精确字段，非文本字段查询</span><br><span class="line"><span class="keyword">GET</span> bank<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;age&quot;: &quot;28&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Aggregations(聚合)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## 搜索address中包含mill的所有人的年龄分布以及平均年龄</span><br><span class="line"><span class="keyword">GET</span> bank<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;address&quot;: &quot;mill&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;ageAgg&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;age&quot;,</span><br><span class="line">        &quot;size&quot;: <span class="number">10</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ageAvg&quot;:&#123;</span><br><span class="line">      &quot;avg&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;age&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;balanceAvg&quot;:&#123;</span><br><span class="line">      &quot;avg&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;size&quot;: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 按照年龄聚合，并且请求这些年龄段的这些人的平均薪资</span><br><span class="line"><span class="keyword">GET</span> bank<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;ageAgg&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;age&quot;,</span><br><span class="line">        &quot;size&quot;: <span class="number">100</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;ageAvg&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 查出所有年龄分布，并且这些年龄段中M的平均薪资和F的平均薪资以及这个年龄段的总体平均薪资</span><br><span class="line"><span class="keyword">GET</span> bank<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;ageAgg&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;age&quot;,</span><br><span class="line">        &quot;size&quot;: <span class="number">100</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;:&#123;</span><br><span class="line">        &quot;genderAgg&quot;:&#123;</span><br><span class="line">          &quot;terms&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;gender.keyword&quot;,</span><br><span class="line">            &quot;size&quot;: <span class="number">10</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;aggs&quot;: &#123;</span><br><span class="line">            &quot;balanceAvg&quot;: &#123;</span><br><span class="line">              &quot;avg&quot;: &#123;</span><br><span class="line">                &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ageBalance&quot;:&#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>映射</p>
<p>在es6.0版本之后，索引被es丢弃了，不建议设置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>bank<span class="operator">/</span>_mapping</span><br><span class="line"></span><br><span class="line">## 新建索引并且字段映射</span><br><span class="line">PUT <span class="operator">/</span>my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;email&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 添加新的字段映射</span><br><span class="line">PUT <span class="operator">/</span>my_index<span class="operator">/</span>_mapping</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;:&#123;</span><br><span class="line">    &quot;employee-id&quot;:&#123;</span><br><span class="line">      &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">      &quot;index&quot;: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>bank<span class="operator">/</span>_mapping</span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>my_index<span class="operator">/</span>_mapping</span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>newbank</span><br><span class="line"></span><br><span class="line">## 如果修改字段映射，选择新建一个索引库，导入旧数据</span><br><span class="line">## 旧版本的导入旧数据</span><br><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;bank&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;account&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;newbank&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>newbank<span class="operator">/</span>_search</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>bank<span class="operator">/</span>_search</span><br><span class="line"></span><br><span class="line">## 新版本导入旧数据，不用type</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="安装ik分词器"><a href="#安装ik分词器" class="headerlink" title="安装ik分词器"></a>安装ik分词器</h3><p>在es的plugin/目录下解压ik分词器的压缩包后，重启es容器。</p>
<p>ik分词器-自定义扩展词库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_smart&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;我是中国人&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;我是中国人&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">随便启动一个nginx实例，只为了复制出配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">没有镜像docker会自动下载</span></span><br><span class="line">docker run -p 80:80 --name nginx -d nginx:1.10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建nginx文件夹，并复制配置文件</span></span><br><span class="line">mkdir nginx</span><br><span class="line">docker container cp nginx:/etc/nginx .</span><br><span class="line">docker stop nginx</span><br><span class="line">docker rm nginx</span><br><span class="line">mv nginx conf</span><br><span class="line">mkdir nginx</span><br><span class="line">mv conf/ nginx/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动nginx</span></span><br><span class="line">docker run -p 80:80 --name nginx \</span><br><span class="line">-v /mydata/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /mydata/nginx/logs:/var/log/nginx \</span><br><span class="line">-v /mydata/nginx/conf:/etc/nginx \</span><br><span class="line">-d nginx:1.10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置nginx的主页</span></span><br><span class="line">cd nginx/html</span><br><span class="line">vi index.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置nginx容器开机自启</span></span><br><span class="line">docker update --restart=always nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自定义分词器的内容</span></span><br><span class="line">mkdir es</span><br><span class="line">cd /mydata/nginx/conf/html/es/</span><br><span class="line">vi fenci.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑数据</span></span><br><span class="line">尚硅谷</span><br><span class="line">乔碧罗</span><br><span class="line"></span><br><span class="line">cd /mydata/elasticsearch/plugins/ik/config/</span><br><span class="line">vi IKAnalyzer.cfg.xml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑：取消远程扩展字典的注释，并使用自己设置的nginx的自定义分词器的内容</span></span><br><span class="line">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span><br><span class="line">&lt;entry key=&quot;remote_ext_dict&quot;&gt;http://81.70.204.157/es/fenci.txt&lt;/entry&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启es</span></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;乔碧罗殿下&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用Rest-High-Level-Client"><a href="#使用Rest-High-Level-Client" class="headerlink" title="使用Rest High Level Client"></a>使用Rest High Level Client</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallSearchApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">searchData</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">//1. 创建检索请求</span></span><br><span class="line">		<span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>();</span><br><span class="line">		<span class="comment">//指定索引</span></span><br><span class="line">		searchRequest.indices(<span class="string">&quot;bank&quot;</span>);</span><br><span class="line">		<span class="comment">//指定DSL，检索条件</span></span><br><span class="line">		<span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">		<span class="comment">//构造检索条件</span></span><br><span class="line">		sourceBuilder.query(QueryBuilders.matchQuery(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;mill&quot;</span>));</span><br><span class="line">		<span class="comment">// 按照年龄的值分布进行聚合</span></span><br><span class="line">		<span class="type">TermsAggregationBuilder</span> <span class="variable">ageAgg</span> <span class="operator">=</span> AggregationBuilders.terms(<span class="string">&quot;agaAgg&quot;</span>).field(<span class="string">&quot;age&quot;</span>).size(<span class="number">10</span>);</span><br><span class="line">		sourceBuilder.aggregation(ageAgg);</span><br><span class="line">		<span class="comment">// 计算平均薪资</span></span><br><span class="line">		<span class="type">AvgAggregationBuilder</span> <span class="variable">balanceAvg</span> <span class="operator">=</span> AggregationBuilders.avg(<span class="string">&quot;balanceAvg&quot;</span>).field(<span class="string">&quot;balance&quot;</span>);</span><br><span class="line">		sourceBuilder.aggregation(balanceAvg);</span><br><span class="line"><span class="comment">//		sourceBuilder.query(QueryBuilders.matchAllQuery());</span></span><br><span class="line"><span class="comment">//		sourceBuilder.from();</span></span><br><span class="line"><span class="comment">//		sourceBuilder.size();</span></span><br><span class="line"><span class="comment">//		sourceBuilder.aggregation();</span></span><br><span class="line">		searchRequest.source(sourceBuilder);</span><br><span class="line">		<span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest, GulimallElasticSearchConfig.COMMON_OPTIONS);</span><br><span class="line">		System.out.println(searchResponse.toString());</span><br><span class="line">		<span class="comment">//获取所有查到的数据</span></span><br><span class="line">		<span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> searchResponse.getHits();</span><br><span class="line">		SearchHit[] searchHits = hits.getHits();</span><br><span class="line">		<span class="keyword">for</span> (SearchHit hit : searchHits) &#123;</span><br><span class="line">			<span class="type">float</span> <span class="variable">score</span> <span class="operator">=</span> hit.getScore();</span><br><span class="line">			<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> hit.getId();</span><br><span class="line"><span class="comment">//			Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">			<span class="type">Accout</span> <span class="variable">accout</span> <span class="operator">=</span> JSON.parseObject(sourceAsString, Accout.class);</span><br><span class="line">			System.out.println(accout);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取这次检索到的分析信息</span></span><br><span class="line">		<span class="type">Aggregations</span> <span class="variable">aggregations</span> <span class="operator">=</span> searchResponse.getAggregations();</span><br><span class="line">		<span class="type">Terms</span> <span class="variable">agaAgg1</span> <span class="operator">=</span> aggregations.get(<span class="string">&quot;agaAgg&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (Terms.Bucket bucket : agaAgg1.getBuckets()) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">keyAsString</span> <span class="operator">=</span> bucket.getKeyAsString();</span><br><span class="line">			System.out.println(<span class="string">&quot;年龄：&quot;</span> + keyAsString + <span class="string">&quot;==&gt;&quot;</span> + bucket.getDocCount());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Avg</span> <span class="variable">balanceAvg1</span> <span class="operator">=</span> aggregations.get(<span class="string">&quot;balanceAvg&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;平均薪资：&quot;</span> + balanceAvg1.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 测试存储数据到es</span></span><br><span class="line"><span class="comment">	 * 保存和更新都可以</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">indexData</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">		<span class="comment">// id全部字符串</span></span><br><span class="line">		indexRequest.id(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">		<span class="comment">//1-1. 键值对保存</span></span><br><span class="line"><span class="comment">//		indexRequest.source(&quot;userName&quot;, &quot;zhangsan&quot;, &quot;age&quot;, 18, &quot;gender&quot;, &quot;男&quot;);</span></span><br><span class="line">		<span class="comment">//1-2. json保存</span></span><br><span class="line">		<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">		user.setUserName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">		user.setAge(<span class="number">18</span>);</span><br><span class="line">		user.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">		indexRequest.source(jsonString, XContentType.JSON);</span><br><span class="line">		<span class="comment">//执行操作</span></span><br><span class="line">		<span class="type">IndexResponse</span> <span class="variable">index</span> <span class="operator">=</span> client.index(indexRequest, GulimallElasticSearchConfig.COMMON_OPTIONS);</span><br><span class="line">		System.out.println(index);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@ToString</span></span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Accout</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> account_number;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">		<span class="keyword">private</span> String firstname;</span><br><span class="line">		<span class="keyword">private</span> String lastname;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">		<span class="keyword">private</span> String gender;</span><br><span class="line">		<span class="keyword">private</span> String address;</span><br><span class="line">		<span class="keyword">private</span> String employer;</span><br><span class="line">		<span class="keyword">private</span> String email;</span><br><span class="line">		<span class="keyword">private</span> String city;</span><br><span class="line">		<span class="keyword">private</span> String state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String userName;</span><br><span class="line">		<span class="keyword">private</span> String gender;</span><br><span class="line">		<span class="keyword">private</span> Integer age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(client);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建es索引库"><a href="#构建es索引库" class="headerlink" title="构建es索引库"></a>构建es索引库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT product</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;skuId&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;spuId&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      # 使用id_smart的分词方法</span><br><span class="line">      &quot;skuTitle&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;skuPrice&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      #冗余字段 不进行索引，不对字段数据进行聚合处理</span><br><span class="line">      &quot;skuImg&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;index&quot;: false,</span><br><span class="line">        &quot;doc_values&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;saleCount&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;hasStock&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;boolean&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;hotScore&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;brandId&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;catalogId&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;brandName&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;index&quot;: false,</span><br><span class="line">        &quot;doc_values&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;brandImg&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;index&quot;: false,</span><br><span class="line">        &quot;doc_values&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;catalogName&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;index&quot;: false,</span><br><span class="line">        &quot;doc_values&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;attrs&quot;:&#123;</span><br><span class="line">      </span><br><span class="line">      	# 为应对es数据扁平化，使该对象的属性嵌套在一个对象中。 扁平化：想要查询满足多个属性的对象，但是查询的结果为满足任意查询条件的多个对象。这是因为es对该对象处理的问题。对于es来说，这个对象的多个属性没有被看作整体。</span><br><span class="line">        &quot;type&quot;: &quot;nested&quot;,</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">          &quot;attrId&quot;:&#123;</span><br><span class="line">            &quot;type&quot;: &quot;long&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;attrName&quot;:&#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">            &quot;index&quot;: false,</span><br><span class="line">            &quot;doc_values&quot;: false</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;attrValue&quot;:&#123;</span><br><span class="line">            &quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-后台编写商品上架功能"><a href="#2-后台编写商品上架功能" class="headerlink" title="2. 后台编写商品上架功能"></a>2. 后台编写商品上架功能</h2><h2 id="3-整合thymeleaf实现前端渲染"><a href="#3-整合thymeleaf实现前端渲染" class="headerlink" title="3. 整合thymeleaf实现前端渲染"></a>3. 整合thymeleaf实现前端渲染</h2><ol>
<li>引入：thymeleaf-starter：关闭缓存</li>
<li>静态资源static文件夹下，直接访问</li>
<li>页面放在templates下，直接访问</li>
<li>页面修改实时更新<ol>
<li>引入dev-tools</li>
<li>修改完页面使用ctrl+shift+F9 重新编译下页面，代码配置推荐重启</li>
</ol>
</li>
</ol>
<h2 id="4-nginx搭建域名访问环境（反向代理配置）"><a href="#4-nginx搭建域名访问环境（反向代理配置）" class="headerlink" title="4. nginx搭建域名访问环境（反向代理配置）"></a>4. nginx搭建域名访问环境（反向代理配置）</h2><p>正向代理：隐藏客户端信息（科学上网）</p>
<p>反向代理：隐藏服务端信息（负载均衡访问，屏蔽内网服务器信息）</p>
<p>域名映射效果</p>
<ul>
<li>接口请求 gulimall.com</li>
<li>请求页面 gulimall.com</li>
</ul>
<p>nginx直接代理网关，网关判断</p>
<ul>
<li>如果/api/****， 转交给对应的服务器</li>
<li>如果是 满足域名，转交给对应的服务</li>
</ul>
<p><img src="https://i.loli.net/2021/02/23/QgLVwBv6bUFohJG.png" alt="image.png"></p>
<h2 id="5-性能压测"><a href="#5-性能压测" class="headerlink" title="5. 性能压测"></a>5. 性能压测</h2><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul>
<li><p>响应时间：发送请求到响应结束</p>
</li>
<li><p>HPS：每秒点击次数，次/秒</p>
</li>
<li><p>TPS：每秒处理交易数，笔/秒</p>
</li>
<li><p>QPS：每秒处理查询次数，次/秒</p>
</li>
<li><p>最大响应时间</p>
</li>
<li><p>最小响应时间</p>
</li>
<li><p>90%响应时间：所有用户的响应时间排序，第90%的相应时间</p>
</li>
<li><p>从外部看，性能测试主要关注如下三个指标</p>
<ul>
<li>吞吐量：每秒系统能够处理的请求数、任务数。（高并发）</li>
<li>响应时间：处理一个请求或一个任务的耗时。（高性能）</li>
<li>错误率：一批请求中结果出错的请求所占比例。</li>
</ul>
</li>
</ul>
<h3 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h3><p>用于压力测试</p>
<p>创建线程组：使用HTTP请求，查看结果树，汇总报告，聚合报告，汇总图</p>
<h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h3><p>用于性能监控</p>
<p>运行：正在运行</p>
<p>休眠：sleep</p>
<p>等待：wait</p>
<p>驻留：线程池里面的空闲线程</p>
<p>监视：阻塞的线程，正在等待锁</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li><p>中间件越多，性能损失越大，大多都损失在网络交互中。</p>
</li>
<li><p>业务（最需要优化）：</p>
<ul>
<li>Db（MySQL优化）<ul>
<li>给字段加索引（可能：提升一倍多倍）</li>
<li>关日志（提高日志级别：error）</li>
</ul>
</li>
<li>模板的渲染速度（缓存）<ul>
<li>开缓存（略微提升）</li>
</ul>
</li>
<li>静态资源<ul>
<li>Nginx动静分离</li>
</ul>
</li>
<li>优化三级分类数据获取（优化业务逻辑，使用redis）</li>
</ul>
</li>
<li><p>jvm优化：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">-Xmx1024m -Xms1024m -Xmn512m</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Nginx动静分离"><a href="#Nginx动静分离" class="headerlink" title="Nginx动静分离"></a>Nginx动静分离</h3><p><img src="https://i.loli.net/2021/02/25/8RVOXzYatSrjJFT.png" alt="image.png"></p>
]]></content>
      <tags>
        <tag>商城</tag>
      </tags>
  </entry>
  <entry>
    <title>商城项目六</title>
    <url>/2021/02/22/%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE6/</url>
    <content><![CDATA[<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><ol>
<li><p>初始化线程的4种方式</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 继承Thread</span><br><span class="line">2. 实现Runable接口</span><br><span class="line">3. 实现Callable接口 + FutureTask(可以拿到结果，可以处理异常)</span><br><span class="line">4. 线程池 给线程池直接提交任务</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">1，2不能得到返回值，3可以获得返回值</span><br><span class="line">1，2，3都不能控制资源</span><br><span class="line">4可以控制资源，性能稳定。</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4种实现方式"><a href="#4种实现方式" class="headerlink" title="4种实现方式"></a>4种实现方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="type">Thread01</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread01</span>();</span><br><span class="line">thread01.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="type">Runable01</span> <span class="variable">runable01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runable01</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(runable01).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.1</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable01</span>());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"><span class="comment">//3.2</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable01</span>());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"><span class="comment">//阻塞 等待整个线程执行完成，获取返回结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">System.out.println(<span class="string">&quot;返回结果：&quot;</span>+integer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//当前系统中池只有一两个，每个异步任务，提交给线程池</span></span><br><span class="line"><span class="comment">//创建全局类变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//4.1</span></span><br><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">Runable01</span>());</span><br><span class="line"><span class="comment">//4.2 使用原生线程池</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">200</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">1000000</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br></pre></td></tr></table></figure>

<h3 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h3><h4 id="原生线程池"><a href="#原生线程池" class="headerlink" title="原生线程池"></a>原生线程池</h4><h5 id="有7大参数"><a href="#有7大参数" class="headerlink" title="有7大参数"></a>有7大参数</h5><ol>
<li>corePoolSize 核心线程池：线程池创建好就准备就绪的线程数量，等待接收异步任务去执行。</li>
<li>maximumPoolSize 最大线程数。</li>
<li>keepAliveTime 存活时间。释放空闲线程，只要空闲线程大于核心线程。</li>
<li>unit 时间单位。</li>
<li>workQueue 阻塞队列。</li>
<li>threadFactory 线程的创建工厂。</li>
<li>handler 如果队列满了，按照指定的拒绝策略拒绝执行任务。</li>
</ol>
<h5 id="工作顺序"><a href="#工作顺序" class="headerlink" title="工作顺序"></a>工作顺序</h5><pre><code>1. 线程池创建，准备好core数量的核心线程。
    1.1 核心满了，再进阻塞队列，空闲的回去阻塞队列获取任务
    1.2 阻塞队列满了，就开新线程执行，最大额能开到max指定的数量
    1.3 max满了就用拒绝任务
    1.4 max都执行完成了，有很多空闲，在指定时间以后，就释放多余线程。
    new LinkedBlockingDeque&lt;&gt;() 默认时Integer的最大值，会造成内存不够
</code></pre>
<h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><p>一个线程池core7，max20，queue50，100并发进来怎么分配？<br>          7个立即执行，50个进入队列，13个开新线程执行。剩下30个使用拒绝策略。<br>          如果不想抛弃还要执行。new ThreadPoolExecutor.CallerRunsPolicy() 使用同步执行的拒绝策略</p>
<h4 id="常见4种线程池"><a href="#常见4种线程池" class="headerlink" title="常见4种线程池"></a>常见4种线程池</h4><ol>
<li>Executors.newCachedThreadPool(); //core是0，所有都可回收</li>
<li>Executors.newFixedThreadPool(); //固定大小，core=max，所有都不可回收</li>
<li>Executors.newScheduledThreadPool();  //定时任务的线程池，可传递一个线程开始运行的时间</li>
<li>Executors.newScheduledThreadPool(); //单线程线程池，后台从队列里面获取任务，依次执行，是同步的</li>
</ol>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>实现了Future接口，Future可以获取异步结果。</p>
<p>当多个线程池运行，可以设置之间相互关系。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>首先创建一个线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h4 id="简单异步运行"><a href="#简单异步运行" class="headerlink" title="简单异步运行"></a>简单异步运行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程id：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;运行结果：&quot;</span> + i);</span><br><span class="line">&#125;, executor);</span><br></pre></td></tr></table></figure>

<h4 id="异步运行获取返回值"><a href="#异步运行获取返回值" class="headerlink" title="异步运行获取返回值"></a>异步运行获取返回值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.1</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程id：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;运行结果：&quot;</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> future.get();</span><br><span class="line">System.out.println(<span class="string">&quot;返回值：&quot;</span>+integer);</span><br></pre></td></tr></table></figure>

<h4 id="异步完成时回调"><a href="#异步完成时回调" class="headerlink" title="异步完成时回调"></a>异步完成时回调</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.2 计算完成时回调</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程id：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;运行结果：&quot;</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor).whenComplete((res,excption)-&gt;&#123;</span><br><span class="line">    <span class="comment">//虽然能得到异常信息，但是没法修改返回数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;异步任务完成了。。。结果是：&quot;</span>+res+<span class="string">&quot;；异常是：&quot;</span>+excption);</span><br><span class="line">&#125;).exceptionally(throwable -&gt; &#123;</span><br><span class="line">    <span class="comment">//可以感知异常，同时返回默认值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="异步完成后再处理"><a href="#异步完成后再处理" class="headerlink" title="异步完成后再处理"></a>异步完成后再处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.3 方法完成后的处理</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程id：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;运行结果：&quot;</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor).handle((res,thr)-&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (res!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (thr!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="线程串行化"><a href="#线程串行化" class="headerlink" title="线程串行化"></a>线程串行化</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">thenRunAsync:不能获取到上一步的执行结果，无返回值</span><br><span class="line">thenAcceptAsync 能接受上一步结果，但无返回值</span><br><span class="line">thenApplyAsync 能接受上一步结果，有返回值</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//thenRunAsync：</span></span><br><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程id：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;运行结果：&quot;</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor).thenRunAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2启动了。。。&quot;</span>);</span><br><span class="line">&#125;,executor);</span><br></pre></td></tr></table></figure>

<h3 id="两任务组合关系"><a href="#两任务组合关系" class="headerlink" title="两任务组合关系"></a>两任务组合关系</h3><p>首先创建两个异步线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Object&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前1线程id：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;运行1结果：&quot;</span> + i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Object&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前2线程id：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;运行2结束&quot;</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br></pre></td></tr></table></figure>

<h4 id="两任务都完成，再执行三任务"><a href="#两任务都完成，再执行三任务" class="headerlink" title="两任务都完成，再执行三任务"></a>两任务都完成，再执行三任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 不能获取两次执行结果</span></span><br><span class="line">future01.runAfterBothAsync(future02,()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务3开始。。。&quot;</span>);</span><br><span class="line">&#125;,executor);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2 能获取两次执行结果，但没有返回值</span></span><br><span class="line">future01.thenAcceptBothAsync(future02,(f1,f2)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务3开始。。。之前的结果：&quot;</span>+f1+<span class="string">&quot;--&gt;&quot;</span>+f2);</span><br><span class="line">&#125;,executor);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3 能获取两次执行结果，有返回值</span></span><br><span class="line">CompletableFuture&lt;String&gt; future = future01.thenCombineAsync(future02, (f1, f2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> f1 + <span class="string">&quot;:&quot;</span> + f2 + <span class="string">&quot;-&gt;end&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line">System.out.println(<span class="string">&quot;结果返回：&quot;</span>+future.get());</span><br></pre></td></tr></table></figure>

<h4 id="两任务任一完成，执行三任务"><a href="#两任务任一完成，执行三任务" class="headerlink" title="两任务任一完成，执行三任务"></a>两任务任一完成，执行三任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 不感知结果，没有返回值</span></span><br><span class="line">future01.runAfterEitherAsync(future02,()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务3开始。。。&quot;</span>);</span><br><span class="line">&#125;,executor);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2 感知结果，没有返回值</span></span><br><span class="line">future01.acceptEitherAsync(future02,(res)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务3开始。。。之前的结果：&quot;</span>+res);</span><br><span class="line">&#125;,executor);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3 感知结果，有返回值</span></span><br><span class="line">CompletableFuture&lt;String&gt; future = future01.applyToEitherAsync(future02, res -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> res.toString() + <span class="string">&quot;-&gt;哈哈&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line">System.out.println(<span class="string">&quot;结果返回：&quot;</span>+future.get());</span><br></pre></td></tr></table></figure>

<h3 id="多任务组合关系"><a href="#多任务组合关系" class="headerlink" title="多任务组合关系"></a>多任务组合关系</h3><p>首先创建多个异步任务，这里创建了3个异步任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待所有结果都完成</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(futureImg, futureAttr, futureDesc);</span><br><span class="line">allOf.get();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待任意一个任务执行完成，获得那个任务的返回值。</span></span><br><span class="line">CompletableFuture&lt;Object&gt; anyOf = CompletableFuture.anyOf(futureImg, futureAttr, futureDesc);</span><br><span class="line">anyOf.get();</span><br></pre></td></tr></table></figure>

<h2 id="MD5-amp-MD5盐值加密"><a href="#MD5-amp-MD5盐值加密" class="headerlink" title="MD5&amp;MD5盐值加密"></a>MD5&amp;MD5盐值加密</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>Message Digest algorithm 5：信息概要算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> DigestUtils.md5Hex(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>任意长度数据，MD5值的长度都是固定的。</li>
<li>容易计算。</li>
<li>对原数据进行任何修改，哪怕只修改1个字节，MD5值都区别很大。</li>
<li>很难找到不同的数据，具有相同的MD5值。</li>
</ol>
<h3 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h3><p>通过生成随机数与MD5生成字符串组合。</p>
<p>数据库据同时存储MD5值和salt值（随机数）。验证正确性时使用salt进行MD5即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//盐值加密</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> Md5Crypt.md5Crypt(<span class="string">&quot;123456&quot;</span>.getBytes());</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> Md5Crypt.md5Crypt(<span class="string">&quot;123456&quot;</span>.getBytes(), <span class="string">&quot;$1$aaaaa&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="spring密码加密器"><a href="#spring密码加密器" class="headerlink" title="spring密码加密器"></a>spring密码加密器</h3><p>使用的盐值加密</p>
<p>每次加密出来的encode都不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BCryptPasswordEncoder</span> <span class="variable">passwordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> passwordEncoder.encode(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">System.out.println(encode);</span><br></pre></td></tr></table></figure>

<p>每次可以让密码跟旧encode种比较，会从旧encode中获取到盐值。</p>
<p>虽然每次的encode不同，但是都会跟原密码匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BCryptPasswordEncoder</span> <span class="variable">passwordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> passwordEncoder.matches(<span class="string">&quot;123456&quot;</span>, <span class="string">&quot;$2a$10$fZU3lFnAGKStM8JAqQtJVu1BHOF99PfK9LCNkGLal0tt.xCWky7rG&quot;</span>);</span><br><span class="line">System.out.println(matches);</span><br></pre></td></tr></table></figure>

<h2 id="社交登录"><a href="#社交登录" class="headerlink" title="社交登录"></a>社交登录</h2><h3 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h3><p>第三方应用使用社交账号登录。</p>
<ol>
<li>向用户申请请求认证</li>
<li>用户输入自己社交账号的账号密码</li>
<li>使用上步授权，进行认证（QQ服务器）</li>
<li>认证通过，返回访问令牌（QQ服务器）</li>
<li>使用访问令牌，获取开放保护信息。</li>
<li>认证令牌，返回受保护信息。</li>
</ol>
<h3 id="使用微博账号登录"><a href="#使用微博账号登录" class="headerlink" title="使用微博账号登录"></a>使用微博账号登录</h3><p>微博中使用code换取accesstoken，code只能用一次。</p>
<p>短时间一个用户的acesstoken一段时间内是不会变化的</p>
<p>授权回调页：<a href="http://gulimall.com/oauth2.0/weibo/success">http://gulimall.com/oauth2.0/weibo/success</a></p>
<p>取消授权回调页：<a href="http://gulimall.com/fail">http://gulimall.com/fail</a></p>
<p><a href="https://imgtu.com/i/cStzXF"><img src="https://z3.ax1x.com/2021/03/28/cStzXF.jpg" alt="cStzXF.jpg"></a></p>
<h2 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h2><h3 id="Session共享问题解决"><a href="#Session共享问题解决" class="headerlink" title="Session共享问题解决"></a>Session共享问题解决</h3><ul>
<li>统一存储</li>
<li>子域session共享</li>
</ul>
<p>SpringSession原理</p>
<h3 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h3><p>多系统情况下，一个地方登录，所有系统通用。</p>
<p>gitee开源项目：xxl-sso克隆下来</p>
<p>编写host文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.226.128	gulimall.com</span><br><span class="line">192.168.226.128	search.gulimall.com</span><br><span class="line">192.168.226.128	item.gulimall.com</span><br><span class="line">192.168.226.128	auth.gulimall.com</span><br><span class="line"></span><br><span class="line">127.0.0.1 ssoserver.com</span><br><span class="line">127.0.0.1 client1.com</span><br><span class="line">127.0.0.1 client2.com</span><br></pre></td></tr></table></figure>

<p>运行服务器命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">目录地址\xxl-sso&gt; mvn clean package -Dmaven.skip.test=true</span><br><span class="line">cd xxl-sso-server\target</span><br><span class="line">java -jar xxl-sso-server-1.1.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>运行成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器sso登录地址</span><br><span class="line">http://ssoserver.com:8080/xxl-sso-server/login</span><br></pre></td></tr></table></figure>

<p>运行2个客户端命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">目录\xxl-sso\xxl-sso-samples\xxl-sso-web-sample-springboot\target&gt;java -jar xxl-sso-web-sample-springboot-1.1.1-SNAPSHOT.jar --server.port=8081</span><br><span class="line">目录\xxl-sso\xxl-sso-samples\xxl-sso-web-sample-springboot\target&gt;java -jar xxl-sso-web-sample-springboot-1.1.1-SNAPSHOT.jar --server.port=8082</span><br></pre></td></tr></table></figure>

<p>运行成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">客户端地址</span><br><span class="line">http://client1.com:8081/xxl-sso-web-sample-springboot</span><br><span class="line">http://client2.com:8082/xxl-sso-web-sample-springboot</span><br></pre></td></tr></table></figure>

<p>核心：三个系统域名不同，但是能给三个系统同步同一个用户票据。</p>
<ol>
<li>中央认证服务器：ssoserver.com</li>
<li>其它系统，想要登录去ssoserver.com的登录，登录成功跳转回来。</li>
<li>只要一个登录，其他都不用登录</li>
<li>全系统统一一个sso-sessionid。所有系统可能域名都不相同</li>
</ol>
<h4 id="单点登录功能以后再做"><a href="#单点登录功能以后再做" class="headerlink" title="单点登录功能以后再做"></a>单点登录功能以后再做</h4>]]></content>
      <tags>
        <tag>商城</tag>
      </tags>
  </entry>
  <entry>
    <title>商城项目五</title>
    <url>/2021/02/25/%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE5/</url>
    <content><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h2><p>哪些数据适合放入缓存？</p>
<ul>
<li>即时性、数据一致性要求不高的</li>
<li>访问大量且更新频率不高的数据</li>
</ul>
<h2 id="整合redis"><a href="#整合redis" class="headerlink" title="整合redis"></a>整合redis</h2><ol>
<li>引入data-redis-starter</li>
<li>简单配置redis的host等信息</li>
<li>使用springboot自动配置好的StringRedisTemplate来操作redis</li>
</ol>
<h3 id="简单使用样例"><a href="#简单使用样例" class="headerlink" title="简单使用样例"></a>简单使用样例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; <span class="title function_">getCatalogJson</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//给缓存中放json字符串，拿出的json字符串，用逆转为能用的对象类型【序列化与反序列化】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 加入缓存逻辑，缓存中存的数据是json字符串</span></span><br><span class="line">    <span class="comment">//JSON 跨语言，跨平台兼容。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">catalogJson</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;catalogJson&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(catalogJson)) &#123;</span><br><span class="line">        <span class="comment">//2. 缓存中没有，查询数据库</span></span><br><span class="line">        Map&lt;String, List&lt;Catelog2Vo&gt;&gt; catalogJsonFromDb = getCatalogJsonFromDb();</span><br><span class="line">        <span class="comment">//3. 查到的数据放入缓存，将对象转为json放入缓存中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSON.toJSONString(catalogJsonFromDb);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;catalogJson&quot;</span>, s);</span><br><span class="line">        <span class="keyword">return</span> catalogJsonFromDb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转为指定的对象</span></span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; result = </span><br><span class="line">        JSON.parseObject(catalogJson, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;() &#123;&#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存泄露及解决"><a href="#内存泄露及解决" class="headerlink" title="内存泄露及解决"></a>内存泄露及解决</h3><h4 id="堆外内存溢出"><a href="#堆外内存溢出" class="headerlink" title="堆外内存溢出"></a>堆外内存溢出</h4><p>redis压力测试易产生：堆外内存溢出：OutOfDirectMemoryError</p>
<ol>
<li>springboot2.0以后默认使用lettuce作为操作redis的客户端。它使用netty进行网络通信。</li>
<li>lettuce的bug导致netty堆外内存溢出。<ol>
<li>-Xmx300m；netty如果没有指定推外内存，默认使用-Xmx300m作为内存：没有得到内存的及时释放。</li>
<li>可以通过-Dio.netty.maxDirectMemory进行设置。</li>
</ol>
</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>不能使用-Dio.netty.maxDirectMemory只去调大堆外内存。</p>
<ol>
<li>升级lettuce客户端</li>
<li>切换使用jedis</li>
</ol>
<h2 id="高并发下缓存失效问题"><a href="#高并发下缓存失效问题" class="headerlink" title="高并发下缓存失效问题"></a>高并发下缓存失效问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>指查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，但是数据库也无此数据。</p>
<p>没有将这次查询的null写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p>
<h4 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h4><p>利用不存在的数据进行攻击，数据库瞬时压力增大，最终导致崩溃</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>null结果缓存，并加入短暂过期时间</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>指在我们设置缓存时key采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</p>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><ul>
<li>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。</li>
<li>如果这个key在大量请求同时进来前刚好失效，那么所有对这个key的数据查询都落到db，我们称为缓存击穿。</li>
</ul>
<h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><p>加锁：大量并发只让一个去查，其他人等待，查到以后释放锁，其他人获取到锁，先查缓存，就会有数据，不用去db</p>
<h3 id="整体解决方案"><a href="#整体解决方案" class="headerlink" title="整体解决方案"></a>整体解决方案</h3><ol>
<li>空结果缓存：解决缓存穿透</li>
<li>这是过期时间（加随机值）：解决缓存雪崩</li>
<li>加锁：解决缓存击穿</li>
</ol>
<p>synchronized(this)：SpringBoot所有的组件在容器中都是单例的。</p>
<p>本地锁：synchronized，JUC（lock），在分布式情况下，想要锁住所有，必须使用分布式锁</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>redis中使用 SET …… NX 不存在才放</p>
<p>map中的数据都是放到内存中的，如果使用map作为缓存，成为本地缓存。</p>
<p>Redission是一个在Redis的基础上实现的Java驻内存数据网格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Redission锁的自动续期，如果业务超长，运行期间自动给锁续上新的30s。（看门狗机制）</span><br></pre></td></tr></table></figure>

<h2 id="使用redis模拟分布式锁"><a href="#使用redis模拟分布式锁" class="headerlink" title="使用redis模拟分布式锁"></a>使用redis模拟分布式锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用redis 使用分布式锁  加锁保证原子性，解锁保证原子性</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; <span class="title function_">getCatalogJsonFromDbWithRedisLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 占分布式锁，去redis占坑</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">// set lock 1111 EX 300 NX    EX: 设置过期时间；NX: 不存在插入</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">300</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取分布式锁成功&quot;</span>);</span><br><span class="line">        <span class="comment">//加锁成功。。。执行业务</span></span><br><span class="line">        <span class="comment">//2. 设置过期时间，必须和加锁是同步的，原子的</span></span><br><span class="line">        <span class="comment">//            redisTemplate.expire(&quot;lock&quot;, 30, TimeUnit.SECONDS);// 30秒过期时间</span></span><br><span class="line">        Map&lt;String, List&lt;Catelog2Vo&gt;&gt; fromDb = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fromDb = getCatalogJsonFromDb();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">            <span class="comment">//删除锁</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">lock1</span> <span class="operator">=</span> redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;Long&gt;(script, Long.class), Arrays.asList(<span class="string">&quot;lock&quot;</span>), uuid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//            redisTemplate.delete(&quot;lock&quot;);//删除锁</span></span><br><span class="line">        <span class="comment">// 获取值 + 删除锁 = 必须原子性操作   lua脚本解锁</span></span><br><span class="line">        <span class="comment">//            String lockValue = redisTemplate.opsForValue().get(&quot;lock&quot;);</span></span><br><span class="line">        <span class="comment">//            if (uuid.equals(lockValue)) &#123;</span></span><br><span class="line">        <span class="comment">//                //删除自己的锁</span></span><br><span class="line">        <span class="comment">//                redisTemplate.delete(&quot;lock&quot;);</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fromDb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//加锁失败。。。重试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取分布式锁失败。。。等待重试&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getCatalogJsonFromDbWithRedisLock(); <span class="comment">//自旋方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整合Redission"><a href="#整合Redission" class="headerlink" title="整合Redission"></a>整合Redission</h2><h3 id="导入redission依赖"><a href="#导入redission依赖" class="headerlink" title="导入redission依赖"></a>导入redission依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p> 编写配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRedissonConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有对Redisson的使用通过RedissonClient对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redisson</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://81.70.204.157:6379&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 根据Config创建出RedissonClient示例</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可重入锁介绍"><a href="#可重入锁介绍" class="headerlink" title="可重入锁介绍"></a>可重入锁介绍</h3><p>有多个带锁的方法，他们需相互调用，如果他们的锁是同一个可重入锁，即可进入锁的方法中。</p>
<p>如果不是可重入锁，只能进一次锁。</p>
<h3 id="该节记录知识点"><a href="#该节记录知识点" class="headerlink" title="该节记录知识点"></a>该节记录知识点</h3><ol>
<li>JUC:  java.util.concurrent</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取一把锁</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;my-lock&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 加锁</span></span><br><span class="line"><span class="comment">// lock.lock();  //阻塞时等待。默认加的锁都是三十秒</span></span><br><span class="line"><span class="comment">//2.1 锁的自动续期，如果业务超长，运行期间自动给锁续上新的30s。不用担心业务时间长，锁被删掉</span></span><br><span class="line"><span class="comment">//2.2 加锁的业务只要运行完成，就不会给当前锁续期，即使不手动解锁，锁默认30s后自动删除</span></span><br><span class="line"><span class="comment">//    看门狗锁续期时间/3=10s  10s后自动续期</span></span><br><span class="line"></span><br><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS); <span class="comment">//1. 时间到了后不会自动续期 //2. 10秒自动解锁，自动解锁时间要大于业务时间</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;加锁成功，执行业务...&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//3. 解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;释放锁...&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>公平锁（默认非公平锁）：先发起请求，先获取锁，后来的请求，按顺序获取锁。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁：并发读不受影响，并发写需依次等待执行。写时 锁住 读锁。</p>
<p>保证一定能读到最新数据，修改期间，写锁是一个排他锁（互斥锁，独享锁）。读锁是一个共享锁。</p>
<p>写锁没释放 读就必须等待；读锁没释放 写就必须等待。</p>
<p>读+读：相当于无锁，并发读。当前所有读锁，都会同时加载成功。</p>
<p>写+读：读等待写锁释放</p>
<p>写+写：阻塞方式，后写等待前写释放</p>
<p>读+写：写等待读锁释放</p>
<h3 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h3><p>设置等待数，通过减一，当等待数完成后，解锁</p>
<p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放假，闭锁</span></span><br><span class="line"><span class="comment"> * 5个班全部走完，锁大门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/lockDoor&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">lockDoor</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">RCountDownLatch</span> <span class="variable">door</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;door&quot;</span>);</span><br><span class="line">    door.trySetCount(<span class="number">5</span>);</span><br><span class="line">    door.await(); <span class="comment">//等待闭锁都完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;放假了。。。&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">gogogo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">    <span class="type">RCountDownLatch</span> <span class="variable">door</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;door&quot;</span>);</span><br><span class="line">    door.countDown();  <span class="comment">//闭锁，计数减 1</span></span><br><span class="line">    <span class="keyword">return</span> id+<span class="string">&quot;班的人都走了。。。&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 车库停车</span></span><br><span class="line"><span class="comment"> * 3车位</span></span><br><span class="line"><span class="comment"> * 信号量 也可以用作分布式 限流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">park</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">RSemaphore</span> <span class="variable">park</span> <span class="operator">=</span> redisson.getSemaphore(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">    park.acquire(); <span class="comment">// 阻塞时等待：获取一个信号，获取一个值,占一个车位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> park.tryAcquire();</span><br><span class="line">    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">        <span class="comment">//执行业务</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok=&gt;&quot;</span>+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">go</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RSemaphore</span> <span class="variable">park</span> <span class="operator">=</span> redisson.getSemaphore(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">    park.release(); <span class="comment">// 释放一个车位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><ol>
<li>双写模式：数据库写，修改redis</li>
<li>失效模式：数据库写，删除redis，读取时第一次从数据库读，写入redis</li>
</ol>
<p>可以使用Canal更新缓存（Canal阿里开发的中间件，可以保证缓存一致性：生成一个记录数据库更新数据的日志，来解决缓存不一致问题）</p>
<p>数据异构：比如每个人的商城首页展示的商品是不同的。原理：用户访问记录与商品信息表通过Canal生成一个异构系统用户推荐表，首页的数据在推荐表中查找。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>缓存的所有数据都有过期时间，数据过期下一次查询触发主动更新。</li>
<li>使用分布式的读写锁。</li>
</ol>
<h1 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h1><p>简介：用来统一不同缓存的技术。</p>
<h2 id="整合-简化缓存开发"><a href="#整合-简化缓存开发" class="headerlink" title="整合-简化缓存开发"></a>整合-简化缓存开发</h2><ol>
<li><p>引入依赖</p>
<ol>
<li>spring-boot-starter-cache</li>
<li>spring-boot-starter-data-redis</li>
</ol>
</li>
<li><p>写配置</p>
<ol>
<li><p>自动配置了哪些</p>
<ol>
<li>自动配好了缓存管理器</li>
</ol>
</li>
<li><p>我们配置什么</p>
<ol>
<li><p>配置使用redis作为缓存</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cache.type</span>=<span class="string">redis</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>测试使用缓存</p>
<ol>
<li>@Cacheable：触发将数据保存到缓存的操作</li>
<li>@CacheEvict：触发将数据从缓存删除的操作</li>
<li>@CachePut：不影响方法执行更新缓存</li>
<li>@Caching：组合以上多个操作</li>
<li>@CacheConig：在类级别共享缓存的相同配置</li>
</ol>
</li>
<li><p>开启缓存功能</p>
<p>@EnableCaching</p>
</li>
<li><p>只需使用注解就能完成缓存的操作</p>
<ol>
<li>每一个需要缓存的数据我们都要指定放到那个名字的缓存。【缓存的分区(按照业务类型分)】</li>
<li>@Cacheable({“category”})</li>
<li>当前方法的解决需要缓存，如果缓存中有，方法不用调用；如果缓存中没有，会调用方法，最后将方法的结果放入缓存。</li>
</ol>
</li>
<li><p>```<br>spring.cache.type=redis<br>#spring.cache.cache-names=qq,<br>#设置存活时间<br>spring.cache.redis.time-to-live=60000<br>#默认分区名作为前缀<br>#spring.cache.redis.key-prefix=CACHE_<br>spring.cache.redis.use-key-prefix=true<br>#是否缓存空值  解决缓存穿透问题<br>spring.cache.redis.cache-null-values=true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">7. 自定义缓存配置</span><br><span class="line"></span><br><span class="line">   ```properties</span><br><span class="line">   spring.cache.type=redis</span><br><span class="line">   #spring.cache.cache-names=qq,</span><br><span class="line">   #设置存活时间</span><br><span class="line">   spring.cache.redis.time-to-live=60000</span><br><span class="line">   spring.cache.redis.key-prefix=CACHE_</span><br><span class="line">   spring.cache.redis.use-key-prefix=true</span><br><span class="line">   #是否缓存空值  解决缓存穿透问题</span><br><span class="line">   spring.cache.redis.cache-null-values=true</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(CacheProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCacheConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    RedisCacheConfiguration <span class="title function_">redisCacheConfiguration</span><span class="params">(CacheProperties cacheProperties)</span>&#123;</span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line"><span class="comment">//        config = config.entryTtl();</span></span><br><span class="line">        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()));</span><br><span class="line">        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>()));</span><br><span class="line">        <span class="comment">// 将配置文件中的所有配置都生效</span></span><br><span class="line">        CacheProperties.<span class="type">Redis</span> <span class="variable">redisProperties</span> <span class="operator">=</span> cacheProperties.getRedis();</span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getTimeToLive() != <span class="literal">null</span>) &#123;</span><br><span class="line">            config = config.entryTtl(redisProperties.getTimeToLive());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getKeyPrefix() != <span class="literal">null</span>) &#123;</span><br><span class="line">            config = config.prefixKeysWith(redisProperties.getKeyPrefix());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isCacheNullValues()) &#123;</span><br><span class="line">            config = config.disableCachingNullValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isUseKeyPrefix()) &#123;</span><br><span class="line">            config = config.disableKeyPrefix();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>商城</tag>
      </tags>
  </entry>
  <entry>
    <title>商城项目七</title>
    <url>/2021/04/05/%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE7/</url>
    <content><![CDATA[<h1 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h1><p>临时（离线）购物车与登录购物车</p>
<p>ThreadLocal-同一个线程共享数据 </p>
<p>RedirectAttribute ra</p>
<p>​    ra.addFlashAttribute();将数据放在session里面，可以在页面中取出，看是只能取一次。</p>
<p>​    ra.addAttribute(“skuId”,skuId);将数据放在url后面</p>
<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><p>分布式系统中的常见作用：</p>
<ol>
<li>异步处理：通过中间件处理程序的异步任务，不用程序等待异步任务执行完成。</li>
<li>应用解耦：服务间通信，通过中间件交换数据。</li>
<li>流量处理：大量请求放入中间件。</li>
</ol>
<p>概述：</p>
<p>概念：消息代理和目的地</p>
<p>目的地两种形式：</p>
<ol>
<li>队列：点对点通信。</li>
<li>主题：发布/订阅消息通信。</li>
</ol>
<p>docker安装RabbitMQ</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management</span><br><span class="line"></span><br><span class="line">docker updata rabbitmq --restart=always</span><br></pre></td></tr></table></figure>

<p>web访问默认端口15672：</p>
<p>账户与密码：guest</p>
<p>交换机类型</p>
<p>Exchange:</p>
<ol>
<li>direct：1-1  直接交换机，一个交换机对1个队列</li>
<li>fanout：广播所有队列</li>
<li>topic：可以给任意部分队列</li>
<li>headers：与direct相同，性能很差</li>
</ol>
<h2 id="当端口被占用时"><a href="#当端口被占用时" class="headerlink" title="当端口被占用时"></a>当端口被占用时</h2><p>在cmd中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ano|</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找9000端口</span></span><br><span class="line">netstat -ano|findstr 9000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有进程</span></span><br><span class="line">tasklist</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看被占用端口号进程</span></span><br><span class="line">tasklist|findstr 19796</span><br></pre></td></tr></table></figure>

<p>用一个消息，只能被一个服务监听获取。</p>
<p>只有一个消息处理完成下一个消息再接收。</p>
<p>@RabbitListener：类+方法上（监听那些队列即可）</p>
<p>@RabbitHandler：标在方法上（重载区分不同的消息）</p>
<p>RabbitMQ消息确认机制-可靠抵达</p>
<ol>
<li>服务收到消息就回调</li>
<li>消息正确敌法队列进行回调</li>
<li>消费端确认ack</li>
</ol>
<h1 id="订单"><a href="#订单" class="headerlink" title="订单"></a>订单</h1><p>Feign远程调用丢失请求头问题</p>
<p>浏览器发送（请求头自动带了cookie）</p>
<p>feign远程调用，会创建一个新的request（没有任何请求头）</p>
<h2 id="保证提交订单的幂等性"><a href="#保证提交订单的幂等性" class="headerlink" title="保证提交订单的幂等性"></a>保证提交订单的幂等性</h2><p>接口幂等性，就是用户对于统一操作发起的一次请求或多次请求的结果是一致的。</p>
<h3 id="防止哪些情况："><a href="#防止哪些情况：" class="headerlink" title="防止哪些情况："></a>防止哪些情况：</h3><ol>
<li>多次点击提交</li>
<li>页面回退再次提交</li>
<li>微服务重复调用。feign出发重试机制。</li>
<li>其他业务情况</li>
</ol>
<h3 id="什么时候需要幂等"><a href="#什么时候需要幂等" class="headerlink" title="什么时候需要幂等"></a>什么时候需要幂等</h3><p>查询天然幂等</p>
<p>更新同一数据，也是幂等</p>
<p>删除同一结果，幂等</p>
<p>插入相同主键用户，幂等</p>
<p>每次执行的结果都会发生变化，不是幂等的。</p>
<p>数据库方面解决：数据库设置索引：订单号设置唯一索引。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-token机制"><a href="#1-token机制" class="headerlink" title="1. token机制"></a>1. token机制</h4><ol>
<li>token存入redis：对比token和删除token必须是，原子性操作。lua脚本。</li>
<li>验证码</li>
</ol>
<h4 id="2-各种锁机制"><a href="#2-各种锁机制" class="headerlink" title="2. 各种锁机制"></a>2. 各种锁机制</h4><p> 悲观锁、乐观锁、业务层分布式锁</p>
<h4 id="3-使用各种唯一约束"><a href="#3-使用各种唯一约束" class="headerlink" title="3. 使用各种唯一约束"></a>3. 使用各种唯一约束</h4><p>数据库唯一约束，redis set 防重处理</p>
<h4 id="4-防重表"><a href="#4-防重表" class="headerlink" title="4. 防重表"></a>4. 防重表</h4><h4 id="5-全局请求唯一id"><a href="#5-全局请求唯一id" class="headerlink" title="5. 全局请求唯一id"></a>5. 全局请求唯一id</h4><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>本地事务：在分布式系统下，控制不了其他服务的事务回滚。</p>
<p>分布式事务：最大原因。网络问题+分布式机器。</p>
<p>事务的传播行为：多个方法，是否公用一个事务。还是在嵌套方法中，事务中包含新事务。</p>
<p>Spring Boot事务是使用代理对象来控制事务的。</p>
<p>如果在同一个对象内事务方法互调，事务默认失效，原因：事务方法的调用绕过了代理对象。</p>
<p>本地事务失效问题：</p>
<p>（同一个对象内事务方法互调默认失效）</p>
<ol>
<li><p>引入aop starter依赖</p>
</li>
<li><p>```java<br>@EnableAspectJAutoProxy(exposeProxy = true)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   开启aspectj动态代理功能。</span><br><span class="line"></span><br><span class="line">3. 暴露代理对象，本类互调对象</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   代理对象类 变量名 = (代理对象名) AopContext.currentProxy();</span><br><span class="line">   变量名.事务方法名();</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="分布式CAP"><a href="#分布式CAP" class="headerlink" title="分布式CAP"></a>分布式CAP</h3><p>一致性、可用性、分区容错性。</p>
<h3 id="Raft算法原理"><a href="#Raft算法原理" class="headerlink" title="Raft算法原理"></a>Raft算法原理</h3><p>节点三种状态：随从、候选、领导。</p>
<h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><p>Spring Cloud Alibaba的一款开源的分布式事务解决方案。为用户提供了AT、TCC、SAGA和XA事务模式。</p>
<p>TC：数据协调者，管理全局事务的提交或回滚。</p>
<p>TM：事务管理器，控制大事务。</p>
<p>RM：资源管理器，自己服务事务的管理器。</p>
<p>Seata模式使用AT模式，是根据二阶段提交的演变。</p>
<p>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</p>
<p>二阶段：如果出现异常，根据数据库的提交日志，回滚数据反向补偿。 </p>
<h4 id="Seata控制分布式事务"><a href="#Seata控制分布式事务" class="headerlink" title="Seata控制分布式事务"></a>Seata控制分布式事务</h4><ol>
<li>创建UNDO_LOG表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>安装事务协调器：下载：<a href="https://github.com/seata/seata/releases">https://github.com/seata/seata/releases</a></p>
</li>
<li><p>整合：</p>
<ol>
<li><p>导入依赖 spring-cloud-starter-alibaba-seata。</p>
</li>
<li><p>解压并启动seata-server。</p>
<p>registry.conf：注册中心配置：修改registry type=nacos</p>
<p>file.conf</p>
</li>
<li><p>所有想要用到分布式事务的微服务使用seata DataSourceProxy代理自己的数据源</p>
</li>
<li><p>每个微服务，都必须导入</p>
<p>registry.conf</p>
<p>file.conf   vgroup_mapping.{application.name}-fescar-service-group = “default”</p>
</li>
<li><p>启动测试分布式事务</p>
</li>
<li><p>给分布式大事务的入口标注@GlobalTransational</p>
</li>
<li><p>每一个小事务@Transational</p>
</li>
</ol>
</li>
</ol>
<h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><p>通过rabbit mq 的延时队列实现订单回滚事务。</p>
<h1 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h1><h2 id="支付宝沙箱环境"><a href="#支付宝沙箱环境" class="headerlink" title="支付宝沙箱环境"></a>支付宝沙箱环境</h2><p>内网穿透待完成。</p>
]]></content>
      <tags>
        <tag>商城</tag>
      </tags>
  </entry>
  <entry>
    <title>商城项目（九）</title>
    <url>/2021/05/31/%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE9/</url>
    <content><![CDATA[<h1 id="秒杀（高并发）系统关注的问题"><a href="#秒杀（高并发）系统关注的问题" class="headerlink" title="秒杀（高并发）系统关注的问题"></a>秒杀（高并发）系统关注的问题</h1><ol>
<li>服务单一职责+独立部署（秒杀服务）</li>
<li>秒杀连接加密（秒杀之前防止秒杀连接暴露）</li>
<li>库存预热+快速扣减（使用缓存redis，把数据放入redis中，使用扣信号量处理库存）</li>
<li>动静分离（nginx动静分离）</li>
<li>恶意请求拦截（网关层，登录拦截）</li>
<li>流量错峰</li>
<li>限流&amp;熔断&amp;降级（Alibaba的Sentinel）</li>
<li>队列削峰（秒杀成功的请求进入队列，慢慢创建订单）</li>
</ol>
<h2 id="Spring-Cloud-Alibaba-Sentinel"><a href="#Spring-Cloud-Alibaba-Sentinel" class="headerlink" title="Spring Cloud Alibaba-Sentinel"></a>Spring Cloud Alibaba-Sentinel</h2><h3 id="熔断降级限流"><a href="#熔断降级限流" class="headerlink" title="熔断降级限流"></a>熔断降级限流</h3><h4 id="什么是熔断"><a href="#什么是熔断" class="headerlink" title="什么是熔断"></a>什么是熔断</h4><p>A服务调用B服务的某个功能，由于网络不稳定问题，或者B服务卡机，导致功能时间超长。如果这样子次数太多，可以直接将B短路了（A不在请求B接口），凡是调用B的直接返回降级数据，不必等待B的超长执行。这样B的故障问题，就不会级联影响到A。</p>
<h4 id="什么是降级"><a href="#什么是降级" class="headerlink" title="什么是降级"></a>什么是降级</h4><p>整个网站处于流量高峰期，服务器压力剧增。根据当前业务情况及流量，对一些服务和页面进行有策略的降级（停止服务，所有的调用直接返回降级数据）。缓解服务器资源的压力，以保证核心业务的正常运行，同时也保持了大部分客户得到正确的响应。</p>
<h4 id="异同："><a href="#异同：" class="headerlink" title="异同："></a>异同：</h4><p>相同点：</p>
<ol>
<li>为了保证集群大部分服务的可用性和可靠性，防止崩溃，牺牲小我。</li>
<li>用户最终都是体验到某个功能不可用。</li>
</ol>
<p>不同点：</p>
<ol>
<li>熔断是被调用方故障，触发的系统主动规则。</li>
<li>降级是基于全局考虑，停止一些正常服务，释放资源。（一般是认为的）</li>
</ol>
<h4 id="什么是限流"><a href="#什么是限流" class="headerlink" title="什么是限流"></a>什么是限流</h4><p>对打入服务的请求流量进行控制，使服务能够承担不超过自己额能力的流量压力。</p>
]]></content>
      <tags>
        <tag>商城</tag>
        <tag>秒杀</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>商城项目（八）</title>
    <url>/2021/04/22/%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE8/</url>
    <content><![CDATA[<h2 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h2><p>秒杀具有瞬间高并发的特点，必须要做 <strong>限流</strong>+<strong>异步</strong>+<strong>缓存</strong>（页面静态化）+<strong>独立部署</strong></p>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>cron表达式用来做定时任务，用法这里不简洁了，可以在网上搜索在线生成cron表达式</p>
<p>org.springframework.scheduling为spring自带的定时任务执行方案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 定时任务</span><br><span class="line">*  <span class="number">1.</span> <span class="meta">@EnableScheduling</span> 开启定时任务</span><br><span class="line">*  <span class="number">2.</span> <span class="meta">@Scheduled</span> 开启定时任务</span><br><span class="line">*  <span class="number">3.</span> 自动配置类 TaskSchedulingAutoConfiguration</span><br><span class="line">* 异步任务</span><br><span class="line">*  <span class="number">1.</span> <span class="meta">@EnableAsync</span>开启异步任务执行</span><br><span class="line">*  <span class="number">2.</span> <span class="meta">@Async</span> 给希望异步执行的方法标注</span><br><span class="line">*  <span class="number">3.</span> 自动配置类 TaskExecutionAutoConfiguration</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="number">1.</span> Spring 中cron表达式由<span class="number">6</span>位组成，不允许第<span class="number">7</span>位的年</span><br><span class="line">* <span class="number">2.</span> 在周几的位置，<span class="number">1</span>-<span class="number">7</span>代表周一到周日</span><br><span class="line">* <span class="number">3.</span> 定时任务不应该阻塞。默认是阻塞的</span><br><span class="line">*      <span class="number">1.</span> 业务已异步的方式，提交到线程池</span><br><span class="line">*      <span class="number">2.</span> 支持定时任务线程池：设置TaskSchedulingProperties</span><br><span class="line">*      <span class="number">3.</span> 让定时任务异步执行</span><br><span class="line">*          异步任务</span><br><span class="line">*    解决：使用异步+定时任务来完成定时任务不阻塞的功能</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>商城</tag>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里巴巴开发手册</title>
    <url>/2020/11/12/java/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>划分七个维度：编程规约、异常日志、单元测试、安全规约、MySQL数据库、工程结构、设计规约。</p>
<h2 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><ol>
<li>代码中的命名不能以下划线或美元符号开始或结束。</li>
<li>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文。</li>
<li>类名是使用UpperCamelCase风格，但有例外：DO/BO/DTO/VO/AO/PO/UID等。<ol>
<li>正例：UserDO/XmlService</li>
<li>反例：UserDo/XMLService</li>
</ol>
</li>
<li>方法名、参数名、成员变量、局部变量统一使用lowerCamelCase风格。必须遵从驼峰式。</li>
<li>常量名全部大写，单词间用下划线隔开，力求语义表达完整，不要嫌名字长。</li>
<li>抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以Test结尾。</li>
<li>类型与中括号紧挨相连表示数组。</li>
<li>POJO类中布尔类型变量都不要加si前缀，否则部分框架解析会引起序列化错误。</li>
<li>包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。</li>
<li>避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名。</li>
<li>杜绝不规范缩写。</li>
<li>任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。</li>
<li>命名常量与变量时，表示类型的名词放在词尾。<ol>
<li>正例：startTime</li>
</ol>
</li>
<li>如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式<ol>
<li>public class OrderFactory;</li>
</ol>
</li>
<li>接口类中的方法和属性不要加任何修饰符号（public也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，除非与接口方法相关，并且是整个应用的基础常量。</li>
<li>接口和实现类有两套命名规则<ol>
<li>对于Service和DAO类，基于SOA理念，暴露出来的服务一定是接口，额你不的实现类用Impl的后缀与接口区别。</li>
<li>如果是形容能力的接口名称，去对应的形容词为接口名（通常是-able的形容词）<ol>
<li>正例：AbstractTranslator实现Translatable接口。</li>
</ol>
</li>
</ol>
</li>
<li>枚举类名带上Enum后缀，枚举成员名称需全大写，单词间用下划线隔开。<ol>
<li>说明：枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有。</li>
</ol>
</li>
<li>各层命名规约：<ol>
<li>Service/DAO层方法命名规约<ol>
<li>获取单个对象的方法用 get 做前缀。</li>
<li>获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。</li>
<li> 获取统计值的方法用 count 做前缀。 </li>
<li>插入的方法用 save/insert 做前缀。</li>
<li>删除的方法用 remove/delete 做前缀。</li>
<li>修改的方法用 update 做前缀。</li>
</ol>
</li>
<li>领域模型命名规约<ol>
<li>数据对象：xxxDO，xxx 即为数据表名。</li>
<li>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</li>
<li>展示对象：xxxVO，xxx 一般为网页名称。</li>
<li>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><h3 id="OOP规约"><a href="#OOP规约" class="headerlink" title="OOP规约"></a>OOP规约</h3><h3 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h3><h3 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><ol>
<li>获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</li>
<li>创建线程或线程池是请指定有意义的线程名称，方便出错时回溯。</li>
<li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</li>
<li>线程池不允许使用Executors去创建，通过ThreadPoolExector的方式。可以更加明确线程池的运行规则，规避资源耗尽的风险。</li>
<li>SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。</li>
<li>必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如不清理，可能会影响后续业务逻辑和造成内存泄漏等问题。尽量在代理中使用try-finally块进行回收。</li>
<li>高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，不要锁整个方法体；能用对象锁，不要用类锁。<ol>
<li>说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。</li>
</ol>
</li>
<li>对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</li>
<li>在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。</li>
<li>在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。<ol>
<li>说明：Lock 对象的 unlock 方法在执行时，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），如果当前线程不持有锁，则抛出IllegalMonitorStateException 异常。</li>
</ol>
</li>
<li>并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。<ol>
<li>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。</li>
</ol>
</li>
<li>多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，如果在处理定时任务时使用ScheduledExecutorService 则没有这个问题。</li>
<li>资金相关的金融敏感信息，使用悲观锁策略。<ol>
<li>说明：乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常。</li>
</ol>
</li>
<li>使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至await方法，知道超出时才返回结果。<ol>
<li>说明：注意，子线程抛出异常堆栈，不能在主线程try-catch到。</li>
</ol>
</li>
<li>避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。</li>
<li>在并发场景下，通过双重检查锁实现延迟初始化的优化问题隐患，推荐解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。</li>
<li>volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</li>
<li>HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。</li>
<li>ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。</li>
</ol>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><ol>
<li>在一个switch块内，每个case要么通过continue/break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，必须包含一个default语句并且放在最后，即使什么代码也没有。</li>
<li>当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null判断。</li>
<li>在 if/else/for/while/do 语句中必须使用大括号。</li>
<li>在高并发场景中，避免使用”等于”判断作为中断或退出的条件。</li>
<li>表达异常的分支时，少用 if-else 方式。</li>
</ol>
<h3 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h3><ol>
<li>类、类属性、类方法的注释必须使用Javadoc规范，使用/** 内容 */格式，不得使用// xxx 方式。<ol>
<li>说明：在IDE编辑窗口中，Javadoc方式会提示相关注释。提高阅读效率。</li>
</ol>
</li>
<li>所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释，除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。<ol>
<li>说明：对子类的实现要求，或者调用注意事项，请一并说明。</li>
</ol>
</li>
<li>所有的类都必须添加创建者和创建日期。</li>
<li>方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐。</li>
<li>所有的枚举类型字段必须要有注释，说明每个数据项的用途。</li>
<li>与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。</li>
<li>代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。</li>
<li>谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。</li>
<li>对于注释的要求：第一、能够准确反映设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。</li>
<li>好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。</li>
<li>特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<ol>
<li>待办事宜（TODO）:（标记人，标记时间，[预计处理时间]）</li>
<li>错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）</li>
</ol>
</li>
<li>对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由。</li>
</ol>
<h2 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol>
<li>Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过 catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等。</li>
<li>异常不要用来做流程控制，条件控制。<ol>
<li>说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</li>
</ol>
</li>
<li>catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。</li>
<li>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</li>
<li>有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。</li>
<li>finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。<ol>
<li>说明：如果 JDK7 及以上，可以使用 try-with-resources 方式。</li>
</ol>
</li>
<li>不要在 finally 块中使用 return。</li>
<li>捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。</li>
<li>在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 Throwable类来进行拦截。</li>
<li>方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。</li>
<li>防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：<ol>
<li>返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。</li>
<li>数据库的查询结果可能为 null。 </li>
<li>集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。 </li>
<li>远程调用返回对象时，一律要求进行空指针判断，防止 NPE。 </li>
<li>对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。</li>
<li>级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。</li>
</ol>
</li>
<li>定义时区分 unchecked / checked 异常，避免直接抛出 new RuntimeException()，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等。</li>
<li>对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。</li>
<li>避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。</li>
</ol>
<h3 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h3><ol>
<li>应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</li>
<li>所有日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。网络运行状态、安全相关信息、系统监测、管理后台操作、用户敏感操作需要留存相关的网络日志不少于 6 个月。</li>
<li>应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。</li>
<li>在日志输出时，字符串变量之间的拼接使用占位符的方式。</li>
<li>对于 trace/debug/info 级别的日志输出，必须进行日志级别的开关判断。</li>
<li>避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。</li>
<li>异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。</li>
<li>谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。</li>
<li>可以使用 warn 日志级别来记录用户输入参数错误的情况</li>
<li>尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。【强制】国际化团队或海外部署的服务器由于字符集问题，使用全英文来注释和描述日志错误信息。</li>
</ol>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol>
<li>好的单元测试必须遵守 AIR 原则。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。</li>
<li>单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。</li>
<li>保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。</li>
<li>单元测试是可以重复执行的，不能受到外界环境的影响。</li>
</ol>
<h2 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h2><ol>
<li>隶属于用户个人的页面或者功能必须进行权限控制校验。</li>
<li>用户敏感数据禁止直接展示，必须对展示数据进行脱敏。</li>
<li>用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。</li>
<li>用户请求传入的任何参数必须做有效性验证。</li>
<li>禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</li>
<li>表单、AJAX 提交必须执行 CSRF 安全验证。</li>
<li>在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的 机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。</li>
<li>发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。</li>
</ol>
<h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><h2 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h2><ol>
<li><p>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。</p>
<ol>
<li>说明：任何字段如果为非负数，必须是 unsigned。</li>
<li>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在&lt; resultMap &gt;设置从 is_xxx到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。</li>
</ol>
</li>
<li><p>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p>
<ol>
<li>说明：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。</li>
</ol>
</li>
<li><p>表名不使用复数名词。</p>
</li>
<li><p>禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p>
</li>
<li><p>主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</p>
<ol>
<li>说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</li>
</ol>
</li>
<li><p>小数类型为 decimal，禁止使用 float 和 double。</p>
<ol>
<li>说明：在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。</li>
</ol>
</li>
<li><p>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p>
</li>
<li><p>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p>
</li>
<li><p>表必备三字段：id, create_time, update_time。</p>
<ol>
<li>说明：：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。create_time, update_time的类型均为 datetime 类型。</li>
</ol>
</li>
<li><p>表的命名最好是遵循“业务名称_表的作用”</p>
<ol>
<li>正例：alipay_task / force_project / trade_config</li>
</ol>
</li>
<li><p>库名与应用名称尽量一致。</p>
</li>
<li><p>如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p>
</li>
<li><p>字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</p>
<ol>
<li>不是频繁修改的字段。</li>
<li>不是 varchar 超长字段，更不能是 text 字段。</li>
<li>不是唯一索引的字段。</li>
</ol>
</li>
<li><p>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</p>
<ol>
<li>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</li>
</ol>
</li>
<li><p>合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检</p>
<p>索速度。</p>
</li>
</ol>
<h2 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h2><ol>
<li>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</li>
<li>超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。</li>
<li>在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</li>
<li>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</li>
<li>如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。<ol>
<li>正例：where a=? and b=? order by c; 索引：a_b_c 。</li>
</ol>
</li>
<li>利用覆盖索引来进行查询操作，避免回表。<ol>
<li>说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。</li>
</ol>
</li>
<li>利用延迟关联或者子查询优化超多分页场景。<ol>
<li>说明：：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL改写。</li>
</ol>
</li>
<li>SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是consts 最好。<ol>
<li>consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。</li>
<li>ref 指的是使用普通的索引（normal index）。 </li>
<li>range 对索引进行范围检索。</li>
</ol>
</li>
<li>建组合索引的时候，区分度最高的在最左边。<ol>
<li>如果 where a=? and b=? ，如果 a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。</li>
<li>说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：where c&gt;? and d=? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 idx_d_c。</li>
</ol>
</li>
<li>防止因字段类型不同造成的隐式转换，导致索引失效。</li>
<li>创建索引时避免有如下极端误解：<ol>
<li>宁滥勿缺。认为一个查询就需要建一个索引。</li>
<li>宁缺勿滥。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。</li>
<li>抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</li>
</ol>
</li>
</ol>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><ol>
<li>不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。<ol>
<li>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</li>
</ol>
</li>
<li>count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</li>
<li>当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。<ol>
<li>正例：使用如下方式来避免 sum 的 NPE 问题：SELECT IFNULL(SUM(column), 0) FROM table;</li>
</ol>
</li>
<li>使用 ISNULL()来判断是否为 NULL 值。<ol>
<li>说明：NULL 与任何值的直接比较都为 NULL。 </li>
</ol>
</li>
<li>代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</li>
<li>不得使用外键与级联，一切外键概念必须在应用层解决。<ol>
<li>说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</li>
</ol>
</li>
<li>禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</li>
<li>数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认无误才能执行更新语句。</li>
<li>in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。</li>
<li>如果有国际化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。<ol>
<li>说明：如果需要存储表情，那么选择 utf8mb4 来进行存储，注意它与 utf-8 编码的区别。</li>
</ol>
</li>
<li>TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。</li>
</ol>
<h3 id="ORM映射"><a href="#ORM映射" class="headerlink" title="ORM映射"></a>ORM映射</h3><ol>
<li>在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。<ol>
<li>增加查询分析器解析成本。</li>
<li>增加查询分析器解析成本。</li>
<li>无用字段增加网络消耗，尤其是 text 类型的字段。</li>
</ol>
</li>
<li>POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。</li>
<li>不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个 POJO 类与之对应。</li>
<li>sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</li>
<li>iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。<ol>
<li>其实现方式是在数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList 取start,size 的子集合。</li>
</ol>
</li>
<li>不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</li>
<li>更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。</li>
<li>不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</li>
<li>@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</li>
<li>&lt; isEqual &gt;中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；&lt; isNotEmpty &gt;表示不为空且不为 null 时执行；&lt; isNotNull &gt;表示不为 null 值时执行。 </li>
</ol>
<h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><h3 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h3><h3 id="二方库依赖"><a href="#二方库依赖" class="headerlink" title="二方库依赖"></a>二方库依赖</h3><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><h2 id="设计规约"><a href="#设计规约" class="headerlink" title="设计规约"></a>设计规约</h2>]]></content>
  </entry>
  <entry>
    <title>商城项目（一）</title>
    <url>/2020/10/19/%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE1/</url>
    <content><![CDATA[<h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>暂时设计B2C，未来项目成熟后，转向C2C。</p>
<p>分布式基础部分</p>
<ol>
<li>分布式的基本概念<ul>
<li>微服务、注册中心、配置中心、feign远程调用、网关（统一配置跨域）</li>
</ul>
</li>
<li>基础开发<ul>
<li>Spring Boot 2.0 、Spring Cloud、Mybatis-Plus、Vue组件化、阿里云对象存储</li>
</ul>
</li>
<li>环境<ul>
<li>Linux、Docker、MySql、Redis、逆向工程&amp;人人开源</li>
</ul>
</li>
<li>开发规范<ul>
<li>数据校验JSR303、全局异常处理、全局统一返回、全局跨域处理</li>
<li>枚举状态、业务状态码、VO与TO与PO划分、逻辑删除</li>
<li>Lombok：@Data、@Slf4j</li>
</ul>
</li>
</ol>
<h2 id="项目技术特点："><a href="#项目技术特点：" class="headerlink" title="项目技术特点："></a>项目技术特点：</h2><p>前后端分离开发，开发基于vue的后台管理系统</p>
<p>SpringCloud全新的解决方案</p>
<p>应用监控、限流、网关、熔断降级等分布式方案，全方位涉及</p>
<p>分布式事务、分布式锁等分布式系统难题</p>
<p>高并发场景，线程池、异步编排等使用</p>
<p>压力测试，性能优化</p>
<p>各种集群技术使用</p>
<p>CI/CD使用</p>
<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>微服务：拒绝大型单体应用，基于业务边界进行服务强化拆分，服务独立部署运行。</p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>网络地址转换</p>
<h1 id="项目开始"><a href="#项目开始" class="headerlink" title="项目开始"></a>项目开始</h1><h2 id="1-安装服务器工具-docker-mysql-redis"><a href="#1-安装服务器工具-docker-mysql-redis" class="headerlink" title="1.安装服务器工具(docker,mysql,redis)"></a>1.安装服务器工具(docker,mysql,redis)</h2><ol>
<li><p>安装虚拟机</p>
<ol>
<li><p>安装VirtualBox</p>
</li>
<li><p>安装 vagrant 快速搭建虚拟机</p>
<ol>
<li><p>安装成功后重启系统。</p>
</li>
<li><p>cmd输入命令vagrant测试是否安装成功。</p>
</li>
<li><p>cmd输入vagrant init centos/7</p>
</li>
<li><p>cmd输入vagrant up 启动虚拟机（停止可以在VirtualBox中停止）</p>
</li>
<li><p>cmd输入vagrant ssh 链接上虚拟机</p>
<blockquote>
<p>vagrant reload   重启虚拟机</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
<li><p>安装docker</p>
<ol>
<li><p>卸载旧版本docke</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>下载</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>安装</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>启动</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>检查当前虚拟机的镜像</p>
<blockquote>
<p>$ sudo docker images</p>
</blockquote>
</li>
<li><p>设置开机自启动</p>
<blockquote>
<p>$ sudo systemctl enable docker</p>
</blockquote>
</li>
<li><p>配置镜像加速</p>
<blockquote>
<p>在阿里云查找镜像加速器</p>
<p>sudo mkdir -p /etc/docker</p>
<p>sudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’ </p>
<p>{</p>
<p> “registry-mirrors”: [“<a href="https://x7tuoc0z.mirror.aliyuncs.com&quot;]">https://x7tuoc0z.mirror.aliyuncs.com&quot;]</a> </p>
<p>} </p>
<p>EOF</p>
<p>sudo systemctl daemon-reload </p>
<p>sudo systemctl restart docker</p>
</blockquote>
</li>
<li><p>其他的使用</p>
<blockquote>
<p>如果遇到docker镜像重启无法使用，就重启docker</p>
<p>systemctl restart docker</p>
<p>查看正在运行中的容器</p>
<p>docker ps</p>
<p>查看全部容器</p>
<p>docker ps -a</p>
<p>删除容器</p>
<p>docker rm -f 容器名</p>
<p>docker rmi 容器名</p>
<p>停止容器</p>
<p>docker stop 容器id</p>
<p>启动容器</p>
<p>docker start 容器id</p>
<p>删除镜像</p>
<p>docker rmi mysql:8.0</p>
<p>重启容器</p>
<p>docker restart 容器名</p>
<p>设置容器开机自启</p>
<p>docker update –restart=always 容器名</p>
</blockquote>
</li>
</ol>
</li>
<li><p>docker安装mysql</p>
<ol>
<li><p>mysql57</p>
<ol>
<li><p>下载MySQL57镜像</p>
<blockquote>
<p>docker pull mysql:5.7</p>
</blockquote>
</li>
<li><p>创建my.cnf文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /mydata/mysql57/conf/</span><br><span class="line">touch /mydata/mysql57/conf/my.cnf</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   [client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">   </span><br><span class="line">[mysql]</span><br><span class="line">   default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">   init_connect=&#x27;SET collation_connection=utf8_unicode_ci&#x27;</span><br><span class="line">   init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line">   character-set-server=utf8</span><br><span class="line">   collation-server=utf8_unicode_ci</span><br><span class="line">   skip-character-set-client-handshake</span><br><span class="line">   skip-name-resolve</span><br><span class="line">   max_connections=1500</span><br></pre></td></tr></table></figure></li>
<li><p>安装</p>
<blockquote>
<p>docker run -p 3306:3306 –name mysql57 <br>-v /mydata/mysql57/log:/var/log/mysql <br>-v /mydata/mysql57/data:/var/lib/mysql <br>-v /mydata/mysql57/conf:/etc/mysql <br>-e MYSQL_ROOT_PASSWORD=Aa19990804 <br>-d mysql:5.7</p>
</blockquote>
<blockquote>
<p>docker run -p 3306:3306 –name mysql57 -v $PWD/conf:/etc/mysql/conf.d -v $PWD/log:/logs -v $PWD/data:/mysql_data -e MYSQL_ROOT_PASSWORD=Aa19990804 -d mysql:5.7</p>
</blockquote>
<ol start="4">
<li><p>进入容器</p>
<blockquote>
<p>docker exec -it mysql57 /bin/bash</p>
</blockquote>
</li>
</ol>
</li>
<li><p>mysql8</p>
<ol>
<li><p>下载MySQL8.0镜像</p>
<blockquote>
<p>docker pull mysql:8.0</p>
</blockquote>
</li>
<li><p>创建my.cnf文件</p>
<blockquote>
<p>vi /mydata/mysql8/conf/my.cnf</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      [mysqld]</span><br><span class="line">      pid-file        = /var/run/mysqld/mysqld.pid</span><br><span class="line">      socket          = /var/run/mysqld/mysqld.sock</span><br><span class="line">      datadir         = /var/lib/mysql</span><br><span class="line">      secure-file-priv= NULL</span><br><span class="line">      # Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">      symbolic-links=0</span><br><span class="line"></span><br><span class="line">      # Custom config should go here</span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br><span class="line">      </span><br><span class="line">      default_authentication_plugin= mysql_native_password</span><br></pre></td></tr></table></figure></li>
<li><p>安装</p>
<blockquote>
<p>docker run <br>-p 3307:3306 <br>-e MYSQL_ROOT_PASSWORD=root <br>-v /mydata/mysql8/data:/var/lib/mysql:rw <br>-v /mydata/mysql8/log:/var/log/mysql:rw <br>-v /mydata/mysql8/conf/my.cnf:/etc/mysql/my.cnf:rw <br>-v /etc/localtime:/etc/localtime:ro <br>–name mysql8 <br>–restart=always <br>-d mysql:8.0</p>
</blockquote>
</li>
<li><p>进入容器</p>
<blockquote>
<p>docker exec -it mysql8 /bin/bash</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
<li><p>docker安装redis</p>
<ol>
<li><p>下载镜像</p>
<blockquote>
<p>docker pull redis</p>
</blockquote>
</li>
<li><p>创建配置</p>
<blockquote>
<p>mkdir -p /mydata/redis/conf</p>
<p>touch /mydata/redis/conf/redis.conf </p>
</blockquote>
</li>
<li><p>运行容器</p>
<blockquote>
<p>docker run -p 6379:6379 –name redis -v /mydata/redis/data:/data -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf</p>
</blockquote>
</li>
<li><p>开启redis客户端</p>
<blockquote>
<p>docker exec -it redis redis-cli</p>
<p>redis默认是没有持久化的，数据存储在内存中。</p>
</blockquote>
</li>
<li><p>在Linux中编辑redis.conf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">让redis启用aof的持久化方式</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="2-安装电脑工具"><a href="#2-安装电脑工具" class="headerlink" title="2. 安装电脑工具"></a>2. 安装电脑工具</h2><p>完成navicat，redisdesktopmanager，idea，vxcode，maven，git工具的安装与配置</p>
<h2 id="3-搭建脚手架"><a href="#3-搭建脚手架" class="headerlink" title="3. 搭建脚手架"></a>3. 搭建脚手架</h2><ol>
<li><p>在码云创建一个仓库java,maven。</p>
</li>
<li><p>在idea中新建Project from version control</p>
</li>
<li><p>创建项目微服务</p>
<ol>
<li>```txt<br>共同点：<ol>
<li>web，openfeign</li>
<li>每个服务，包名com.genuine.wmall.xxx(product/order/ware/coupon/member)</li>
<li>模块名：wmall-<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   2. 创建所有模块module，使用spring快速搭建，由于是**微服务**，必要的两个依赖web的**springweb**和**springcloudrouting的openfeign**</span><br><span class="line"></span><br><span class="line">4. 在wmall中创建并编辑pom.xml</span><br><span class="line"></span><br><span class="line">   关联各个微服务</span><br><span class="line"></span><br><span class="line">   ```xml</span><br><span class="line">   &lt;groupId&gt;com.genuine.wmall&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;wmall&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">       &lt;name&gt;wmall&lt;/name&gt;</span><br><span class="line">       &lt;description&gt;聚合服务&lt;/description&gt;</span><br><span class="line">   	&lt;!-- 使用maven分模块管理 一般所有父级项目的packaging都为pom，packaging默认类型jar类型，如果不做配置，maven会将该项目打成jar包。 --&gt;</span><br><span class="line">       &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">       &lt;modules&gt;</span><br><span class="line">           &lt;module&gt;wmall-coupon&lt;/module&gt;</span><br><span class="line">           &lt;module&gt;wmall-member&lt;/module&gt;</span><br><span class="line">           &lt;module&gt;wmall-order&lt;/module&gt;</span><br><span class="line">           &lt;module&gt;wmall-product&lt;/module&gt;</span><br><span class="line">           &lt;module&gt;wmall-ware&lt;/module&gt;</span><br><span class="line">       &lt;/modules&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>在maven中添加wmall模块（默认使root模块）。</p>
</li>
<li><p>在wmall中的.gitignore（git的模板，可以忽视垃圾文件）</p>
<p><strong>忽略设置：使git不上传远程仓库规定文件</strong></p>
<p>只将有用的代码纳入版本控制（Add VCS）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**/  -- 代表任意目录</span><br><span class="line"></span><br><span class="line">**/mvnw</span><br><span class="line">**/mvnw.cmd</span><br><span class="line">**/.mvn</span><br><span class="line">**/target</span><br><span class="line">.idea</span><br><span class="line">**/.gitignore</span><br></pre></td></tr></table></figure></li>
<li><p>设计数据库</p>
<p>设计表，创建表。</p>
<p>在电商项目中表与表之间不做外键。</p>
<p>每一个服务创建自己的数据库。</p>
</li>
<li><p><strong>反向创建代码</strong></p>
<p>自动创建数据库实体类，dao层，service层</p>
<ol>
<li><p>构建数据库</p>
</li>
<li><p>下载人人开源的renren-fast和renren-fast-vue项目。</p>
</li>
<li><p>将两个项目的.git文件夹删掉</p>
</li>
<li><p>将renren-fast项目放入后台项目中，加入modules中，并创建数据库，之后可以运行测试。</p>
</li>
<li><p>使用vscode打开renren-fast-vue项目。</p>
<blockquote>
<p>npm install</p>
<p>npm run duv</p>
</blockquote>
</li>
<li><p>登录账户密码：admin   admin</p>
</li>
<li><p>下载并安装代码生成器renren-generator项目，放入wmall项目中，加入modules中，修改application.yml文件中的数据库配置。修改generator.properties文件中的配置</p>
<blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mainPath</span>=<span class="string">com.genuine</span></span><br><span class="line"><span class="attr">package</span>=<span class="string">com.genuine.wmall</span></span><br><span class="line"><span class="attr">moduleName</span>=<span class="string">product</span></span><br><span class="line"><span class="attr">author</span>=<span class="string">xuanhuanxingkong8</span></span><br><span class="line"><span class="attr">email</span>=<span class="string">xuanhuanxingkong8@gmail.com</span></span><br><span class="line"><span class="attr">tablePrefix</span>=<span class="string">pms</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>运行代码生成器服务</p>
</li>
<li><p>根据数据库的表，生成代码，导入到项目中。</p>
</li>
<li><p>修改程序中的报错的问题，将公共工具放到common模块中。</p>
</li>
<li><p><strong>整合MyBatis-Plus</strong></p>
<ol>
<li><p>导入依赖</p>
</li>
<li><p>配置</p>
<ol>
<li><p>配置数据源</p>
<ol>
<li><p>导入数据库驱动</p>
</li>
<li><p>配置数据源相关信息</p>
</li>
<li><p>配置MyBatis-Plus</p>
<pre><code>1. 使用@MapperScan
  
2. 告诉MyBatis-Plus，sql映射文件位置
  
   <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://81.70.204.157:3306/gulimall_pms</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="comment"># 表主键自增</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># mapper-locations: classpath*:/mapper/**/*.xml</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/**/*.xml</span></span><br></pre></td></tr></table></figure>
  
   classpath后*表示任意模块路径下的mapper的任意路径下的任意.xml结尾的文件。
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="4-微服务"><a href="#4-微服务" class="headerlink" title="4. 微服务"></a>4. 微服务</h2><p>技术搭配方案：</p>
<p>Nacos：注册中心（服务发现/注册）</p>
<p>Nacos：配置中心（动态配置管理）</p>
<p>Ribbon：负载均衡</p>
<p>Feign：声明式HTTP客户端（调用远程服务）</p>
<p>Sentinel：服务容错（限流、降级、熔断）</p>
<p>Gateway：API网关（webflux编程模式）</p>
<p>Sleuth：调用链监控</p>
<p>Seata：原Fescar，分布式事务解决方案</p>
<h3 id="Nacos注册中心和OpenFeign远程调用"><a href="#Nacos注册中心和OpenFeign远程调用" class="headerlink" title="Nacos注册中心和OpenFeign远程调用"></a>Nacos注册中心和OpenFeign远程调用</h3><ol>
<li><p>分布式组件spring cloud alibaba</p>
<p>导入依赖：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>下载nacos服务器（注册中心、配置中心），并启动服务。</p>
<p><strong>在项目配置文件中配置Nacos Server地址和当前服务名</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8848</span></span><br><span class="line">  application:</span><br><span class="line">    name: 项目名</span><br></pre></td></tr></table></figure>

<p><strong>使用@EnableDiscoveryClient注解开启服务注册与发现功能</strong></p>
<p>运行项目</p>
</li>
<li><p>Feign声明式远程调用</p>
<p>简介：Feign是一个声明式的HTTP客户端。整合了Ribbon（负载均衡）和Hystrix（服务熔断）。</p>
<p>步骤：</p>
<ol>
<li><p>引入open-feign</p>
</li>
<li><p>编写一个接口，需要调用远程服务</p>
<ol>
<li><p>声明接口的每一个方法都是调用那个远程服务的请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被调用方 类中</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/member/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">membercoupons</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">CouponEntity</span> <span class="variable">couponEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CouponEntity</span>();</span><br><span class="line">    couponEntity.setCouponName(<span class="string">&quot;满100减10&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> R.ok().put(<span class="string">&quot;coupons&quot;</span>,Arrays.asList(couponEntity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用远程服务的服务名</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;wmall-coupon&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CouponFeignService</span> &#123;</span><br><span class="line">    <span class="comment">//使用接口的完整签名</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/coupon/coupon/member/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">membercoupons</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">调用方 类中</span><br><span class="line">   </span><br><span class="line">   ```java</span><br><span class="line">   //test调用方 类中</span><br><span class="line">   @Autowired</span><br><span class="line">   CouponFeignService couponFeignService;</span><br><span class="line">   </span><br><span class="line">   @RequestMapping(&quot;/coupons&quot;)</span><br><span class="line">public R test()&#123;</span><br><span class="line">       MemberEntity memberEntity = new MemberEntity();</span><br><span class="line">    memberEntity.setNickname(&quot;张三&quot;);</span><br><span class="line">       R membercoupons = couponFeignService.membercoupons();</span><br><span class="line">       return R.ok().put(&quot;member&quot;,memberEntity).put(&quot;coupons&quot;,membercoupons.get(&quot;coupons&quot;));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>调用方 启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启远程调用功能 自动扫描 全包名</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.genuine.wmall.member.feign&quot;)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WmallMemberApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(WmallMemberApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在浏览器发送请求：localhost:8000/member/member/coupons</p>
<p>附：如果服务停止，前端会显示，连接超时。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h3><ol>
<li><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用配置中心做配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个bootstrap.properties文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">wmall-coupon项目名</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br></pre></td></tr></table></figure></li>
<li><p>给配置中心默认添加一个 数据集（Data Id）。 默认规则：应用名.properties</p>
</li>
<li><p>给 应用名.properties 添加任何配置</p>
</li>
<li><p>动态获取配置。</p>
<ol>
<li><p>@RefreshScope 动态获取，并刷新配置。可应用在控制器类名上</p>
</li>
<li><p>@Value(${配置项名})  获取到配置</p>
<p>当配置中心和当前应用都配置了相同的项，优先使用配置中心的配置。</p>
</li>
</ol>
</li>
<li><p>细节：</p>
<ol>
<li><p>命名空间：配置隔离：</p>
<p>默认：public（保留空间）</p>
<p>基于不同环境隔离：开发，测试，生产：利用命名空间做环境隔离。</p>
<p>注意：在bootstrap.properties中配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string">bf179235-e27b-42e6-b162-8b598e0a2bae</span></span><br></pre></td></tr></table></figure>

<p><strong>基于微服务隔离</strong>：每一个微服务之间互相隔离配置，每一个微服务都创建自己的命名空间，只加载自己明明空间下的所有配置。</p>
</li>
<li><p>配置集：所有的配置的集合。</p>
</li>
<li><p>配置集id：类似于文件名。就是Data ID</p>
</li>
<li><p>配置分组：默认所有配置集都属于：DEFAULT_GROUP</p>
<p><strong>每个微服务创建自己的命名空间，使用配置分组区分环境。</strong> 分组：dev、prod</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.config.group</span>=<span class="string">dev Group名</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>同时加载多个配置集</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置集id</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[0].data-id</span>=<span class="string">datasource.yml</span></span><br><span class="line"><span class="comment"># 配置分组</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[0].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="comment"># 启动配置刷新</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[0].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[1].data-id</span>=<span class="string">mybatis.yml</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[1].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[1].refresh</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">...</span></span><br></pre></td></tr></table></figure>

<ol>
<li>微服务任何配置信息，任何配置文件都可以放在配置中心中。</li>
<li>只需要在bootstrap.properties说明加载配置中心的哪些配置文件即可。</li>
<li>SpringBoot任何方法从配置文件中获取值，都能使用配置中心获取文件。</li>
</ol>
</li>
</ol>
<h3 id="API网关-Gateway"><a href="#API网关-Gateway" class="headerlink" title="API网关 Gateway"></a>API网关 Gateway</h3><p>分布式开发中需要api网关：</p>
<ol>
<li>实时的接受注册中心的服务是否上线，将请求转发到正确的目标服务。</li>
<li>不将登录校验的功能分布到每一个服务上，在网关服务上实现。</li>
</ol>
<p><strong>Gateway简介</strong>：</p>
<p>网关作为流量的入口，常用功能包括 <strong>路由转发、权限校验、限流控制等</strong>，而spring cloud gateway 作为SpringCloud官方推出的第二代网关框架，取代了Zuul网关。</p>
<p>（每秒能处理三万多的请求，请求到达网关，通过断言，是否符合路由规则，然后经过filter路由到指定地方） </p>
<p>学习Gateway，在官方文档中学习与使用。</p>
<p>断言：判断请求是否符合路由规则，符合就经过一系列filter过滤后到达指定地点。</p>
<ol>
<li><p>新建网关项目，仅依赖网关gateway</p>
</li>
<li><p>依赖common工程，注册到common中</p>
</li>
<li><p>统一gateway的spring版本与springcloud版本</p>
</li>
<li><p>开启服务注册发现（配置服务信息）</p>
<p>启动类中添加@EnableDiscoveryClient</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.properties 配置nacos注册中心</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">wmall-gateway</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">88</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bootstrap.properties 配置nacos配置中心</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string">da468fd0-0579-4ac8-b473-f93211213424</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.group</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">wmall-coupon</span></span><br></pre></td></tr></table></figure>

<p>有需要时，在配置中心配置</p>
<p>启动网关的时候会遇到数据源相关的错误，网关排除掉跟数据库相关的自动配置 @SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</p>
<p>网关是基于Netty启动的。</p>
<p>请求转发：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">test_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Query=baz</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">qq_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.qq.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Query=url,</span> <span class="string">qq</span></span><br></pre></td></tr></table></figure>

<p>浏览器输入localhost:88/?baz 会跳转到百度页面</p>
<p>输入localhost:88/?url=qq 会跳转到qq页面</p>
</li>
</ol>
<h1 id="项目问题待解决"><a href="#项目问题待解决" class="headerlink" title="项目问题待解决"></a>项目问题待解决</h1><h3 id="Maven-plugins-爆红，无法导入"><a href="#Maven-plugins-爆红，无法导入" class="headerlink" title="Maven plugins 爆红，无法导入"></a>Maven plugins 爆红，无法导入</h3><h3 id="springcloud版本问题"><a href="#springcloud版本问题" class="headerlink" title="springcloud版本问题"></a>springcloud版本问题</h3><p>已解决，我已经全部换成:</p>
<p>spring-boot-starter-parent 2.1.3.RELEASE</p>
<p>spring-cloud.version Greenwich.SR3</p>
<ol>
<li><p>gulimall-common</p>
</li>
<li><p>gulimall-coupon<br>spring-boot-starter-parent 2.4.1<br>spring-cloud.version 2020.0.0-M6</p>
</li>
<li><p>gulimall-member<br>spring-boot-starter-parent 2.3.4.RELEASE<br>spring-cloud.version Greenwich.SR3</p>
</li>
<li><p>gulimall-order</p>
<p>spring-boot-starter-parent 2.4.1<br>spring-cloud.version 2020.0.0-M6</p>
</li>
<li><p>gulimall-product</p>
<p>spring-boot-starter-parent 2.3.5.RELEASE<br>spring-cloud.version Greenwich.SR3</p>
</li>
<li><p>gulimall-ware</p>
<p>spring-boot-starter-parent 2.4.1<br>spring-cloud.version 2020.0.0-M6</p>
</li>
</ol>
<h3 id="Java解决Excel（POI）"><a href="#Java解决Excel（POI）" class="headerlink" title="Java解决Excel（POI）"></a>Java解决Excel（POI）</h3><p>已解决，如果maven阿里云仓库没有最新的依赖，阿里云将会去国外中央仓库下载</p>
]]></content>
      <tags>
        <tag>商城</tag>
        <tag>springclooud</tag>
        <tag>gateway</tag>
        <tag>docker</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装Mysql 8.0</title>
    <url>/2020/08/27/Linux/Linux%E5%AE%89%E8%A3%85Mysql%208.0/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/xiexinxx0225/article/details/107665316" title="参考连接">https://blog.csdn.net/xiexinxx0225/article/details/107665316</a>  </p>
<h2 id="卸载MariaDB"><a href="#卸载MariaDB" class="headerlink" title="卸载MariaDB"></a>卸载MariaDB</h2><p>MariaDB是Linux默认数据库，需先卸载。  </p>
<ol>
<li>使用 yum list installed | grep mariadb 检查MariaDB是否安装。</li>
<li>使用 yum -y remove mariadb* 命令 卸载</li>
</ol>
<h2 id="删除MySQL对应的文件夹"><a href="#删除MySQL对应的文件夹" class="headerlink" title="删除MySQL对应的文件夹"></a>删除MySQL对应的文件夹</h2><ol>
<li><p>whereis mysql</p>
</li>
<li><p>find / -name musql</p>
<pre><code> [root@localhost /]# whereis mysql
 mysql: /usr/bin/mysql /usr/include/mysql
 [root@localhost lib]# find / -name mysql
 /data/mysql
 /data/mysql/mysql
</code></pre>
</li>
</ol>
<ol start="3">
<li><p>删除上两条命令查询出来的相关目录或文件。</p>
<pre><code> [root@localhost /]#  rm -rf /usr/bin/mysql /usr/include/mysql /data/mysql /data/mysql/mysql 
</code></pre>
</li>
<li><p>重复输入1、2命令，是否删除完毕。</p>
</li>
</ol>
<h2 id="检查MySQL用户组和用户是否存在，如果没有，则创建"><a href="#检查MySQL用户组和用户是否存在，如果没有，则创建" class="headerlink" title="检查MySQL用户组和用户是否存在，如果没有，则创建"></a>检查MySQL用户组和用户是否存在，如果没有，则创建</h2><pre><code>[root@localhost /]# cat /etc/group | grep mysql
[root@localhost /]# cat /etc/passwd |grep mysql
[root@localhost /]# groupadd mysql
[root@localhost /]# useradd -r -g mysql mysql
[root@localhost /]#
</code></pre>
<h2 id="命令下载Linux的Mysql安装包"><a href="#命令下载Linux的Mysql安装包" class="headerlink" title="命令下载Linux的Mysql安装包"></a>命令下载Linux的Mysql安装包</h2><pre><code>[root@localhost ~]#  wget https://cdn.mysql.com/archives/mysql-8.0/mysql-8.0.19-linux-glibc2.12-x86_64.tar.xz
</code></pre>
<h1 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h1><h2 id="解压安装包"><a href="#解压安装包" class="headerlink" title="解压安装包"></a>解压安装包</h2><pre><code>[root@localhost /]#  tar xvf mysql-8.0.19-linux-glibc2.12-x86_64.tar.xz
[root@localhost /]# ls
mysql-8.0.19-linux-glibc2.12-x86_64
mysql-8.0.19-linux-glibc2.12-x86_64.tar.xz
</code></pre>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol>
<li>首先确保/usr/local/下没有mysql文件夹，如果有就删除  </li>
<li>执行移动命令  <pre><code> [root@localhost ~]# mv mysql-8.0.19-linux-glibc2.12-x86_64 /usr/local/mysql
</code></pre>
</li>
</ol>
<ol start="3">
<li><p>在/usr/local/mysql目录下创建data目录  </p>
<pre><code> [root@localhost /]# mkdir /usr/local/mysql/data
</code></pre>
</li>
<li><p>更改mysql目录下所有的目录及文件夹所属的用户组和用户，以及权限  </p>
<pre><code> [root@localhost /]# chown -R mysql:mysql /usr/local/mysql
 [root@localhost /]# chmod -R 755 /usr/local/mysql 
</code></pre>
</li>
<li><p>下载链接库文件  </p>
<pre><code> [root@localhost bin]#  yum -y install libaio-devel.x86_64
</code></pre>
</li>
<li><p>编译安装并初始化mysql,务必记住初始化输出日志末尾的密码（数据库管理员临时密码）  </p>
<pre><code> [root@localhost /]# cd /usr/local/mysql/bin
 [root@localhost bin]# ./mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql
</code></pre>
</li>
<li><p>编辑配置文件my.cnf，添加配置如下</p>
<pre><code> [root@localhost bin]#  vi /etc/my.cnf

 [mysqld]
 datadir=/usr/local/mysql/data
 port=3306
 sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
 symbolic-links=0
 max_connections=600
 innodb_file_per_table=1
 log-error=/usr/local/mysql/data/error.log
</code></pre>
</li>
<li><p>测试启动mysql服务器</p>
<pre><code> [root@localhost /]# /usr/local/mysql/support-files/mysql.server start
</code></pre>
</li>
<li><p>添加软连接，并重启mysql服务</p>
<pre><code> [root@localhost /]#  ln -s /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql 
 [root@localhost /]#  ln -s /usr/local/mysql/bin/mysql /usr/bin/mysql
 [root@localhost /]#  service mysql restart  
</code></pre>
</li>
<li><p>登录mysql，修改密码(密码为步骤6生成的临时密码)</p>
<pre><code>[root@localhost /]#  mysql -u root -p
Enter password:
mysql&gt;ALTER USER USER() IDENTIFIED BY &#39;yourpass&#39;;
mysql&gt;flush privileges;
</code></pre>
</li>
<li><p>开放远程连接  </p>
<pre><code>mysql&gt;use mysql;
msyql&gt;update user set user.Host=&#39;%&#39; where user.User=&#39;root&#39;;
mysql&gt;flush privileges; 
</code></pre>
</li>
</ol>
<ol start="12">
<li><p>必须修改加密规则  </p>
<pre><code>1.输入 use mysql; 出现Database changed
2.输入select user,host from user; 目的为了查看user的root 对应host是什么  我对应的是 %
3.修改加密规则：输入ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;

root:为数据库用户名
123456：为数据库密码
</code></pre>
</li>
</ol>
<ol start="13">
<li><p>可以自由设置开机自动启动</p>
<pre><code>1、将服务文件拷贝到init.d下，并重命名为mysql
[root@localhost /]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld
2、赋予可执行权限
[root@localhost /]# chmod +x /etc/init.d/mysqld
3、添加服务
[root@localhost /]# chkconfig --add mysqld
4、显示服务列表
[root@localhost /]# chkconfig --list
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>安装</category>
      </categories>
      <tags>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中char与varchar</title>
    <url>/2021/04/13/MySQL/20210413-MySQL%E4%B8%ADchar%E4%B8%8Evarchar/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>使用MySQL创建数据库表结构时，为了给字符串类型的数据定义数据类型，一般使用的都是char或者varchar。但使用过程中，比如模糊查询‘like’的使用，有感受到他们之间的不同。</p>
<p>那么他们到底有什么区别，特性以及适用范围呢？</p>
<h1 id="一、char"><a href="#一、char" class="headerlink" title="一、char"></a>一、char</h1><p>char：定长字符串</p>
<h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ol>
<li>存储空间固定。</li>
<li>长度不够时，内部存储使用空格填充。</li>
<li>若数据末尾存在空格，检索出来自动截断末尾空格。（无法区分空格是数据的还是自动填充的）</li>
<li>若数据前端存在空格，不会截断。</li>
<li>当数据的字符长度超过指定长度时，char会截断超出的字符。</li>
</ol>
<h2 id="使用情况："><a href="#使用情况：" class="headerlink" title="使用情况："></a>使用情况：</h2><ul>
<li>适合存储很短的或者长度接近同一个长度的字符串。</li>
<li>char比varchar在存取上更具效率，因为它是固定长度。</li>
<li>对于非常短的列，char比varchar在存储空间上更有效率。</li>
</ul>
<h1 id="二、varchar"><a href="#二、varchar" class="headerlink" title="二、varchar"></a>二、varchar</h1><p>varchar：可变长字符串</p>
<h2 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h2><ol>
<li>存储空间不固定，根据数据长度决定。</li>
<li>需要格外的1个或2个字节记录字符串的长度，字符串长度小于255字节使用1个字节，否则使用2个。</li>
<li>最大长度为65535字节</li>
<li>如果列为null，则需要额外一个自己作为标志。</li>
<li>最大长度 = 字段长度 + 【长度记录（1或2字节）或 null标志位1字节】</li>
</ol>
<h2 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h2><ul>
<li>字符串列的最大长度比平均长度大很多</li>
<li>使用了像utf-8这样复杂的数据集，每个字符都用不同的字节数存储。</li>
</ul>
<h1 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h1><ul>
<li>取数据的时候，char类型会去掉末尾多余的空格，而varchar是不会的。</li>
<li>时间与空间效率<ul>
<li>char的存取数度要比varchar要快得多</li>
<li>varchar 空间利用率要比char 更充分</li>
</ul>
</li>
<li>存储方式：<ul>
<li>char的存储方式是，对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节</li>
<li>varchar的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节。</li>
<li>两者的存储数据都非unicode的字符数据。</li>
</ul>
</li>
</ul>
<p>所以，从空间上考虑，varcahr较合适；从效率上考虑，用char合适。如何使用，还需要根据实际情况查询</p>
<p>参考地址：<a href="https://blog.csdn.net/weixin_43054397/article/details/91126605">https://blog.csdn.net/weixin_43054397/article/details/91126605</a></p>
]]></content>
      <categories>
        <category>mysql</category>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/2020/11/28/Linux/Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -iname &quot;node&quot;</span><br><span class="line">find / -type &quot; *.config &quot;</span><br></pre></td></tr></table></figure>

<h2 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://...</span><br></pre></td></tr></table></figure>

<h2 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h2><ul>
<li><p>tar.gz</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf xxx</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [源] [目标地址]</span><br></pre></td></tr></table></figure>

<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm xxx</span><br><span class="line">强制删除</span><br><span class="line">rm -f xxx</span><br><span class="line">删除文件夹</span><br><span class="line">rm -rf xxx</span><br><span class="line"></span><br><span class="line">排除显示当前文件夹的文件并未被排除的文件</span><br><span class="line">ls | grep -v cJKmhpmERdSoFhCX_Fm9yw | grep -v x9kg3vvoQZSzTLSt4m9BuQ | grep -v VVNb4OKkSoOTinXw7vSMsQ | grep -v pZrsvW6TRNqs_qXigFYkpA | grep -v yd4BNfvSS1enINMdeWNAyg |  xargs rm -rf</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="查看剩余空间"><a href="#查看剩余空间" class="headerlink" title="查看剩余空间"></a>查看剩余空间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>

<h2 id="启动软件命令"><a href="#启动软件命令" class="headerlink" title="启动软件命令"></a>启动软件命令</h2><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">非root用户     ./elasticsearch -d</span><br></pre></td></tr></table></figure>

<h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">非root用户		nohup ./kibana &amp;</span><br></pre></td></tr></table></figure>

<h1 id="重要命令"><a href="#重要命令" class="headerlink" title="重要命令"></a>重要命令</h1><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>Linux grep 命令用于查找文件里符合条件的字符串。</p>
<p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把<strong>含有范本样式</strong>的那<strong>一列显示</strong>出来。若不指定任何文件名称，或是所给予的文件名为 **-**，则 grep 指令会从标准输入设备读取数据。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示行数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</span><br></pre></td></tr></table></figure>

<p><strong>该命令经常以管道的方式使用：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat default.conf | grep -n  &quot;is&quot; | grep 127</span><br></pre></td></tr></table></figure>

<p>管道的意思就是将<code>|</code>前面命令的结果作为后面命令的输入内容。</p>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li><strong>-n 或 –line-number</strong> : 在显示符合样式的那一行之前，标示出该行的列数编号。</li>
<li><strong>-o 或 –only-matching</strong> : 只显示匹配PATTERN 部分。</li>
<li><strong>-v 或 –invert-match</strong> : 显示不包含匹配文本的所有行。</li>
</ul>
<h1 id="系统操作"><a href="#系统操作" class="headerlink" title="系统操作"></a>系统操作</h1><h3 id="开机选项"><a href="#开机选项" class="headerlink" title="开机选项"></a>开机选项</h3><p>启动虚拟机会有两个选项</p>
<p><img src="https://i.loli.net/2020/12/11/OGVxFNMA7BI8lRc.png" alt="image.png"></p>
<p>第一个是正常启动</p>
<p>第二个是修改模式启动（出现问题的时候使用）</p>
<h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><p>立即关机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown now</span><br></pre></td></tr></table></figure>

<p>10分钟后关机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown -h 10</span><br></pre></td></tr></table></figure>

<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>立即重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown -r now</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p>十分钟后重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown -r 10</span><br></pre></td></tr></table></figure>

<h3 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol>
<li><p>开机root登录</p>
</li>
<li><p>安装X（X Window System）命令：</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum groupinstall &quot;X Windwo System&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装图形界面软件GNOME Desktop命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum groupinstall &quot;GNOME Desktop&quot;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>安装完成，输入命令<code>startx</code>或者 <code>init 3</code>来进入图形界面，输入命令<code>init 5</code>进入命令行界面</li>
</ol>
<h4 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h4><p>查询当前所设定的状态。</p>
<p>multi-user.target 相当于以前的 level 3，也就是命令行终端；而 graphical.target 相当于以前的 level 5，也就是图形界面。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl get-default</span><br></pre></td></tr></table></figure>

<p>开机以命令模式启动，执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure>

<p>开机以图形界面启动，执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl set-default graphical.target</span><br></pre></td></tr></table></figure>

<h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><ol>
<li><p>root修改密码</p>
<p>直接输入passwd修改</p>
</li>
<li><p>用户修改密码</p>
<p>root用户输入passwd 用户名</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中text类型</title>
    <url>/2021/04/13/MySQL/20210413-MySQL%E4%B8%ADtext%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="text类型"><a href="#text类型" class="headerlink" title="text类型"></a>text类型</h1><p>TEXT类型一般分为 TINYTEXT(255长度)、TEXT(65535)、 MEDIUMTEXT（int最大值16M），和LONGTEXT(long最大值4G)这四种，它被用来存储非二进制字符集，二进制字符集使用blob类型的字段来存储。</p>
<p>对于text列，插入时MySQL不会对它进行填充，并且select时不会删除任何末尾的字节。</p>
<p>如果text列被作为索引，则在它的内容后面添加空格时，会出现duplicate key错误，也就是说，如果我们定义了一个作为索引的text字段，它的值是’a’,则不能定义一个值为’a ‘的记录，因为这样会产生冲突。</p>
<p>对text列进行排序的时候，决定顺序的字符个数是由参数max_sort_length来决定的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> max_sort_length<span class="operator">=</span><span class="number">1000</span>; </span><br><span class="line"><span class="keyword">SELECT</span> id,comment <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> comment;</span><br></pre></td></tr></table></figure>

<h1 id="text和varchar的区别"><a href="#text和varchar的区别" class="headerlink" title="text和varchar的区别"></a>text和varchar的区别</h1><p>在大多数情况下，我们可以把text视为varchar字段，但是这两个字段类型在存储字符大小上有一些区别：</p>
<p>varchar在mysql中必须满足最大行宽度限制，也就是 65535(64k)字节，而varchar本身是按字符串个数来定义的,在mysql中使用uft-8字符集一个中文字符占用三个字节，所以单表varchar实际占用最大长度如下：<br>   1.使用utf-8字符编码集varchar最大长度是(65535-2)/3=21844个字符（超过255个字节会有2字节的额外占用空间开销，所以减2,如果是255以下,则减1）。<br>   2.使用 utf-8mb4字符集，mysql中使用 utf-8mb4 字符集一个中文字符占用4个字节，所以 varchar 最大长度是(65535-2)/4=16383 个字符（超过255个字节会有2字节的额外占用空间开销，所以减2,如果是255以下,则减1）。</p>
<p>text的最大限制也是64k个字节,但是本质是溢出存储,innodb默认只会存放前768字节在数据页中,而剩余的数据则会存储在溢出段中。text类型的数据,将被存储在元数据表之外地方,但是varchar/char将和其他列一起存储在表数据文件中，值得注意的是，varchar列在溢出的时候会自动转换为text类型。text数据类型实际上将会大幅度增加数据库表文件尺寸。</p>
<p>1、当text作为索引的时候，必须 制定索引的长度，而当varchar充当索引的时候，可以不用指明。</p>
<p>2、text列不允许拥有默认值</p>
<p>3、当text列的内容很多的时候，text列的内容会保留一个指针在记录中，这个指针指向了磁盘中的一块区域，当对这个表进行select *的时候，会从磁盘中读取text的值，影响查询的性能，而varchar不会存在这个问题。</p>
<p>参考地址：<a href="https://www.cnblogs.com/wqbin/p/11927456.html">https://www.cnblogs.com/wqbin/p/11927456.html</a></p>
]]></content>
      <categories>
        <category>mysql</category>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL范式</title>
    <url>/2021/04/13/MySQL/20210413-MySQL%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><ol>
<li><p>第一范式（1NF）：无重复的列。</p>
<ol>
<li><p>所谓第一范式（<em>1NF</em>）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值</p>
</li>
<li><p>不满足第一范式（<em>1NF</em>）的数据库就不是关系数据库。</p>
</li>
<li><p>现有的<em>DBMS</em>中设计出不符合第一范式的数据库都是不可能的。</p>
</li>
<li><p>例如：不应出现下图情况</p>
<p><img src="https://i.loli.net/2021/04/13/ctRGjyQ9DH3UizJ.png" alt="image-20210413172703618"></p>
</li>
</ol>
</li>
<li><p>第二范式（2NF）：非主属性完全依赖于主键。（消除部分子函数依赖）</p>
<ol>
<li>为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。</li>
<li>不应使用关键字为组合关键字。</li>
<li>例如：*(<em>学号</em>,* 课程名称*)* → <em>(<em>姓名</em>,</em> 年龄*,* 成绩*,* 学分*)*，不应使用组合关键字</li>
</ol>
</li>
<li><p>第三范式（3NF）：属性不依赖于其它非主属性。（消除传递依赖）</p>
<ol>
<li>第三范式（<em>3NF</em>）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。</li>
<li>例如：员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。</li>
</ol>
</li>
<li><p>BCNF：3NF改进</p>
<ol>
<li>数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合鲍依斯*-*科得范式。</li>
<li>例如：*(<em>仓库</em>ID)* → <em>(<em>管理员ID)并且</em>(<em>管理员</em>ID)</em> → *(<em>仓库</em>ID)*不应赶在一张表中</li>
</ol>
</li>
</ol>
<p><a href="https://blog.csdn.net/aguang110/article/details/84008615?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">参考地址</a></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL遇到连接超时问题</title>
    <url>/2021/04/18/MySQL/20210418-MySQL%E9%81%87%E5%88%B0%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="查看最大连接数"><a href="#查看最大连接数" class="headerlink" title="查看最大连接数"></a>查看最大连接数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看最大连接数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%max_connections%&#x27;</span></span><br><span class="line"><span class="comment">-- 查看已连接数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Max_used_connections&#x27;</span></span><br><span class="line"><span class="comment">-- 设置最大连接数，但是重启就还原了，可以在MySQL地配置文件中修改</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> max_connections<span class="operator">=</span><span class="number">1500</span></span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>my.cnf</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">   max<span class="built_in">_</span>connections=1500</span><br></pre></td></tr></table></figure>

<h3 id="打开表一直处于加载中，表死锁"><a href="#打开表一直处于加载中，表死锁" class="headerlink" title="打开表一直处于加载中，表死锁"></a>打开表一直处于加载中，表死锁</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 显示正在连接的进程</span></span><br><span class="line"><span class="keyword">show</span> processlist</span><br><span class="line"><span class="comment">-- 杀死进程号</span></span><br><span class="line"> kill <span class="number">60</span>;</span><br></pre></td></tr></table></figure>

<p>死锁原因：并发操作表导致表死锁。<br>结束所有操作当前表的进程，再去查询表，发现表解锁！</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的使用</title>
    <url>/2020/12/16/MySQL/MySQL%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="查看创建表结构"><a href="#查看创建表结构" class="headerlink" title="查看创建表结构"></a>查看创建表结构</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br></pre></td></tr></table></figure>

<h2 id="优雅操作"><a href="#优雅操作" class="headerlink" title="优雅操作"></a>优雅操作</h2><h3 id="多字段中文排序"><a href="#多字段中文排序" class="headerlink" title="多字段中文排序"></a>多字段中文排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select t1.value,t2.chinese_name</span><br><span class="line">from dictionary as t1 </span><br><span class="line">right join website as t2 on t1.uuid=t2.country</span><br><span class="line">where t1.type=&quot;country&quot;</span><br><span class="line">ORDER BY CONVERT(t1.value USING gbk), CONVERT(t2.chinese_name USING gbk)</span><br></pre></td></tr></table></figure>

<h3 id="存在主表不在另一个表中的数据"><a href="#存在主表不在另一个表中的数据" class="headerlink" title="存在主表不在另一个表中的数据"></a>存在主表不在另一个表中的数据</h3><p>三种实现方式：</p>
<ol>
<li><p>使用not in，容易理解，效率最低</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> A.ID <span class="keyword">from</span> A <span class="keyword">where</span> A.ID <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> ID <span class="keyword">from</span> B)</span><br></pre></td></tr></table></figure></li>
<li><p>使用左连接字段为空的记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A.ID <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B A.ID <span class="operator">=</span> B.ID <span class="keyword">where</span> B.ID <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>逻辑复杂，速度最快</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> num <span class="keyword">from</span> A <span class="keyword">where</span> A.ID <span class="operator">=</span> B.ID ) <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="useSSL"><a href="#useSSL" class="headerlink" title="useSSL"></a>useSSL</h2><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。</p>
<p>TLS与SSL在传输层与应用层之间对网络连接进行加密。</p>
<p>SSL协议提供服务主要：</p>
<ol>
<li>认证用户服务器，确保数据发送到正确的服务器；</li>
<li>加密数据，防止数据传输途中被窃取使用；</li>
<li>维护数据完整性，验证数据在传输过程中是否丢失；</li>
</ol>
<h3 id="useSSL-false-true"><a href="#useSSL-false-true" class="headerlink" title="useSSL=false / true"></a>useSSL=false / true</h3><p><strong>mysql连接中是否要设置成useSSL=true / false 与数据库中的用户的设置有关，每个数据库的用户都有一个sslType属性，如果设置了值，就需要useSSL设置成true，如果没有设置值，useSS设置成false。</strong></p>
<p><strong>SSL协议的作用，用于对敏感的数据进行加密，类似http与https的区别。</strong></p>
<p>MySQL在高版本需要指明是否进行SSL连接</p>
<ol>
<li>true 需要连接</li>
<li>false 不需要连接</li>
</ol>
<p>web应用中连接mysql数据库时后台会出现这样的提示：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+,</span><br><span class="line">5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.</span><br></pre></td></tr></table></figure>

<p>解决</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">url=jdbc:mysql://127.0.0.1:3306/xxx?useSSL=false</span></span><br></pre></td></tr></table></figure>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="数据库对象"><a href="#数据库对象" class="headerlink" title="数据库对象"></a>数据库对象</h2><ol>
<li>表</li>
<li>数据字典：系统表</li>
<li>约束：保证数据的完整性</li>
<li>视图</li>
<li>索引</li>
<li>存储过程</li>
<li>存储函数</li>
<li>触发器 </li>
</ol>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>使用表的一部分，针对不用的用户指定不同的查询视图。视图为虚拟表，可以理解为存储起来的select语句。</p>
<p>create view 视图名 as select</p>
<p>对视图中的数据进行增加删除修改操作，数据库相应发生变化。优点：控制数据访问的权限。</p>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>一组经过预先编译的sql封装。</p>
<p>函数一定会有返回值。存储过程可以没有返回值。</p>
<p>好处：</p>
<ol>
<li>提高sql语句的重用性</li>
<li>减少操作失误，提高效率</li>
<li>减少网络传输量</li>
<li>减少sql语句网络暴露的网上风险，提高数据查询的安全性。</li>
</ol>
<p>与视图的区别：视图偏向于查询看重成是一张表，存储过程用来存储sql，结构更加复杂，看中sql逻辑。</p>
<h1 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h1><p>MySQL架构：连接层-（服务层）处理层-引擎层-存储层</p>
<p>业务逻辑处理层包括：连接池-管理服务与工具-SQL处理接口-解析转换-优化器-缓存和缓冲。</p>
<p>存储引擎相关命令：show engines;</p>
<p>MyISAM与InnoDB数据库引擎对比：</p>
<p><img src="https://i.loli.net/2021/06/28/AnZBQPNa29ToCf4.png" alt="image-20210628143712555"></p>
<p>SQL性能下降原因：</p>
<ol>
<li>性能下降了SQL慢；执行时间长；等待时间长；<ol>
<li>查询语句写的烂</li>
<li>索引失效（单值、符合）</li>
<li>关联太多join（设计缺陷或不得已的需求）</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）</li>
</ol>
</li>
</ol>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>创建索引命令：create index idx_user_name on user(name, email)</p>
<p>SQL的Join查询：</p>
<ol>
<li><p>SQL执行顺序：</p>
<ol>
<li><p>手写顺序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="operator">&lt;&gt;</span> <span class="keyword">join</span> <span class="operator">&lt;&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>公有部分用来配对<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">where</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="keyword">having</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;&gt;</span></span><br><span class="line">limit <span class="operator">&lt;&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>机读顺序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="operator">&lt;&gt;</span> <span class="keyword">join</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="keyword">where</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="keyword">having</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">distinct</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;&gt;</span></span><br><span class="line">limit <span class="operator">&lt;&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Join图：left join; right join; inner join; full outer join(全外连接：a.key is null or b.key is null)</p>
</li>
</ol>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>索引简介：索引（Index）帮助MySQL高效获取数据的数据结构。</p>
<ol>
<li><p>B数（多路搜索树）索引，B+树索引，哈希索引</p>
</li>
<li><p>索引优势：</p>
<ol>
<li>提高数据检索的效率，降低数据库的IO成本；</li>
<li>降低数据排序的成本，降低了CPU的消耗。</li>
</ol>
</li>
<li><p>索引劣势：</p>
<ol>
<li>索引也是一张表，保存了主键与索引字段，并指向实体库的记录。占空间。</li>
<li>提高了查询速度，却降低了更新表的速度</li>
<li>索引只是提高效率的一个因素，如果MySQL有大数据量的表，需要花时间研究建立最优秀的索引或优化查询。</li>
</ol>
</li>
</ol>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>索引分类：</p>
<ol>
<li>单值索引：一个索引只包含单个列，一个表可以有多个单值索引。</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值。</li>
<li>复合索引：一个索引包含多个列。</li>
<li>基本语法：<ol>
<li>创建：<ol>
<li>create &lt;&gt; index indexName ON mytable(columnname(length))</li>
<li>alter mytable ADD &lt;&gt; index [indexName] ON (columnname(length))</li>
</ol>
</li>
<li>删除：drop index [indexName] ON mytable;</li>
<li>查看：show index from tableName;</li>
</ol>
</li>
</ol>
<p>mysql索引结构包括：BTree；Hash索引；full-text全文索引；R-Tree索引。</p>
<p>BTree树图形结构：</p>
<p><a href="https://imgtu.com/i/RUkTTH"><img src="https://z3.ax1x.com/2021/06/28/RUkTTH.png" alt="RUkTTH.png"></a></p>
<p>需要创建索引的情况：</p>
<ol>
<li>主键自动创建唯一索引。</li>
<li>频繁作为查找条件的字段应创建索引。</li>
<li>查询中与其他表关联的字段，外键关系建立索引。</li>
<li>频繁更新的字段不适合创建索引</li>
<li>where条件里用不到的字段不创建索引。</li>
<li>单键/组合索引选择？（高并发倾向组合索引）</li>
<li>排序字段若通过索引去访问将提高排序速度。</li>
<li>查询中统计或者分组字段</li>
</ol>
<p>不需要创建索引的情况：</p>
<ol>
<li>表记录太少</li>
<li>经常增删改的表</li>
<li>某数据列包含许多重复的内容</li>
</ol>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>性能分析：</p>
<ol>
<li><p>MySQL常见瓶颈：</p>
<ol>
<li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时</li>
<li>IO：发生在装入数据远大于内存容量的时候</li>
<li>服务器硬件的性能瓶颈</li>
</ol>
</li>
<li><p>Explain</p>
<ol>
<li><p>是什么：执行计划。</p>
</li>
<li><p>干什么： </p>
<p><a href="https://imgtu.com/i/RUmSFe"><img src="https://z3.ax1x.com/2021/06/28/RUmSFe.png" alt="RUmSFe.png"></a></p>
</li>
<li><p>怎么用：</p>
<ol>
<li>explain+SQL语句</li>
<li>执行计划包含的信息：id  select_type  table  type  possible_keys  key  key_len  ref  rows  Extra</li>
</ol>
</li>
<li><p>名词解释：</p>
<ol>
<li>id：查询的序列号<ol>
<li>id相同：执行顺序由上至下</li>
<li>id不同：id越大优先级越高</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>select_type：查询的类型，用于区别普通、联合、子查询等的复杂情况。</p>
<pre><code>  1. simple：简单查询，不包括子查询或者union
  2. primary：查询中包含子查询，最外层的查询
  3. subquery：子查询
  4. derived：子查询作为衍生，结果放到临时表
  5. union：第二个select出现在union之后，别被纪委union。若union包还在from子句的子查询中，外层select将被标记为derived。
  6. union result：从union表获取结果的select
</code></pre>
<ol start="3">
<li>table：哪张表</li>
<li>type：<ol>
<li>显示查询使用的了何种类型</li>
<li>从最好到最差依次是：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</li>
<li>system：表只有一行记录</li>
<li>const：通过索引能找到唯一记录。（主键或唯一索引）</li>
<li>eq_ref：唯一性索引扫描，每个索引键，表中只有一条记录与之匹配。</li>
<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。</li>
<li>range：之间所指定范围的行，使用一个索引来选择行。</li>
<li>index：全索引扫描，读取索引中的数据。索引文件比数据文件小。</li>
<li>ALL：遍历所有数据</li>
</ol>
</li>
<li>possible_keys：显示可能应用在这张表中的索引。</li>
<li>key：实际查询时，使用的索引。</li>
<li>key_len：索引使用的字节数。查询中使用的索引的长度。长度越短越好。</li>
<li>ref：显示索引那一列被使用了。</li>
<li>rows：找到记录读取的行数。</li>
<li>Extra：包含不在其他列的重要的信息<ol>
<li><strong>Using filesort</strong>：不好；mysql没有使用索引排序，使用的外部排序。（文件排序）</li>
<li><strong>Using temportry</strong>：不好；使用了临时表。</li>
<li><strong>Using index</strong>：很好；（覆盖索引 Covering Index select节u功德数据从索引中取得，不必根据索引读取数据文件）</li>
<li>Using where：使用罗where过滤；</li>
<li>using join buffer：使用了连接缓存；</li>
<li>impossible where：where的结果总是false；</li>
<li>distinct：找到第一个匹配，不再找相同的。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>union操作符：用于合并两个或多个select语句的结果集。默认选取不同的值。如果允许重复，使用union all。</p>
<p>索引优化：</p>
<p>两表优化方案，左连接查询，给右表建立索引。右连接查询，给左表建立索引。</p>
<h2 id="面试名词"><a href="#面试名词" class="headerlink" title="面试名词"></a>面试名词</h2><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>一个索引无法把数据查询出来，需要通过前几个索引最后再次查询逐渐索引才能把select的所有数据都查询出来。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>MySQL</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/2020/09/17/MySQL/Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="索引数据结构红黑树，Hash表，B-Tree"><a href="#索引数据结构红黑树，Hash表，B-Tree" class="headerlink" title="索引数据结构红黑树，Hash表，B+Tree"></a>索引数据结构红黑树，Hash表，B+Tree</h2><p>二叉树，红黑树，Hash表，B-Tree。</p>
<h3 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h3><p>索引是帮助Mysql高效获取数据的排好序的数据结构。</p>
<p>红黑树本质也是二叉树，不过可以自动平衡，不让二叉树一边叶子过长。</p>
<p>Hash：哈希算法：哈希散列值结果就是磁盘文件地址。</p>
<ul>
<li>不管表记录有多少，都能快速定位表数据的位置。</li>
<li>但是不能很好解决范围查找。</li>
</ul>
<p>B-Tree： </p>
<ul>
<li>叶子节点具有相同的深度，存放数据。</li>
<li>所有索引元素不重复。</li>
<li>节点中的数据索引从左到右递增排列。</li>
</ul>
<p>B+Tree：每个数据节点都能快速找到相邻节点（节点之间双向指针）。</p>
<ul>
<li>   非叶子节点不存储data，只存储索引（非叶子节点冗余索引），可以放更多的索引。</li>
<li>   叶子界定啊包含所有索引字段</li>
<li> 叶子节点用指针链接，提高区间访问的性能。</li>
<li>提高范围查找的性能。</li>
</ul>
<h3 id="B-Tree与B-Tree的不同："><a href="#B-Tree与B-Tree的不同：" class="headerlink" title="B-Tree与B+Tree的不同："></a>B-Tree与B+Tree的不同：</h3><ul>
<li><p>B+Tree叶子节点之间增加双向指针，B-Tree叶子节点之间没有。</p>
</li>
<li><p>B+Tree非叶子简单不存放数据，只存放索引（所以造成冗余索引）；B-Tree所有节点都存放数据，没有冗余索引。</p>
</li>
<li><p>在树的高度相同的情况下，B+Tree能放的数据更多。</p>
</li>
</ul>
<h2 id="千万级数据表快速查找"><a href="#千万级数据表快速查找" class="headerlink" title="千万级数据表快速查找"></a>千万级数据表快速查找</h2><p>Mysql底层数据结构：B+Tree（B-Tree变种）：多叉查找(x&lt;y&lt;=z]</p>
<p>B+Tree的索引每个节点大小：16kb</p>
<p>数据库有存储引擎的概念。表级别的概念。INNODB/MYISAM</p>
<p>MYISAM（非聚集索引）:</p>
<pre><code>frm表结构信息
MYD存储数据
MYI存储B+Tree的索引。
</code></pre>
<p>INNODB（聚集索引）: </p>
<pre><code>frm表结构信息
ibd索引和数据在一起
</code></pre>
<h2 id="基于B-Tree高性能索引"><a href="#基于B-Tree高性能索引" class="headerlink" title="基于B+Tree高性能索引"></a>基于B+Tree高性能索引</h2><p>INNODB索引实现（聚集）</p>
<ul>
<li>表数据文件本身就是按B+Tree组织的一个索引结构的文件。</li>
<li>聚集索引：叶子节点包含了完整的数据记录。</li>
<li>为什么INNODB表必须有主键，并且建议整型自增。<ul>
<li>如果没有主键，mysql找字段中的唯一字段作为索引，如果都没有，MySQL会创建一个隐藏列。不要增加MySQL的性能负担。</li>
<li>主键不要使用UUID（UUID不是整形也不是自增），B+树经常比大小，整形比大小快，上产环境高速SSD成本高。</li>
<li>在B+Tree数据结构中，自增树插入对B+Tree树的分裂小（B+Tree会自动优化分裂树的结构，保证在一定的规范下），随机树插入对B+Tree的分裂大</li>
</ul>
</li>
<li>为什么主键索引结构叶子节点存储的是主键值？（一致性和节省存储空间）</li>
</ul>
<h2 id="联合索引底层数据结构"><a href="#联合索引底层数据结构" class="headerlink" title="联合索引底层数据结构"></a>联合索引底层数据结构</h2><p>KEY ‘idx_name_age_position’ （’name’,’age’,’position’) USING BTREE</p>
<p>根据索引字段的顺序进行比较。先比较name后age后position</p>
<p><img src="https://i.loli.net/2020/09/17/pN3KRCx4UtlBEPi.jpg" alt="联合索引底层数据结构.jpg"></p>
<p>最左前缀优化：因为联合索引底层已经实现了</p>
<pre><code>explain select * from employees where name=&#39;Bill&#39; and age=31;
</code></pre>
<p>还有很多的知识需要学习。</p>
]]></content>
  </entry>
  <entry>
    <title>Nebula Graph图数据库学习</title>
    <url>/2021/04/20/NoSQL/20210420-Nebula%20Graph%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Nebula Graph是一款开源的、分布式的、易扩展的原生图数据库，能够承载数十亿个点和数万亿条边的超大规模数据集，提供毫秒级查询。</p>
<h2 id="架构总览"><a href="#架构总览" class="headerlink" title="架构总览"></a>架构总览</h2><p>Nebula Graph三种服务架构：</p>
<ol>
<li>Graph服务</li>
<li>Meta服务</li>
<li>Storage服务</li>
</ol>
<p><img src="https://docs-cdn.nebula-graph.com.cn/docs-2.0/1.introduction/2.nebula-graph-architecture/nebula-graph-architecture-1.png" alt="Nebula Graph architecture"></p>
<h3 id="Meta服务"><a href="#Meta服务" class="headerlink" title="Meta服务"></a>Meta服务</h3><p><img src="https://docs-cdn.nebula-graph.com.cn/docs-2.0/1.introduction/2.nebula-graph-architecture/meta-architecture1.png" alt="The architecture of the Meta Service"></p>
<p>Meta服务是由nebula-metad进程提供的，构成了基于Raft协议的集群，其中一个进程是leader，其它进程都是follower。</p>
<p>功能：管理用户账号、管理分片、管理图空间、管理Schema信息、管理基于TTL的数据回收、管理作业。</p>
<h3 id="Graph服务"><a href="#Graph服务" class="headerlink" title="Graph服务"></a>Graph服务</h3><p>负责处理计算请求</p>
<h3 id="Storage服务"><a href="#Storage服务" class="headerlink" title="Storage服务"></a>Storage服务</h3><p>负责存储数据</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><p>定义一个搜索模式，匹配存储在Nebula Graph中的数据，用RETURN子句检索数据。</p>
<h3 id="LOOKUP"><a href="#LOOKUP" class="headerlink" title="LOOKUP"></a>LOOKUP</h3><p>根据索引遍历数据。</p>
<h3 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h3><p>用指定过滤条件遍历图，返回结果</p>
<h3 id="FETCH"><a href="#FETCH" class="headerlink" title="FETCH"></a>FETCH</h3><p>可以获取指定点或边的属性值。</p>
<h3 id="UNWIND"><a href="#UNWIND" class="headerlink" title="UNWIND"></a>UNWIND</h3><p>作为单独语句或语句中的子句使用。将列表拆分为单独的行，列表中的每个元素为一行。</p>
<h3 id="SHOW"><a href="#SHOW" class="headerlink" title="SHOW"></a>SHOW</h3><p>显示一些Nebula Graph中的信息</p>
<h4 id="查询vid所有数据"><a href="#查询vid所有数据" class="headerlink" title="查询vid所有数据"></a>查询vid所有数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> PROP <span class="keyword">ON</span> <span class="operator">*</span> &quot;569961631955718144&quot;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>图数据库</category>
      </categories>
      <tags>
        <tag>图数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>详解@Autowired 与 @Resource的区别</title>
    <url>/2020/04/13/Spring/20200413-@Autowired%E4%B8%8E@Resource%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>spring不但支持自己定义的@Autowired注解，还支持几个由JSR-250规范定义的注解，它们分别是@Resource、@PostConstruct以及@PreDestroy。</p>
<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>@Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。</p>
<p>@Resource有两个属性是比较重要的，分是name和type，</p>
<p>Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。</p>
<p>所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<h1 id="2-Resource装配顺序"><a href="#2-Resource装配顺序" class="headerlink" title="2. @Resource装配顺序"></a>2. @Resource装配顺序</h1><p>　　1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常<br>　　2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常<br>　　3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常<br>　　4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</p>
<h1 id="3-Autowired-与-Resource的区别："><a href="#3-Autowired-与-Resource的区别：" class="headerlink" title="3. @Autowired 与@Resource的区别："></a>3. @Autowired 与@Resource的区别：</h1><p>1、 @Autowired与@Resource都可以用来装配bean. 都可以写在字段上,或写在setter方法上。</p>
<p>2、 @Autowired默认按类型装配（这个注解是属业spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired()</span> <span class="meta">@Qualifier(&quot;baseDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure>

<p>3、@Resource（这个注解属于J2EE的），默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<p>推荐使用：@Resource注解在字段上，这样就不用写setter方法了，并且这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起就比较优雅。</p>
<h1 id="4-总结："><a href="#4-总结：" class="headerlink" title="4. 总结："></a>4. 总结：</h1><p>@Autowired//默认按type注入<br>@Qualifier(“cusInfoService”)//一般作为@Autowired()的修饰用<br>@Resource(name=”cusInfoService”)//默认按name注入，可以通过name和type属性进行选择性注入</p>
<p>一般@Autowired和@Qualifier一起用，@Resource单独用。</p>
<p>当然没有冲突的话@Autowired也可以单独用</p>
<p>参考地址： <a href="https://blog.csdn.net/weixin_40423597/article/details/80643990">https://blog.csdn.net/weixin_40423597/article/details/80643990</a></p>
]]></content>
      <categories>
        <category>spring</category>
        <category>注解</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC框架</title>
    <url>/2020/09/18/Spring/SpringMVC%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/</url>
    <content><![CDATA[<h1 id="SpringMVC框架"><a href="#SpringMVC框架" class="headerlink" title="SpringMVC框架"></a>SpringMVC框架</h1><p>springmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。</p>
<p>springmvc是一个基于mvc的web框架。</p>
<h3 id="什么是mvc"><a href="#什么是mvc" class="headerlink" title="什么是mvc"></a>什么是mvc</h3><p>mvc是一个设计模式。</p>
<h4 id="mvc在b-s系统下的应用"><a href="#mvc在b-s系统下的应用" class="headerlink" title="mvc在b/s系统下的应用"></a>mvc在b/s系统下的应用</h4><p><img src="https://i.loli.net/2020/09/18/L4xKMIndoywCD1q.jpg" alt="mvc在bs系统下的应用.jpg"></p>
<h4 id="springmvc的框架"><a href="#springmvc的框架" class="headerlink" title="springmvc的框架"></a>springmvc的框架</h4><p><img src="https://i.loli.net/2020/09/21/cETUaj26e9LoM5O.png" alt="springmvc框架1.PNG"><br><img src="https://i.loli.net/2020/09/21/BLzTq9XCuEKQdpP.jpg" alt="springmvc框架2.jpg"></p>
<p>组件：</p>
<ol>
<li>前端控制器 Dispatcherservlet：作用接受请求，响应结果，相当于转发器(非常重要)。</li>
<li>处理器映射器 HandlerMapping：根据请求的url查找Handler</li>
<li>处理器适配器 HandlerAdapter：按特定的规则执行Handler</li>
<li>处理器Handler（需要开发）:编写Handler按照HandlerAdapter的要求去做</li>
<li>视图解析器 View reolver：进行视图解析，根据逻辑视图名解析成真正的视图（view）</li>
<li>视图View（需要开发）：View是一个接口，实现类支持不同的View类型（jsp,freemarker,pdf…）</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>详解@Qualifer注解</title>
    <url>/2021/04/12/Spring/%E8%AF%A6%E8%A7%A3@Qualifer%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>了解 <strong>Spring</strong> 框架的 <code>@Qualifier</code> 注解，它解决了哪些问题，以及如何使用它。</p>
<p>还将了解它与 <code>@Primary</code> 注解的不同之处。</p>
<h1 id="2-Autowired问题"><a href="#2-Autowired问题" class="headerlink" title="2. @Autowired问题"></a>2. @Autowired问题</h1><p>使用 <code>@Autowired</code> 注解是 <strong>Spring</strong> 依赖注入的绝好方法。但是有些场景下仅仅靠这个注解不足以让 <strong>Spring</strong> 知道要注入哪个 <strong>bean</strong> 。默认情况下， <code>@Autowired</code> 按类型装配 <strong>Spring Bean</strong> 。如果容器有多个相同类型的  <strong>bean</strong> ，则框架将抛出异常 <code>NoUniqueBeanDefinitionException</code> ，以提示有多个满足条件的 <strong>bean</strong> 进行装配。程序无法正确做出判断使用哪一个，下面就是个鲜活的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;fooFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooFormatter</span> <span class="keyword">implements</span> <span class="title class_">Formatter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">format</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;barFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BarFormatter</span> <span class="keyword">implements</span> <span class="title class_">Formatter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">format</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Formatter formatter;</span><br><span class="line">    <span class="comment">//todo </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们尝试将 <strong>FooService</strong> 加载到上下文中，<strong>Spring</strong> 框架将抛出 <code>NoUniqueBeanDefinitionException</code> 。这是因为 <strong>Spring</strong> 不知道要注入哪个 <strong>bean</strong> 。</p>
<p>为了避免这个问题。有几种解决方案。要讲解的 <code>@Qualifier</code> 注解就是其中之一。</p>
<h1 id="3-Qualifier"><a href="#3-Qualifier" class="headerlink" title="3. Qualifier"></a>3. Qualifier</h1><p>通过使用 <code>@Qualifier</code> 注解，可以消除需要注入哪个 <strong>bean</strong> 的问题。通过包含<code>@Qualifier</code>注解来指出我们想要使用哪个<strong>bean</strong>来解决问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;fooFormatter&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Formatter formatter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过将<code>@Qualifier</code>注解与想要使用的特定<strong>Spring bean</strong>的名称一起进行装配，<strong>Spring</strong>框架就能从多个相同类型并满足装配要求的<strong>bean</strong>中找到想要的，避免让<strong>Spring</strong>脑裂。我们需要做的是<code>@Component</code>或者<code>@Bean</code>注解中声明的<strong>value</strong>属性以确定名称。</p>
<p>其实我们也可以在 <code>Formatter</code> 实现类上使用 <code>@Qualifier</code> 注释，而不是在 <code>@Component</code> 或者 <code>@Bean</code> 中指定名称，也能达到相同的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;fooFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooFormatter</span> <span class="keyword">implements</span> <span class="title class_">Formatter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">format</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;barFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BarFormatter</span> <span class="keyword">implements</span> <span class="title class_">Formatter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">format</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-Qualifier-VS-Primary"><a href="#4-Qualifier-VS-Primary" class="headerlink" title="4. @Qualifier VS @Primary"></a>4. @Qualifier VS @Primary</h1><p>还有另一个名为 <code>@Primary</code> 的注解，我们也可以用来发生依赖注入的歧义时决定要注入哪个 <strong>bean</strong>。当存在多个相同类型的 <strong>bean</strong> 时，此注解定义了首选项。除非另有说明，否则将使用与 <code>@Primary</code> 注释关联的 <strong>bean</strong> 。<br>我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Employee <span class="title function_">tomEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> Employee <span class="title function_">johnEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，两个方法都返回相同的 <code>Employee</code>类型。<strong>Spring</strong> 将注入的 <strong>bean</strong> 是方法 <code>johnEmployee</code> 返回的 <strong>bean</strong>。这是因为它包含 <code>@Primary</code> 注解。当我们想要指定默认情况下应该注入特定类型的 <strong>bean</strong> 时，此注解很有用。如果我们在某个注入点需要另一个 <strong>bean</strong>，我们需要专门指出它。我们可以通过 <code>@Qualifier</code> 注解来做到这一点。例如，我们可以通过使用 <code>@Qualifier</code> 注释来指定我们想要使用 <code>tomEmployee</code> 方法返回的 <strong>bean</strong> 。值得注意的是，如果 <code>@Qualifier</code> 和 <code>@Primary</code> 注释都存在，那么 <code>@Qualifier</code> 注释将具有优先权。基本上，<code>@Primary</code> 是定义了默认值，而 <code>@Qualifier</code> 则非常具体。当然<code> @Component</code> 也可以使用<code> @Primary</code> 注解，这次使用的还是上面3的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooFormatter</span> <span class="keyword">implements</span> <span class="title class_">Formatter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">format</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BarFormatter</span> <span class="keyword">implements</span> <span class="title class_">Formatter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">format</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>@Primary</code> 注解指定了默认注入的是 <code>FooFormatter</code>，消除了场景中的注入歧义。</p>
<h1 id="5-通过名称来自动注入"><a href="#5-通过名称来自动注入" class="headerlink" title="5. 通过名称来自动注入"></a>5. 通过名称来自动注入</h1><p>在使用 <code>@Autowired</code> 进行自动装配时，如果 <strong>Spring</strong> 没有其他提示，将会按照需要注入的变量名称来寻找合适的 <strong>bean</strong>。也可以解决依赖注入歧义的问题。让我们看一些基于我们最初的例子的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Formatter fooFormatter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<strong>Spring</strong> 将确定要注入的 <strong>bean</strong> 是 <code>FooFormatter</code>，因为字段名称与我们在该 <strong>bean</strong> 的 <code>@Component</code>或者 <code>@Bean</code> 注解中使用的值(默认 <code>@Bean</code> 使用方法名)相匹配。</p>
<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><p>通过对 <code>@Qualifier</code> 的探讨，我们知道该注解是用来消除依赖注入冲突的。通过@Qualifier注解设置value，告诉Spring应该注入的bean的名称。</p>
<p>借鉴地址：<a href="https://zhuanlan.zhihu.com/p/100371910?from_voters_page=true">https://zhuanlan.zhihu.com/p/100371910?from_voters_page=true</a></p>
]]></content>
      <categories>
        <category>spring</category>
        <category>注解</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie和Session</title>
    <url>/2023/02/23/Web/Cookie%E5%92%8CSession/</url>
    <content><![CDATA[<p>会话跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie和Session。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Cookie是某些网站为了辨别用户身份，进行Session跟踪而存储在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息。</p>
<h3 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h3><p>内存式：存储在内存中，浏览器关闭后就会消失，由于其存储时间较短，因此也被称为非持久Cookie或会话Cookie。</p>
<p>硬盘式：保存在硬盘中，不会随浏览器的关闭而消失，除非用户手工清理或到了过期时间。由于硬盘式Cookie存储时间是长期的，因此也被称为持久Cookie。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Cookie定义了一些HTTP请求头和HTTP响应头，通过这些HTTP头信息使服务器与客户进行状态交互。</p>
<p>客户端请求服务器后，如果服务器需要记录用户状态，服务器会在响应信息中包含一个Set-Cookie的响应头，客户端会根据这个响应头存储Cookie信息。再次请求服务器时，客户端会在请求信息中包含一个Cookie请求头，而服务器会根据这个请求头进行用户身份、状态等较验。</p>
<p><img src="https://genuine-ipic.oss-cn-beijing.aliyuncs.com/markdown/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3YWRpYW4yMDA4,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>在服务器响应请求中，响应头中包一个Set-Cookie字段。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>UserID=itbilu; Max-Age=3600; Version=1</span><br></pre></td></tr></table></figure>

<h3 id="Cookie的属性设置"><a href="#Cookie的属性设置" class="headerlink" title="Cookie的属性设置"></a>Cookie的属性设置</h3><p>Java中把Cookie封装成了javax.servlet.http.Cookie类。服务器通过操作Cookie类对象对客户端Cookie进行操作。</p>
<p>通过request.getCookie()获取客户端提交的所有Cookie，通过response.addCookie()向客户端设置Cookie。</p>
<p>每个属性对应一个getter方法与一个setter方法。</p>
<p><img src="https://genuine-ipic.oss-cn-beijing.aliyuncs.com/markdown/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3YWRpYW4yMDA4,size_16,color_FFFFFF,t_70-20230309112232886.png" alt="img"></p>
<p><img src="https://genuine-ipic.oss-cn-beijing.aliyuncs.com/markdown/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3YWRpYW4yMDA4,size_16,color_FFFFFF,t_70-20230309112220181.png" alt="img"></p>
<h4 id="Unicode编码：保存中文"><a href="#Unicode编码：保存中文" class="headerlink" title="Unicode编码：保存中文"></a>Unicode编码：保存中文</h4><p>中文与英文字符不同，中文属于Unicode字符，在内存中占4个字符，而英文属于ASCII字符，内存中只占2个字节。Cookie中使用Unicode字符时需要对Unicode字符进行编码，否则会乱码。</p>
<p>Cookie中保存中文只能编码。一般使用UTF-8编码即可。不推荐使用GBK等中文编码，因为浏览器不一定支持，而且JavaScript也不支持GBK编码</p>
<h4 id="设置Cookie的有效期"><a href="#设置Cookie的有效期" class="headerlink" title="设置Cookie的有效期"></a>设置Cookie的有效期</h4><p>从客户端读取Cookie时，包括maxAge在内的其他属性都是不可读的，也不会被提交。浏览器提交Cookie时只会提交name与value属性。maxAge属性只被浏览器用来判断Cookie是否过期。</p>
<h4 id="修改和删除cookie"><a href="#修改和删除cookie" class="headerlink" title="修改和删除cookie"></a>修改和删除cookie</h4><p>要想修改Cookie只能使用一个同名的Cookie来覆盖原来的Cookie，达到修改的目的。删除时只需要把maxAge修改为0即可。</p>
<p>修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。</p>
<h4 id="设置cookie的域名"><a href="#设置cookie的域名" class="headerlink" title="设置cookie的域名"></a>设置cookie的域名</h4><p>Cookie是不可跨域名的。域名 <a href="http://www.google.com/">www.google.com</a> 颁发的Cookie不会被提交到域名 <a href="http://www.baidu.com/">www.baidu.com</a> 去。这是由Cookie的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的Cookie。</p>
<h4 id="设置cookie的安全属性"><a href="#设置cookie的安全属性" class="headerlink" title="设置cookie的安全属性"></a>设置cookie的安全属性</h4><p>secure属性并不能对Cookie内容加密，因而不能保证绝对的安全性。如果需要高安全性，需要在程序中对Cookie内容加密、解密，以防泄密。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。</p>
<h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>某个客户端初次请求创建Session时，服务器先检查请求中是否包含Session标识，成为session id，包含说明已经为此客户端创建过session，服务器根据session id把Session检索出来，不包含则需要创建一个唯一session id，并在本次响应中返回给客户端保存。</p>
<p><img src="https://genuine-ipic.oss-cn-beijing.aliyuncs.com/markdown/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3YWRpYW4yMDA4,size_16,color_FFFFFF,t_70-20230309113835050.png" alt="img"></p>
<h4 id="保存session-id的方式"><a href="#保存session-id的方式" class="headerlink" title="保存session id的方式"></a>保存session id的方式</h4><h5 id="使用Cookie保存"><a href="#使用Cookie保存" class="headerlink" title="使用Cookie保存"></a>使用Cookie保存</h5><p>在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。然而，比如weblogic对于web应用程序生成的cookie，JSESSIONID=ByOK3v，它的名字就是JSESSIONID。</p>
<h5 id="URL重写"><a href="#URL重写" class="headerlink" title="URL重写"></a>URL重写</h5><p>由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。一种是作为URL路径的附加信息http://…../xxx;jsessionid=ByOK3v，另一种是作为查询字符串附加在URL后面http://…../xxx?jsessionid=ByOK3v。</p>
<h5 id="表单隐藏字段"><a href="#表单隐藏字段" class="headerlink" title="表单隐藏字段"></a>表单隐藏字段</h5><p>表单隐藏就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。</p>
<h3 id="Session的常用方法"><a href="#Session的常用方法" class="headerlink" title="Session的常用方法"></a>Session的常用方法</h3><p><img src="https://genuine-ipic.oss-cn-beijing.aliyuncs.com/markdown/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3YWRpYW4yMDA4,size_16,color_FFFFFF,t_70-20230309135307139.png" alt="img"></p>
<p><img src="https://genuine-ipic.oss-cn-beijing.aliyuncs.com/markdown/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3YWRpYW4yMDA4,size_16,color_FFFFFF,t_70-20230309135317292.png" alt="img"></p>
<p>Session对应的类为javax.servlet.http.HttpSession类。Session对象是在客户端第一次请求服务器的时候创建的。Session也是一种key-value的属性对，通过getAttribute(String key)和setAttribute(String key，Objectvalue)方法读写客户状态信息。Servlet里通过request.getSession()方法获取该客户的Session。</p>
<p>当多个客户端执行程序时，服务器会保存多个客户端的Session。获取Session的时候也不需要声明获取谁的Session。Session机制决定了当前客户只会获取到自己的Session，而不会获取到别人的Session。</p>
<p>Session保存在服务器端。为了获得更高的存取速度，服务器一般把Session放在内存里。每个用户都会有一个独立的Session。如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，Session里的信息应该尽量精简。</p>
<h2 id="Session和Cookie的区别与联系"><a href="#Session和Cookie的区别与联系" class="headerlink" title="Session和Cookie的区别与联系"></a>Session和Cookie的区别与联系</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>cookie数据存放在客户端，session数据放在服务器上。</li>
<li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</li>
<li>session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑性能应当使用cookie。</li>
<li>不同浏览器对cookie的数据大小限制不同，个数限制也不相同。单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>可以考虑将登陆信息等重要信息存放为session，不重要的信息可以放在cookie中。</li>
</ol>
<h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ol>
<li>都是用来记录用户的信息，以便让服务器分辨不同的用户。</li>
<li>可以搭配使用，但都有自己的使用局限，要考虑到安全和性能的问题。</li>
</ol>
<p><a href="https://blog.csdn.net/swadian2008/article/details/104267034">原文地址</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 注解学习-持续更新</title>
    <url>/2020/08/11/Spring/spring%E6%B3%A8%E8%A7%A3-%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
    <content><![CDATA[<h2 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h2><h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">　　 <span class="meta">@Value(&quot;normal&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String normal; <span class="comment">// 注入普通字符串</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;os.name&#x27;]&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String systemPropertiesName; <span class="comment">// 注入操作系统属性</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Value(&quot;#&#123; T(java.lang.Math).random() * 100.0 &#125;&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> randomNumber; <span class="comment">//注入表达式结果</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Value(&quot;#&#123;beanInject.another&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String fromAnotherBean; <span class="comment">// 注入其他Bean属性：注入beanInject对象的属性another，类具体定义见下面</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Value(&quot;classpath:com/hry/spring/configinject/config.txt&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> Resource resourceFile; <span class="comment">// 注入文件资源</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Value(&quot;http://www.baidu.com&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> Resource testUrl; <span class="comment">// 注入URL资源</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;book.name&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String bookName;<span class="comment">// 注入配置外部文件属性</span></span><br></pre></td></tr></table></figure>



<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><h3 id="WebMethod"><a href="#WebMethod" class="headerlink" title="@WebMethod"></a>@WebMethod</h3><h3 id="FeignClient"><a href="#FeignClient" class="headerlink" title="@FeignClient"></a>@FeignClient</h3><p>注解被@Target(ElementType.TYPE)修饰，表示FeignClient注解的作用目标在接口上。<br>    name：指定FeignClient的名称，如果项目使用了Ribbon，name属性会作为微服务的名称，用于服务发现<br>    url: url一般用于调试，可以手动指定@FeignClient调用的地址   </p>
<h3 id="EnableMongoRepositories"><a href="#EnableMongoRepositories" class="headerlink" title="@EnableMongoRepositories"></a>@EnableMongoRepositories</h3><p>启动类中：让框架创建的Repository接口创建实现类，并添加到Spring容器中进行管理。<br>resources目录下：application.properties文件中配置MongoDB的连接字符串。<br>spring.data.mongodb.uri=mongodb://springbucks:<a href="mailto:&#115;&#x70;&#114;&#x69;&#110;&#103;&#x62;&#117;&#99;&#x6b;&#115;&#64;&#x78;&#120;&#x78;&#46;&#120;&#x78;&#120;&#46;&#x78;&#x78;&#120;&#46;&#x78;&#120;&#120;">&#115;&#x70;&#114;&#x69;&#110;&#103;&#x62;&#117;&#99;&#x6b;&#115;&#64;&#x78;&#120;&#x78;&#46;&#120;&#x78;&#120;&#46;&#x78;&#x78;&#120;&#46;&#x78;&#120;&#120;</a>:xxxxx/springbucks  </p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>用来映射请求，也就是通过它来指定控制器可以处理哪些URL请求，相当于Servlet中在web.xml中配置  </p>
<ol>
<li>@Target中有两个属性，分别为 ElementType.METHOD 和 ElementType.TYPE ，也就是说 @RequestMapping 可以在方法和类的声明中使用  <h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3></li>
</ol>
<h3 id="controller"><a href="#controller" class="headerlink" title="@controller"></a>@controller</h3><p>控制器（注入服务），用于标注控制层，相当于struts中的action层。  </p>
<h3 id="service"><a href="#service" class="headerlink" title="@service"></a>@service</h3><p>服务（注入dao），用于标注服务层，主要用来进行业务的逻辑处理。  </p>
<h3 id="repository"><a href="#repository" class="headerlink" title="@repository"></a>@repository</h3><p>实现dao访问，用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件。  </p>
<h3 id="component"><a href="#component" class="headerlink" title="@component"></a>@component</h3><p>把普通pojo实例化到spring容器中，泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。</p>
<h3 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h3><p>主要体现在pojo实体中，通常要在实体类上注明@Document。<br>其属性可以标明属于的索引和类型—-对应数据库中的数据库名和表名,其中type不预先创建也可以,没预先创建的它会自动创建一个与实体相匹配的type。<br>标识要持久保存到MongoDB的域对象。  </p>
<h3 id="NoRepositoryBean"><a href="#NoRepositoryBean" class="headerlink" title="@NoRepositoryBean"></a>@NoRepositoryBean</h3><p>以排除获取存储库接口，从而导致创建实例。<br>当为所有存储库提供扩展的基本接口并结合自定义存储库基类以实现在该中间接口中声明的方法时，通常会使用此方法。在这种情况下，您通常是从中间接口派生出具体的存储库接口，但又不想为中间接口创建Spring bean。  </p>
<h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><p>抑制警告，取消警告信息。  </p>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>指示一个类声明了一个或多个@Bean方法，并且可以由Spring容器处理以在运行时为这些bean生成bean定义和服务请求。  </p>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="@Entity"></a>@Entity</h3><p>指定该类是一个实体。该注释应用于实体类。  </p>
<h3 id="Table-name-“DE-WS-OID-DT”"><a href="#Table-name-“DE-WS-OID-DT”" class="headerlink" title="@Table(name = “DE_WS_OID_DT”)"></a>@Table(name = “DE_WS_OID_DT”)</h3><p>指定带注释的实体的主表。<br>如果没有为实体类指定Table注释，则使用默认值。  </p>
<h3 id="NamedQuery"><a href="#NamedQuery" class="headerlink" title="@NamedQuery"></a>@NamedQuery</h3><p>(用Java Persistence查询语言)指定一个静态的命名查询。查询名称的作用域是持久性单元。(NamedQuery批注可以应用于实体或映射的超类。)  </p>
<h3 id="Column"><a href="#Column" class="headerlink" title="@Column"></a>@Column</h3><p>用于为持久属性或字段指定映射的列。如果未指定Column注解，则应用默认值。  </p>
<h3 id="FeignClient-1"><a href="#FeignClient-1" class="headerlink" title="@FeignClient"></a>@FeignClient</h3><p>接口注释，声明应创建具有该接口的REST客户端（例如，用于自动装配到另一个组件中）。如果功能区可用，它将用于负载均衡后端请求，并且可以使用与假客户端具有相同名称（即值）的@RibbonClient配置负载均衡器。<br>name指定FeignClient的名称，如果项目使用了Ribbon，name属性会作为微服务的名称，用于服务发现。<br>url属性一般用于调试程序，允许我们手动指定@FeignClient调用的地址。</p>
<h3 id="Mapper和-Repository注解的区别"><a href="#Mapper和-Repository注解的区别" class="headerlink" title="@Mapper和@Repository注解的区别"></a>@Mapper和@Repository注解的区别</h3><ol>
<li>使用@Mapper，不需要在spring配置中设置扫描地址，通过mapper.xml中的namespace属性对应相关的mapper类，spring将动态的生成Bean后注入到ServiceImpl中。  </li>
<li>@Repository则需要在Spring中配置扫描包地址，然后生成dao层的bean，之后被注入到ServiceImpl中。  </li>
</ol>
<h2 id="lombok注解"><a href="#lombok注解" class="headerlink" title="lombok注解"></a>lombok注解</h2><h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>使用这个注解，就不用再去手写Getter,Setter,equals,canEqual,hasCode,toString等方法了，注解后在编译时会自动加进去。</p>
<h3 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h3><p>使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数</p>
<h3 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor"></a>@NoArgsConstructor</h3><p>使用后创建一个无参构造函数</p>
<h3 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h3><p>关于Builder较为复杂一些，Builder的作用之一是为了解决在某个类有很多构造函数的情况，也省去写很多构造函数的麻烦，在设计模式中的思想是：用一个内部类去实例化一个对象，避免一个类出现过多构造函数</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring学习</title>
    <url>/2020/09/10/Spring/spring%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><p>Spring框架是一系列应用框架的核心，是整合其他应用框架的基座。同时还是SpringBoot的基础。里面包含了Spring，SpringMVC，SpringData（事务），SpringTest等等。</p>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>IOC负责降低代码间的依赖关系，使项目灵活度更高，可复用性更强。</p>
<p>AOP让方法间的各个部分更加独立，达到统一调用执行，使后期维护更加方便。</p>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>对Servlet和JSP的API进行了封装，并在此基础上进一步加强。它推出的一套注解，可以更轻松的做表现层开发。</p>
<h3 id="SpringData"><a href="#SpringData" class="headerlink" title="SpringData"></a>SpringData</h3><p>一组技术合集。里面包含了JDBC，Data JPA，Data Redis，Data Mongodb，Data Rabbit，Data ElasticSearch等等。合集中的每一项都是针对不同数据存储做的简化封装。</p>
<h3 id="SpringTest"><a href="#SpringTest" class="headerlink" title="SpringTest"></a>SpringTest</h3><p>对Junit单元测试的整合。在开发中以及开发后期进行测试时，直接使用Junit结合spring一起测试。</p>
<h1 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring"></a>Spring</h1><h3 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h3><p>Spring是分层的JavaSE/EE应用的轻量级开源框架，IOC和AOP为内核，提供了展现层MVC和持久层Spring JDBC以及业务层事务管理等众多企业级应用技术，还能整合众多第三方框架和类库。主键成为使用最多的JavaEE企业应用开源框架。</p>
<h3 id="spring的优势"><a href="#spring的优势" class="headerlink" title="spring的优势"></a>spring的优势</h3><ul>
<li>方便解耦</li>
<li>AOP编程的支持</li>
<li>声明式事务的支持</li>
<li>方便层序的测试</li>
<li>方便集成各种优秀的框架</li>
<li>降低JavaAPI的使用难度</li>
<li>Java源码是经典设计范例</li>
</ul>
<h3 id="spring体系框架"><a href="#spring体系框架" class="headerlink" title="spring体系框架"></a>spring体系框架</h3><p><img src="https://i.loli.net/2020/09/22/oYXJAV9mB4dh36D.jpg" alt="spring体系框架.jpg"></p>
<p>IOC：控制反转，对象创建的权力转移了，不在new了，交由spring管理。<br>AOP：日志与异常的代码，动态的切入业务类。</p>
<p>以前使用EJB，臃肿、低效的开发模式。</p>
<p>开发分三层：</p>
<ul>
<li>表现层：整合Struts</li>
<li>业务层：事务管理，记录日志</li>
<li>持久层：整合Hibernate，JdbcTemplate</li>
</ul>
<h2 id="Spring的IOC"><a href="#Spring的IOC" class="headerlink" title="Spring的IOC"></a>Spring的IOC</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>控制反转，把创建对象的权力交给框架。包括依赖注入和依赖查找。</p>
<p>ioc的作用：削减计算机程序的耦合（减少代码间的依赖关系）。</p>
<h3 id="设计模式-工厂模式"><a href="#设计模式-工厂模式" class="headerlink" title="设计模式-工厂模式"></a>设计模式-工厂模式</h3><p>最常用的实例化对象模式，用工厂中的方法代替new创建对象的一种设计模式。</p>
<h3 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a>IOC和DI</h3><h4 id="IOC-Inversion-of-Control"><a href="#IOC-Inversion-of-Control" class="headerlink" title="IOC-Inversion of Control"></a>IOC-Inversion of Control</h4><p>控制反转。不是一个技术，而是一个思想。</p>
<p>对象创建的权力转移了，不在new了，交由spring管理。</p>
<p>作用：削减代码间的耦合。</p>
<p>实现思想：利用工厂模式，把创建对象代码从具体类中剥离出去，交由工厂完成，从而降低代码间的依赖关系。</p>
<p>耦合分类：耦合程序间的依赖关系</p>
<ol>
<li>内容耦合：修改时需要修改源码</li>
<li>公共耦合：开发时需要限制作用范围</li>
<li>外部耦合</li>
<li>控制耦合：</li>
<li>标记耦合</li>
<li>数据耦合</li>
<li>非直接耦合</li>
</ol>
<p>为什么要解耦：</p>
<ul>
<li>耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用原则：<ul>
<li>如果模块间必然存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。</li>
</ul>
</li>
</ul>
<h4 id="DI-Dependency-Injection"><a href="#DI-Dependency-Injection" class="headerlink" title="DI-Dependency Injection"></a>DI-Dependency Injection</h4><p>依赖注入。是spring框架核心IOC的具体实现。</p>
<h3 id="IOC-细节"><a href="#IOC-细节" class="headerlink" title="IOC 细节"></a>IOC 细节</h3><p>获取spring的IOC核心容器，并根据id获取对象</p>
<p>Application||Context的常用的三个常用的实现类：</p>
<ol>
<li>ClassPathXmlApplicationContext:可以加载类路径下的配置文件，要求配置文件必须在类路径下。</li>
<li>FileSystemXmlApplicationContext:可以加载磁盘任意路径下的配置文件（必须有访问权限），使用绝对路径。</li>
<li>AnnotationConfigApplicationContext:用于读取注解创建容器的。</li>
</ol>
<p>核心容器的两个接口：</p>
<ol>
<li>ApplicationContext（单例对象适用）：在构建容器时，创建对象，采取立即加载的方式。只要一读取完配置文件就创建配置文件中配置的对象。</li>
<li>BeanFactory（多例对象适用）：在构建核心容器时，创建对象，采用延迟加载的方式。什么时候根据id获取对象，才真正的获取对象。</li>
</ol>
<h3 id="bean细节"><a href="#bean细节" class="headerlink" title="bean细节"></a>bean细节</h3><h4 id="创建bean的三种方式"><a href="#创建bean的三种方式" class="headerlink" title="创建bean的三种方式"></a>创建bean的三种方式</h4><ol>
<li><p>默认构造函数创建：在spring的配置文件中使用bean标签，配以id和class属性，没有其他属性和标签时，采用默认构造函数创建bean对象。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com...AccountServiceImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用普通工厂中的方法创建对象（使用某个类的方法创建对象，并存入spring容器）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1. <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;instanceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com...InstanceFactory&quot;</span> /&gt;</span></span><br><span class="line">2. <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;instanceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getAccountService&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>工厂中静态方法（某个类中静态方法创建对象，并存入spring容器）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com...StaticFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getAccountService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="bean对象的作用范围"><a href="#bean对象的作用范围" class="headerlink" title="bean对象的作用范围"></a>bean对象的作用范围</h4><p>bean标签的scope属性：用于指定bean的作用范围</p>
<p>取值：</p>
<ol>
<li>singleton：单例的（默认值）</li>
<li>prototype：多例的</li>
<li>request：作用于web应用的请求范围</li>
<li>session：作用于web应用的会话范围</li>
<li>global-session：作用于集群环境的会话范围（全局会话范围），不是集群环境时，就是session</li>
</ol>
<h4 id="bean-对象的生命周期"><a href="#bean-对象的生命周期" class="headerlink" title="bean 对象的生命周期"></a>bean 对象的生命周期</h4><ol>
<li><p>单例对象</p>
<ol>
<li>出生：当容器对象创建时</li>
<li>容器还在，对象一直在</li>
<li>容器销毁，对象消亡</li>
<li>结论：单例对象生命周期和容器相同。</li>
</ol>
</li>
<li><p>多例对象</p>
<ol>
<li>出生：当使用对象时创建</li>
<li>对象使用时，一直在</li>
<li>当对象长时间不用，且没有别的对象引用时，GC回收。</li>
</ol>
</li>
</ol>
<h3 id="spring中的依赖注入"><a href="#spring中的依赖注入" class="headerlink" title="spring中的依赖注入"></a>spring中的依赖注入</h3><p>当前类需要使用到其他类的对象，由spring提供，依赖关系的维护称之为依赖注入。</p>
<p>能注入的数据有3类：</p>
<ol>
<li>基本类型和String</li>
<li>其他bean类型（在配置文件中或者注解配置过的bean）</li>
<li>复杂类型/集合类型<ol>
<li>list结构集合注入标签：list，array，set</li>
<li>Map结构结合注入标签：map，props</li>
</ol>
</li>
</ol>
<p>注入的方式3中：</p>
<ol>
<li>构造函数提供：编写带参构造函数<ol>
<li>使用标签constructor-arg</li>
<li>位置：bean标签内部</li>
<li>属性：<ol>
<li>type：构造函数中某个或某些参数的类型</li>
<li>index：构造函数中指定索引位置的参数赋值</li>
<li>name：构造函数中指定名称的参数赋值（以上三个用于指定给构造函数中那个参数赋值）</li>
<li>value：提供基本类型和String类型的数据</li>
<li>ref：指定其他的bean类型数据。spring的IOC核心容器中出现过的bean对象</li>
</ol>
</li>
<li>优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。</li>
<li>弊端：改变了bean对象的实例化方式，在创建对象时，如果用不到这些方式也会提供。</li>
</ol>
</li>
<li>set方法提供（需要给成员变量写set方法）<ol>
<li>标签：property；复杂类型/集合类型可以在内部使用对应的标签。</li>
<li>位置：bean标签的内部</li>
<li>属性：<ol>
<li>name：指定注入时set方法名称（setUserName–&gt;userName）</li>
<li>value</li>
<li>ref</li>
</ol>
</li>
<li>优势：创建对象是没有明确的限制，可以直接使用默认构造函数。</li>
<li>弊端：如果某个成员必须有值，则获取对象时可能set方法没有执行。</li>
</ol>
</li>
<li>注解提供</li>
</ol>
<h2 id="spring基于注解的IOC"><a href="#spring基于注解的IOC" class="headerlink" title="spring基于注解的IOC"></a>spring基于注解的IOC</h2><h3 id="曾经的xml配置："><a href="#曾经的xml配置：" class="headerlink" title="曾经的xml配置："></a>曾经的xml配置：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com...AccountServiceImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="用于创建对象"><a href="#用于创建对象" class="headerlink" title="用于创建对象"></a>用于创建对象</h4><ol>
<li>@Component：用于把当前对象存入spring容器中。<ol>
<li>属性：value：用于指定bean的id。默认值为当前类名，首字母小写<ol>
<li>需要在配置文件中导入context命名空间。<strong>告知spring在创建容器时要扫描的包</strong>，配置需要的标签不是在 nbeans的约束中，在context名称空间和约束中 &lt;context:component-scan base-package=”com.genuine”/&gt;</li>
</ol>
</li>
</ol>
</li>
<li>@Controller：表现层</li>
<li>@Service：业务层</li>
<li>@Repository：持久层</li>
<li>2-4三个注解的作用和属性与Component时一模一样的。spring框架提供明确的三层使用是为了使三层对象更清晰。</li>
</ol>
<h4 id="用于注入数据"><a href="#用于注入数据" class="headerlink" title="用于注入数据"></a>用于注入数据</h4><ol>
<li>@Autowired：自动按照类型注入<ol>
<li>只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配就注入成功</li>
<li>如果有多个同类型。先根据对象类型查找后根据变量名称查找。</li>
</ol>
</li>
<li>@Qualifier（与Autowired一起使用）：在按照类中注入的基础上，再按照名称注入，value用于指定bean的id，在方法中可以单独使用。</li>
<li>@Resource：name属性直接指定bean 的id。</li>
<li>@Value：用于注入基本类型和String类型的数据<ol>
<li>属性：value：用于指定数据的值。</li>
<li>可以使用spring中的SpEL（spring的el表达式）。SqEL的写法：${表达式}</li>
</ol>
</li>
</ol>
<p>总结：以上1-3个只能注入其他bean类型的数据，基本类型和String类型无法使用上述注解实现。集合类型的注入只能通过xml来实现。</p>
<h4 id="用于改变作用范围"><a href="#用于改变作用范围" class="headerlink" title="用于改变作用范围"></a>用于改变作用范围</h4><p>@Scope：用于指定bean的作用范围。属性value指定范围取值。常用值：singleton，prototype。</p>
<h4 id="和生命周期相关（了解）"><a href="#和生命周期相关（了解）" class="headerlink" title="和生命周期相关（了解）"></a>和生命周期相关（了解）</h4><ol>
<li>@ProDestroy：用于销毁方法上</li>
<li>@PostConstruct：用于初始化方法上</li>
</ol>
<h4 id="基于xml的ioc案例"><a href="#基于xml的ioc案例" class="headerlink" title="基于xml的ioc案例"></a>基于xml的ioc案例</h4><p>需要粘钩：使用dbutils的queryrunner数据库操作方法，链接c3p0数据库连接池。</p>
<p>spring中ioc的常用注解</p>
<p>xml方式和注解方式实现CRUD</p>
<p>基于注解的ioc案例，使用纯注解的方式实现</p>
<p>spring和Junit整合</p>
<h3 id="spring配置类"><a href="#spring配置类" class="headerlink" title="spring配置类"></a>spring配置类</h3><p>作用与bean.xml是一样的。</p>
<ol>
<li><p>@Configuration：指定当前类是一个配置类。</p>
<ol>
<li>当使用annotationconfigration（**.class）如果没有class文件，就要在类中加入该注解。</li>
</ol>
</li>
<li><p>@ComponentScan：通过注解指定spring在创建容器时要扫描的包。</p>
<ol>
<li><p>属性basePackages：指定创建容器时要扫描的包。</p>
</li>
<li><p>属性value：和basePackages的作用是一样的。</p>
</li>
<li><p>当时使用了此注解，就等同于在xml中配置了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.genuine&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>@Bean：把当前方法的返回值作为bean对象，存入spring的ioc容器中。</p>
<ol>
<li>属性name：指定bean的id，默认值是当前方法的名称。</li>
<li>如果方法有参数，spring框架会去容器中查找有没有可用的bean对象，查找的方式和Autowired注解的作用相同。</li>
</ol>
</li>
<li><p>@Import(JdbcConfig.class)： 可以在主配置类中，导入其他的子配置类。</p>
</li>
<li><p>@PropertySource(“classpath:**.properties”)：指定properties文件的位置。</p>
<ol>
<li>属性value：指定文件的名称和路径。关键字classpath，表示类路径下。</li>
</ol>
</li>
</ol>
<h3 id="spring整合Junit单元测试"><a href="#spring整合Junit单元测试" class="headerlink" title="spring整合Junit单元测试"></a>spring整合Junit单元测试</h3><ol>
<li>导入spring整合junit的jar</li>
<li>使用junit提供的一个注解把原有的main方法替换了，替换成@RunWith(SpringJunit4ClassRunner.class)</li>
<li>告知spring的运行器，spring和ioc创建居于xml还是注解，并说明位置@contextConfiguration<ol>
<li>localtions：指定xml文件的位置，加上classpath关键字。</li>
<li>classes：指定注解类所在的位置。</li>
</ol>
</li>
</ol>
<p>使用spring5.x时，要使用junit的jar包4.12版本及以上。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>连接池在项目启动的时候会创建一些连接，从而避免了数据库连接的操作。</p>
<p>在项目启动的时候，线程池统一管理这些线程。</p>
<ol>
<li>前置通知： 开始事务</li>
<li>后置通知：提交事务</li>
<li>异常通知：回滚</li>
<li>最终通知：关闭连接</li>
</ol>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>特点：字节码随用随创建，随用随加载</p>
<p>作用：不修改源码的基础上对方法增强</p>
<p>分类：</p>
<ol>
<li>基于接口的动态代理</li>
<li>基于子类的动态代理</li>
</ol>
<h4 id="基于接口的动态代理："><a href="#基于接口的动态代理：" class="headerlink" title="基于接口的动态代理："></a>基于接口的动态代理：</h4><ol>
<li>涉及的类：Proxy</li>
<li>提供者：JDK官方</li>
</ol>
<p>如何创建代理对象：</p>
<ol>
<li>使用Proxy类中的newProxyInstance方法</li>
</ol>
<p>创建代理对象的要求：</p>
<ol>
<li>被代理类最少实现一个接口，如果没有则不能使用</li>
</ol>
<p>newProxyInstance方法的参数：</p>
<ol>
<li>ClassLoader：类加载器。用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。</li>
<li>Class[]：字节码数组。用于让代理对象和被代理对象拥有相同的方法。固定写法。</li>
<li>InvocationHandler：用于提供增强的代码。一般都是一些接口地实现类，通常是匿名内部类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Proxy.newProxyInstance(producer.getClass().getClassLoader(),producer.getClass().getIntergaces(),</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">InvocationHander</span>()&#123;</span><br><span class="line">         <span class="comment">//作用：执行被代理对象的任何接口方法都会经过该方法，方法参数的意义：proxy代理对象的引用，method当前方法的执行，args当前方法所需的参数，return和被代理对象方法相同的返回值。</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy,Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h4><p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifacId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifacId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1_3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>设计的类：Enhancer</li>
<li>提供者：第三方cglib</li>
</ol>
<p>如何创建代理对象：</p>
<ol>
<li>使用Enhancer类中的create方法</li>
</ol>
<p>创建代理对象的要求：</p>
<ol>
<li>被代理类不是最终类。</li>
</ol>
<p>create方法的参数：</p>
<ol>
<li>Class：字节码。用于被代理对象的字节码</li>
<li>Callback：用于提供增强的代码。一般都是一些接口地实现类，通常是匿名内部类。一般都写该接口的子接口实现类：MethodInterceptor</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Producer producer</span><br><span class="line">Enhancer.create(producer.getClass(),<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>()&#123;</span><br><span class="line">    <span class="comment">//MethodProxy 当前执行方法的代理对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object proxy,Method method,Object[] args,MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>Aspect Oriented Programming 面向切面编程。</p>
<p><strong>作用：</strong>在程序运行期间，不修改源码对已有方法进行增强。</p>
<p><strong>优势：</strong></p>
<ol>
<li><p>减少重复代码</p>
</li>
<li><p>提高开发效率</p>
</li>
<li><p>维护方便</p>
</li>
</ol>
<p>实现方式：使用动态代理技术</p>
<h2 id="Spring的AOP"><a href="#Spring的AOP" class="headerlink" title="Spring的AOP"></a>Spring的AOP</h2><h4 id="AOP中的术语："><a href="#AOP中的术语：" class="headerlink" title="AOP中的术语："></a>AOP中的术语：</h4><ol>
<li>**Joinpoint **连接点：指那些被拦截到的点。在 spring 中,这些点指的是方法。</li>
<li><strong>Pointcut</strong> 切入点：指我们要对哪些 Joinpoint 进行拦截的定义。</li>
<li><strong>Advice(通知/增强):</strong> 指拦截到 Joinpoint 之后所要做的事情就是通知。通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。</li>
<li>**Introduction(引介):**引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。</li>
<li>**Target(目标对象):**代理的目标对象。</li>
<li>**Weaving(织入):**是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。</li>
<li>**Proxy（代理）:**一个类被 AOP 织入增强后，就产生一个结果代理类。</li>
<li>**Aspect(切面):**是切入点和通知（引介）的结合。</li>
</ol>
<h4 id="运行阶段Spring-框架："><a href="#运行阶段Spring-框架：" class="headerlink" title="运行阶段Spring 框架："></a>运行阶段Spring 框架：</h4><p>Spring框架监听切入点方法的执行。一旦监听到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成功能的代码逻辑运行。</p>
<h3 id="基于配置的springAOP"><a href="#基于配置的springAOP" class="headerlink" title="基于配置的springAOP"></a>基于配置的springAOP</h3><ol>
<li><p>配置spring的ioc进行service对象bean配置</p>
</li>
<li><p>配置Logger 日志AOP类进行对象bean配置</p>
</li>
<li><p>配置aop：</p>
<ol>
<li>```xml<br><a href="aop:config">aop:config</a><pre><code>&lt;!-- 配置切入顶啊表达式 id唯一表示 exxpression指定表达式内容  在aop:aspect标签中，只能在该标签中使用，可以写在外面--&gt;
    &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(public void com.genuine.service.impl.*.*(..))&quot;/&gt;
    &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;
        &lt;!-- 前置通知 --&gt;
        &lt;aop:before method=&quot;beforePrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt;
        &lt;!-- 后置通知 --&gt;
        &lt;aop:after-returning method=&quot;afterReturningPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-returning&gt;
        &lt;!-- 异常通知 --&gt;
        &lt;aop:after-throwing method=&quot;afterThrowingPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-throwing&gt;
        &lt;!-- 最终通知 --&gt;
        &lt;aop:after method=&quot;afterPrintLog&quot; pointcut=&quot;execution(public void com.genuine.service.impl.*.*(..))&quot;&gt;&lt;/aop:after&gt;

        &lt;!-- 环绕通知 --&gt;
        &lt;aop:around method=&quot;aroundPrintLog&quot; pointcut=&quot;execution(public void com.genuine.service
    &lt;/aop:aspect&gt;
</code></pre>
</aop:config><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. Logger类中环绕通知书写规范：</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123;</span><br><span class="line">           Object rtValue = null;</span><br><span class="line">           try &#123;</span><br><span class="line">               Object[] args = pjp.getArgs();</span><br><span class="line">               System.out.println(&quot;前置Logger类的beforePrintLog方法开始记录日志。。。&quot;);</span><br><span class="line">               </span><br><span class="line">               rtValue = pjp.proceed();//明确调用业务层方法（切入点方法）</span><br><span class="line">               </span><br><span class="line">               System.out.println(&quot;后置Logger类的afterReturningPrintLog方法开始记录日志。。。&quot;);</span><br><span class="line">               return rtValue;</span><br><span class="line">           &#125; catch (Throwable t) &#123;</span><br><span class="line">               System.out.println(&quot;异常Logger类的afterThrowingPrintLog方法开始记录日志。。。&quot;);</span><br><span class="line">               throw new RuntimeException(t);</span><br><span class="line">           &#125;finally &#123;</span><br><span class="line">               System.out.println(&quot;最终Logger类的afterPrintLog方法开始记录日志。。。&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="基于注解的springAOP"><a href="#基于注解的springAOP" class="headerlink" title="基于注解的springAOP"></a>基于注解的springAOP</h3><ol>
<li><p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置spring创建容器时要扫描的包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.genuine&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置spring开启注解AOP的支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Logger类细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;logger&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//表示当前类是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="comment">//切点表达式</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.genuine.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Before(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="meta">@After(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="meta">@Around(&quot;pt1()&quot;)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="保证idea的maven的jdk保持不变"><a href="#保证idea的maven的jdk保持不变" class="headerlink" title="保证idea的maven的jdk保持不变"></a>保证idea的maven的jdk保持不变</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在pom.xml文件中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Spring的JdbcTemplate"><a href="#Spring的JdbcTemplate" class="headerlink" title="Spring的JdbcTemplate"></a>Spring的JdbcTemplate</h2><ol>
<li><p>需要导入ioc，jdbc，tx，mysql依赖。</p>
</li>
<li><p>编写是实体类，需要实现Serializable接口。私有属性，get/set/toString方法。</p>
</li>
<li><p>JdbcTemplate简单使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//准备数据源：spring 的内置数据源</span></span><br><span class="line"><span class="type">DriverManagerDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>();</span><br><span class="line">ds.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">ds.setUrl(<span class="string">&quot;jdbc:mysql://39.97.117.252:3306/essy?useUnicode=true&amp;charcterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;severTimezone=UTC&quot;</span>);</span><br><span class="line">ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">ds.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//1.创建JdbcTemplate对象</span></span><br><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">jt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line"><span class="comment">//给jt设置数据源</span></span><br><span class="line">jt.setDataSource(ds);</span><br><span class="line"><span class="comment">//2.执行操作</span></span><br><span class="line">jt.execute(<span class="string">&quot;insert into account (name,money) values (&#x27;ccc&#x27;,1000)&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>配置数据源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置JdbcTemplate --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://39.97.117.252:3306/essy?useUnicode=true<span class="symbol">&amp;amp;</span>charcterEncoding=utf8<span class="symbol">&amp;amp;</span>autoReconnect=true<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>severTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/<span class="number">1.</span> 获取容器</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="comment">//2. 获取对象</span></span><br><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">jt</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>,JdbcTemplate.class);</span><br></pre></td></tr></table></figure></li>
<li><p>JdbcTemplate的CURD</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存</span></span><br><span class="line">jt.update(<span class="string">&quot;insert into account (name,money) values (&#x27;eee&#x27;,1000)&quot;</span>);</span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line">jt.update(<span class="string">&quot;update account set name=?,money=? where id=?&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="number">4567</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">jt.update(<span class="string">&quot;delete from account where id=?&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//查询所有 需要new BeanPropertyRowMapper对象</span></span><br><span class="line"><span class="comment">//List&lt;Account&gt; accounts = jt.query(&quot;select * from account where money &gt; ?&quot;, new AccountRowMapper(), 99d);//这样方式需要定义account的封装策略</span></span><br><span class="line">List&lt;Account&gt; accounts = jt.query(<span class="string">&quot;select * from account where money &gt; ?&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class), <span class="number">99d</span>);</span><br><span class="line"><span class="keyword">for</span> (Account account :accounts) &#123;System.out.println(account);&#125;</span><br><span class="line"><span class="comment">//查询一个</span></span><br><span class="line">List&lt;Account&gt; account = jt.query(<span class="string">&quot;select * from account where id = ?&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class), <span class="number">1</span>);</span><br><span class="line">System.out.println(account.isEmpty()?<span class="string">&quot;没有内容&quot;</span> : account.get(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//查询返回一行一列（使用聚合函数，但不加group by字句）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jt.queryForObject(<span class="string">&quot;select count(*) from account&quot;</span>,Integer.class);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义account的封装策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountRowMapper</span> <span class="keyword">implements</span> <span class="title class_">RowMapper</span>&lt;Account&gt;&#123;</span><br><span class="line">    <span class="comment">//把结果及中的数据封装到account中,由spring把每个account加到集合中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">mapRow</span><span class="params">(ResultSet resultSet, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        account.setId(resultSet.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        account.setName(resultSet.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        account.setMoney(resultSet.getDouble(<span class="string">&quot;money&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="SpringMVC-1"><a href="#SpringMVC-1" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>基于Java实现的MVC设计模型的请求驱动类型的轻量级Web框架</p>
<h3 id="SpringMVC的优势"><a href="#SpringMVC的优势" class="headerlink" title="SpringMVC的优势"></a>SpringMVC的优势</h3><ol>
<li>清晰的角色划分：<ol>
<li><p>前端控制器DispatcherServlet：是整个流程控制的中心，由</p>
<p>它调用其它组件处理用户的请求，在降低了组件之间的耦合性。</p>
</li>
<li><p>处理器映射器HandlerMapping：根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
</li>
<li><p>处理器Handler：开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由</p>
<p>Handler 对具体的用户请求进行处理。</p>
</li>
<li><p>处理器适配器HandlerAdapter：通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理</p>
<p>器进行执行。</p>
</li>
<li><p>视图解析器ViewResolver：负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>
</li>
<li><p>视图View：要通过页面标签或页面模版技术将模型数据通过页面展示给用户。</p>
</li>
<li><p>验证器</p>
</li>
<li><p>命令对象</p>
</li>
<li><p>表单对象</p>
</li>
</ol>
</li>
<li>分工明确，容易扩展。</li>
<li>。。。</li>
</ol>
<h3 id="SpringMVC与Struts2的优略分析"><a href="#SpringMVC与Struts2的优略分析" class="headerlink" title="SpringMVC与Struts2的优略分析"></a>SpringMVC与Struts2的优略分析</h3><p>共同点：</p>
<ol>
<li>都是表现成框架，基于MVC模型编写</li>
<li>底层都离不开原始的ServletAPI</li>
<li>处理请求的机制都是一个核心控制器</li>
</ol>
<p>区别：</p>
<ol>
<li>SpringMVC的入口是Servlet，而Struts2是Filter</li>
<li>SpringMVC是基于方法设计的，而Struts2是基于类（多例的，每次执行都会创建一个动作类）</li>
<li>SpringMVC更加简洁，同时支持JSR303（JavaBean参数校验的标准），处理ajax的请求更方便。</li>
<li>Struts2的OGNL表达式时页面的开发效率相比SpringMVC更高，但执行效率没有JSTL高，尤其是struts2的表单标签，远没有html执行效率高。</li>
</ol>
<h2 id="SpringMVC入门程序"><a href="#SpringMVC入门程序" class="headerlink" title="SpringMVC入门程序"></a>SpringMVC入门程序</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol>
<li><p>创建Maven项目</p>
</li>
<li><p>选择maven-archetype-webapp模型</p>
</li>
<li><p>选择自己maven仓库</p>
</li>
<li><p>为解决maven项目创建过慢的问题在Properties中添加一个键值对archetypeCatalog：internal</p>
</li>
<li><p>在项目目录下创建java和resourecs文件夹，并Mark directory as 对应的选项。</p>
</li>
<li><p>导入pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span> $&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  前端控制器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- / 表示：所有的路径都会经过 dispatcherServlet --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>部署项目-环境搭建完成</p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/10/12/zCs9JenfOpXtH1i.png" alt="image.png"></p>
<h4 id="入门程序-springmvc-xml"><a href="#入门程序-springmvc-xml" class="headerlink" title="入门程序-springmvc.xml"></a>入门程序-springmvc.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.genuine&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    视图解析器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        会找该目录下的文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        后缀名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    开启springmvc注解的支持配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h4><ol>
<li>启动服务器，加载一些配置文件<ol>
<li>DispatcherServlet对象创建</li>
<li>springmvc.xml被加载</li>
<li>HelloController创建成对象</li>
</ol>
</li>
<li>发送请求，后台处理请求<ol>
<li>DispatcherServlet：前端控制器，控制作用，指挥中心</li>
<li>找到控制器类方法</li>
<li>InternalResourceViewResolver，通过视图解析器的包名和后缀名。</li>
<li>找到对应的jsp页面</li>
<li>返回给前端控制器再给浏览器。</li>
</ol>
</li>
</ol>
<p><img src="https://i.loli.net/2020/10/12/cRlNruMIPqY3FdE.png" alt="image.png"></p>
<p>SpringMVC框架基于组件方式执行流程：</p>
<ol>
<li><p>Request请求给前端控制器（控制整个流程 ）。</p>
</li>
<li><p>前端控制器根据请求通过处理器映射器<strong>找到</strong>对应的Controller类中的方法。</p>
</li>
<li><p>通过处理器适配器去执行方法返回结果</p>
</li>
<li><p>通过视图解析器找页面并返回给前端控制器</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。</p>
<p>使用自动加载 RequestMappingHandlerMapping （处理映射器）和RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用替代注解处理器和适配器的配置。</p>
<h3 id="注解讲解"><a href="#注解讲解" class="headerlink" title="注解讲解"></a>注解讲解</h3><ol>
<li><p>@RequestMapping</p>
<ol>
<li>属性path与value：作用相同，指路径</li>
<li>属性method：RequestMethod枚举类，请求方式</li>
<li>属性params：指定限制请求参数的条件</li>
<li>属性headers：用于指定限制请求消息头的条件</li>
</ol>
</li>
<li><p>@RequestParam：把请求中指定名称的参数给控制器中的形参赋值（由于可能两者的参数名不同）。以下方法均用于形参中</p>
<ol>
<li>value：请求参数中的名称。</li>
<li>required：请求参数中是否必须提供此参数。默认值：true。</li>
</ol>
</li>
<li><p>@RequestBody：用于获取请求体内容，直接使用得到是 key=value&amp;key=value…结构的字符串数据。get不适用</p>
<ol>
<li>required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。</li>
</ol>
</li>
<li><p>@PathVariable：用于绑定 url 中的占位符。例如：请求 url 中 /delete/**{id}<strong>，这个</strong>{id}**就是 url 占位符。url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。</p>
<ol>
<li>value：用于指定 url 中占位符名称。</li>
<li>required：是否必须提供占位符。</li>
</ol>
</li>
<li><p>@RequestHeader：用于获取请求消息头。</p>
<ol>
<li>value：提供消息头名称</li>
<li>required：是否必须有此消息头</li>
</ol>
</li>
<li><p>@CookieValue：用于把指定 cookie 名称的值传入控制器方法参数。</p>
<ol>
<li>value：指定 cookie 的名称。</li>
<li>required：是否必须有此 cookie。</li>
</ol>
</li>
<li><p>@ModelAttribute</p>
<ol>
<li>出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。</li>
<li>出现在参数上，获取指定的数据给参数赋值。</li>
<li>value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。</li>
</ol>
</li>
<li><p>@SessionAttribute：用于多次执行控制器方法间的参数共享。</p>
<ol>
<li>value：用于指定存入的属性名称</li>
<li>type：用于指定存入的数据类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SessionAttributes(value =&#123;&quot;username&quot;,&quot;password&quot;&#125;,types=&#123;Integer.class&#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionAttributeController</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 把数据存入 SessionAttribute</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* Model 是 spring 提供的一个接口，该接口有一个实现类 ExtendedModelMap</span></span><br><span class="line"><span class="comment">* 该类继承了 ModelMap，而 ModelMap 就是 LinkedHashMap 子类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testPut&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testPut</span><span class="params">(Model model)</span>&#123; </span><br><span class="line"> model.addAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;泰斯特&quot;</span>); </span><br><span class="line"> model.addAttribute(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>); </span><br><span class="line"> model.addAttribute(<span class="string">&quot;age&quot;</span>, <span class="number">31</span>); </span><br><span class="line"> <span class="comment">//跳转之前将数据保存到 username、password 和 age 中，因为注解@SessionAttribute 中有这几个参数 </span></span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h3><h4 id="绑定的机制"><a href="#绑定的机制" class="headerlink" title="绑定的机制"></a>绑定的机制</h4><p>表单中请求参数都是基于 key=value 。</p>
<h4 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a><strong>支持的数据类型</strong></h4><ol>
<li><p><strong>基本类型</strong></p>
<ol>
<li>基本类型和String类型：参数名称和方法的形参名称保持一致。(严格区分大小写)。</li>
</ol>
</li>
<li><p><strong>POJO</strong> <strong>类型参数</strong></p>
<ol>
<li><p>实体类以及关联的实体类：表单中参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;address.provinceName&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>数组和集合类型参数</strong></p>
<ol>
<li><p>List 结构和 Map 结构的集合（包括数组）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;list[0].name&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;map[&#x27;one&#x27;].name&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>接收的请求参数是 json 格式数据。需要借助一个注解实现</p>
</li>
</ol>
</li>
<li><p><strong>特殊类型转换要求，需要我们自己编写自定义类型转换器。</strong></p>
<ol>
<li><p><strong>定义一个类，实现</strong> <strong>Converter</strong> <strong>接口，该接口有两个泛型。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String,Date&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">convert</span><span class="params">(String source)</span>&#123;</span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(source)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;请输入要转换的日期&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            format = <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> format.parse(source);</span><br><span class="line">            <span class="keyword">return</span> date;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入日期有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>在</strong> <strong>spring</strong> <strong>配置文件中配置类型转换器。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置类型转换器工厂 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;converterService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 给工厂注入一个新的类型转换器 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- 配置自定义类型转换器 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.web.converter.StringToDateConverter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>在</strong> <strong>annotation-driven</strong> <strong>标签中引用配置的类型转换服务</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用自定义类型转换器 --&gt;</span> <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;converterService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="请求参数乱码问题"><a href="#请求参数乱码问题" class="headerlink" title="请求参数乱码问题"></a><strong>请求参数乱码问题</strong></h4><p>在post方式会出现乱码问题，可以配置过滤器解决。</p>
<p>在 web.xml 中配置一个过滤器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 springMVC 编码过滤器 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 设置过滤器中的属性值 --&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line"> 		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 启动过滤器 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 过滤所有请求 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-ServletAPI-对象作为方法参数"><a href="#使用-ServletAPI-对象作为方法参数" class="headerlink" title="使用 ServletAPI 对象作为方法参数"></a><strong>使用</strong> <strong>ServletAPI</strong> <strong>对象作为方法参数</strong></h4><p>SpringMVC 支持使用原始 ServletAPI 对象作为控制器方法的参数。<strong>把需要的对象，直接写在控制的方法参数中使用。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">testServletAPI</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                            HttpServletResponse response,</span></span><br><span class="line"><span class="params">                            HttpSession session)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于HiddentHttpMethodFilter的多种请求方式"><a href="#基于HiddentHttpMethodFilter的多种请求方式" class="headerlink" title="基于HiddentHttpMethodFilter的多种请求方式"></a>基于HiddentHttpMethodFilter的多种请求方式</h3><p>由于浏览器 form 表单只支持 GET 与 POST 请求，而 DELETE、PUT 等 method 并不支持，Spring3.0 添加了一个过滤器，可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持 GET、POST、PUT 与 DELETE 请求。</p>
<p>使用方法：</p>
<ol>
<li><p>在 web.xml 中配置该过滤器。</p>
</li>
<li><p>请求方式必须使用 post 请求。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;springmvc/testRestPUT/1&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">用户名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;更新&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>按照要求提供_method 请求参数，该参数的取值就是我们需要的请求方式。</p>
</li>
</ol>
<h2 id="响应数据和结果视图"><a href="#响应数据和结果视图" class="headerlink" title="响应数据和结果视图"></a>响应数据和结果视图</h2><h3 id="1-按返回值分类"><a href="#1-按返回值分类" class="headerlink" title="1.按返回值分类"></a>1.按返回值分类</h3><h4 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定逻辑视图名，经过视图解析器解析为 jsp 物理路径：/WEB-INF/pages/success.jsp</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testReturnString&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testReturnString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-void"><a href="#2-void" class="headerlink" title="2. void"></a>2. void</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testReturnVoid&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReturnVoid</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> </span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 controller 方法形参上可以定义 request 和 response，使用 request 或 response 指定响应结果</p>
<ol>
<li><p>使用 request 转发页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/pages/success.jsp&quot;</span>).forward(request, </span><br><span class="line">response);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 response 页面重定向</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendREdirect(<span class="string">&quot;testReturnString&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 response 指定响应结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">response.getWriter().write(<span class="string">&quot;json 串&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-ModelAndView"><a href="#3-ModelAndView" class="headerlink" title="3.ModelAndView"></a>3.ModelAndView</h4><p>ModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。</p>
<p>该对象中有两个方法：</p>
<p><img src="https://i.loli.net/2020/10/15/GDQkdFzswOPTnUu.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/10/15/GDQkdFzswOPTnUu.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testReturnModelAndView&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testReturnModelAndView</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    mv.addObject(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    mv.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;/head&gt; &lt;body&gt;</span><br><span class="line">执行成功！</span><br><span class="line">$&#123;requestScope.username&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>注意：在页面上获取使用的是 requestScope.username 取的，所以返回 ModelAndView 类型时，浏览器跳转只能是请求转发。</p>
<h3 id="2-转发和重定向"><a href="#2-转发和重定向" class="headerlink" title="2.转发和重定向"></a>2.转发和重定向</h3><h4 id="1-forward转发"><a href="#1-forward转发" class="headerlink" title="1.forward转发"></a>1.forward转发</h4><p>controller 方法在提供了 String 类型的返回值之后，默认就是请求转发。我们也可以写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/WEB-INF/pages/success.jsp&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/user/findAll&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-Redirect重定向"><a href="#2-Redirect重定向" class="headerlink" title="2. Redirect重定向"></a>2. Redirect重定向</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:testReturnModelAndView&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/add.jsp&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果是重定向到 jsp 页面，则 jsp 页面不能写在 WEB-INF 目录中，否则无法找到。</p>
<h3 id="3-ResponseBody-响应-json-数据"><a href="#3-ResponseBody-响应-json-数据" class="headerlink" title="3.ResponseBody 响应 json 数据"></a>3.ResponseBody 响应 json 数据</h3><p>该注解用于将 Controller 的方法返回的对象，通过 HttpMessageConverter 接口转换为指定格式的数据如：json,xml 等，通过 Response 响应给客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseJson&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> Account <span class="title function_">testResponseJson</span><span class="params">(<span class="meta">@RequestBody</span> Account account)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;异步请求：&quot;</span>+account);</span><br><span class="line"><span class="keyword">return</span> account; &#125;</span><br></pre></td></tr></table></figure>

<p>使用需要要导入jar包jackson。</p>
<h2 id="SpringMVC文件上传"><a href="#SpringMVC文件上传" class="headerlink" title="SpringMVC文件上传"></a>SpringMVC文件上传</h2><h3 id="1-文件上传回顾"><a href="#1-文件上传回顾" class="headerlink" title="1.文件上传回顾"></a>1.文件上传回顾</h3><p>导入文件上传的jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>动态代理</title>
    <url>/2023/04/24/java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>首先了解下静态代理。</p>
<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>目标类和代理类实现了相同的接口，并且代理类中依赖了目标类。在代理类的方法中调用目标类方法，并做一些增强性的工作。</p>
<h2 id="静态代理的缺陷"><a href="#静态代理的缺陷" class="headerlink" title="静态代理的缺陷"></a>静态代理的缺陷</h2><p>需要手动为每个目标类编写对应的代理类。如果当前系统已经有成百上千个类，工作量太大了。</p>
<p>当接口改变时，不仅目标类需要改变，所有的代理类都需要进行相应的变化。</p>
<p>目标：如何少写或者不写代理类，却能完成代理功能。</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>在程序的执行过程中，使用jdk的反射机制，创建代理对象，并动态的指定代理的目标类。</p>
<h2 id="常用的两种实现方式"><a href="#常用的两种实现方式" class="headerlink" title="常用的两种实现方式"></a>常用的两种实现方式</h2><p>jdk代理</p>
<p>cjlib代理</p>
<h2 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h2><p>基于Java的反射机制实现，使用jdk反射包下的Proxy和InvocationHandler实现代理对象的动态创建。（jdk动态代理要求目标对象必须实现接口）</p>
<h3 id="InvocationHandler接口"><a href="#InvocationHandler接口" class="headerlink" title="InvocationHandler接口"></a>InvocationHandler接口</h3><p>接口中只有一个方法 ：invoke()，代理类要完成的功能写在invoke()方法中。</p>
<p>代理类需要的工作：</p>
<p>调用目标类的方法。</p>
<p>功能增强，在目标方法调用前后，增加功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Object proxy：jdk创建的代理对象，无需赋值</span></span><br><span class="line"><span class="comment">* Method method：目标类中的方法，通过Method可以执行某个目标类的方法</span></span><br><span class="line"><span class="comment">* Object[] args：目标类中方法的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br></pre></td></tr></table></figure>

<h3 id="proxy类"><a href="#proxy类" class="headerlink" title="proxy类"></a>proxy类</h3><p>最核心的类，使用静态方法 newProxyInstance() ，创建代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassLoader loader：类加载器，负责向内存中加载对象（需要使用目标对象的类加载器）</span></span><br><span class="line"><span class="comment">* Class&lt;?&gt;[] interfaces：目标对象实现的接口 </span></span><br><span class="line"><span class="comment">* InvocationHandler h：我们自己写的代理类需要实现的功能 返回值就是代理对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、创建目标对象</span></span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="comment">//2、创建invocationHandler对象</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(calculator);</span><br><span class="line"></span><br><span class="line">        <span class="type">Calculate</span> <span class="variable">proxyInstance</span> <span class="operator">=</span>(Calculate) Proxy.newProxyInstance(calculator.getClass().getClassLoader(), calculator.getClass().getInterfaces(),</span><br><span class="line">                invocationHandler);</span><br><span class="line">        proxyInstance.add(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="cjlib动态代理"><a href="#cjlib动态代理" class="headerlink" title="cjlib动态代理"></a>cjlib动态代理</h2><p>cglib是第三方的工具库，可以创建代理对象。</p>
<p>cglib的原理是继承，cglib通过继承目标类，创建它的子类，在子类中重写父类中的方法，实现功能的修改。</p>
<p>cglib要求目标类不能是final，且目标类的方法不能是final修饰的。</p>
<p><a href="https://blog.csdn.net/hc1285653662/article/details/127199791">原文链接</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>http是无状态的吗？怎么解决的？</title>
    <url>/2023/04/25/Web/http%E6%97%A0%E7%8A%B6%E6%80%81%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84/</url>
    <content><![CDATA[<p>为什么说http是无状态的？它不是一直在维持tcp的长连接吗？</p>
<h1 id="什么是http无状态"><a href="#什么是http无状态" class="headerlink" title="什么是http无状态"></a>什么是http无状态</h1><p>http的每次请求都是一次单独的请求。</p>
<h2 id="http无状态的优点"><a href="#http无状态的优点" class="headerlink" title="http无状态的优点"></a>http无状态的优点</h2><p>不需要额外资源记录状态信息。实现简单、服务器负担少。</p>
<p>对于有状态的协议，如果将会话状态与连接绑定在一起，意外断开，整个会话就会丢失。重新连接一般需要从头开始。</p>
<h2 id="http无状态的缺点"><a href="#http无状态的缺点" class="headerlink" title="http无状态的缺点"></a>http无状态的缺点</h2><p>每次请求都是独立的，所以每个请求需要的所有信息都必须包含在请求中一次发送到服务端。导致消息结构比较复杂，必须能够支持大量元数据。</p>
<h1 id="解决http无状态的方案"><a href="#解决http无状态的方案" class="headerlink" title="解决http无状态的方案"></a>解决http无状态的方案</h1><h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><p>身份验证流程：用户登录到服务器验证成功后，相关数据保存在当前会话中，服务器发挥session_id，写入到用户的cookie中。后续的请求需要在Cookie中取出session_id传给服务器，服务器根据session_id检索之前保存的数据，确认用户身份。</p>
<p>弊端：Session信息存储在服务器，必然占用内存。用户多了后，开销增大，为了提高效率，需要分布式、负载均衡。</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>Token传递过程跟Cookie类似，只是传递对象变成了Token。</p>
<ol>
<li>用户使用用户名、密码请求服务器后。</li>
<li>服务器生成 Token并响应给客户端。</li>
<li>客户端再次请求时带上 Token，服务器取到 Token 进行认证鉴权。</li>
<li>认证通过，服务器响应数据。认证不通过，跳转登陆。</li>
</ol>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT时不需要查库的，所需的基础信息可以放在JWT中，服务器只需要判断用户是否可以拥有接口权限，JWT的内容不是无限的，其他信息需要通过id查询数据库。</p>
<ol>
<li>客户端使用账户密码请求登录接口</li>
<li>服务器使用签名密钥生成JWT ,然后返回JWT给客户端</li>
<li>客户端再次向服务端请求其他接口时带上JWT</li>
<li>服务端接收到JWT后验证签名的有效性.对客户端做出相应的响应</li>
</ol>
<h3 id="和Token的区别"><a href="#和Token的区别" class="headerlink" title="和Token的区别"></a>和Token的区别</h3><p>token需要查库验证token是否有效，JWT不用查库或少查库，只需在服务器验证。用户的信息已被加密其中，只需要校验即可，校验JWT自己实现。</p>
<p>为什么JWT不用验证token是否有效</p>
<h3 id="JWT查询流程"><a href="#JWT查询流程" class="headerlink" title="JWT查询流程"></a>JWT查询流程</h3><ol>
<li>解析JWT</li>
<li>判断签名是否正确，根据生成签名时使用的密钥和加密算法，这步之后说明是可信的。</li>
<li>判断JWT token是否过期，根据exp，判断是否是VIP，根据isVip</li>
</ol>
<p><a href="https://blog.csdn.net/weixin_50736511/article/details/127996819">原文地址</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件</title>
    <url>/2020/07/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>非底层操作系统软件，非业务应用软件，不是直接给最终用户使用的，不能直接给客户带来价值的软件统称为中间件。  </p>
<h3 id="什么是消息中间件"><a href="#什么是消息中间件" class="headerlink" title="什么是消息中间件"></a>什么是消息中间件</h3><p>关注数据的发送和接受，利用高效可靠的异步消息传递机制集成分布式系统。  </p>
<h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>Java消息服务（Java Message Service），一个Java平台中关于面向消息中间件的API，用于两个应用程序之间，或分布式系统中发送消息，进行异步通信。  </p>
<h4 id="JSM相关概念"><a href="#JSM相关概念" class="headerlink" title="JSM相关概念"></a>JSM相关概念</h4><p>提供者：实现JSM规范的消息中间件服务器<br>客户端：发送或接受消息的应用程序<br>生产者/发布者：创建并发送消息的客户端<br>消费者/订阅者：接受并处理消息的客户端<br>消息：应用程序之间传递的数据内容<br>消息模式：在客户端之间传递消息的方式，JSM中定义了主题和队列两种模式。</p>
<h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>advanced massage queuing protocol 是一个提供统一服务的应用层标准协议，基于此协议的客户端与消息中间件传递消息，不受客户端/中间件不同产品，不同开发语言等条件的限制。  </p>
<h3 id="常见消息中间件"><a href="#常见消息中间件" class="headerlink" title="常见消息中间件"></a>常见消息中间件</h3><h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><p>完全支持JMS1.1和J2EE1.4规范的JMS Provider实现。<br>优点：遵循JMS规范，安装部署方便。    </p>
<h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>开源的AMQP实现，服务端采用Erlang语言编写。用于分布式系统中存储转发消息。<br>优点：继承Erlang天生的并发性，最初用于金融行业，稳定性，安全性有保障。  </p>
<h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>高吞吐量的分布式发布订阅消息系统，分布式的、分区的、可靠的分布式日志存储服务。<br>优点：依赖zk，可动态扩展节点，高性能、高吞吐量、无限扩容，消息可指定追溯。  </p>
<h3 id="队列模式"><a href="#队列模式" class="headerlink" title="队列模式"></a>队列模式</h3><p>客户端包括生产者和消费者<br>队列中的消息只能被一个消费者消费<br>消费者可以随时消费队列中的消息  </p>
<h3 id="主题模型"><a href="#主题模型" class="headerlink" title="主题模型"></a>主题模型</h3><p>客户端包括发布者和订阅者<br>主题中的消息被所有订阅者消费<br>消费者不能消费订阅之前就发送到主题中的消息  </p>
<h3 id="JMS编码接口"><a href="#JMS编码接口" class="headerlink" title="JMS编码接口"></a>JMS编码接口</h3><p>ConnectionFactory 用于创建连接到消息中间件的连接工厂<br>Connection 应用程序和消息服务器之间的通信链路<br>Destination 消息发布和接受的地点，包括队列或主题<br>Session 一个单线程的上下文，用于发送和接受消息<br>MessageConsumer 由会话创建，用于接受发送到目标的消息<br>MessageProducer 有会话创建，用于发送消息到目标<br>Message 是在消费者和生产者之间传送的对象，消息头，一组消息属性，一个消息体。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch使用</title>
    <url>/2020/11/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticsearch/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。</p>
<p>Elasticsearch 是一个建立在全文搜索引擎 Apache Lucene(TM) 基础上的搜索引擎，可以说 Lucene 是当今最先进，最高效的全功能开源搜索引擎框架。</p>
<p>Elasticsearch 是一个<strong>分布式文档储存中间件</strong>，将信息储存<strong>已序列化为 JSON 文档的复杂数据结构</strong>。</p>
<p>当你在一个集群中有多个节点时，储存的文档分布在整个集群里面，并且立刻可以从任意节点去访问。</p>
<p>当文档被储存时，它将建立索引并且近实时（1s）被搜索。 Elasticsearch 使用一种被称为<strong>倒排索引</strong>的数据结构，该结构支持快速全文搜索。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>可扩展高达PB级的结构化和非结构化数据。</li>
<li>可以用来替代MongoDB和RavenDB等做文档存储。</li>
<li>使用非标准化来提高搜索性能。</li>
<li>是受欢迎的企业搜索引擎之一，目前被许多大型组织使用，如Wikipedia，The Guardian，StackOverflow，GitHub等。</li>
<li>Elasticsearch是开放源代码，可在Apache许可证版本<code>2.0</code>下提供。</li>
</ul>
<h3 id="Lucene与Elasticsearch关系？"><a href="#Lucene与Elasticsearch关系？" class="headerlink" title="Lucene与Elasticsearch关系？"></a>Lucene与Elasticsearch关系？</h3><p>Lucene不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。想要使用，必须使用Java将其直接集成到应用中，非常复杂，需要深入了解检索的相关知识来理解它是如何工作的。</p>
<h3 id="与Solr性能对比"><a href="#与Solr性能对比" class="headerlink" title="与Solr性能对比"></a>与Solr性能对比</h3><ul>
<li>对已有数据查询，solr更快。</li>
<li>建立索引是，se更快。</li>
<li>随着数据增加时，se远快于solr，se更适合于实时搜索。</li>
</ul>
<p>为什么搜索引擎远大于传统搜索：<strong>倒排索引</strong>。当数据导入se的时候，就会做分词，在搜索的时候也会分词，将同分词的数据传出。</p>
<h2 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h2><ul>
<li>节点：它指的是Elasticsearch的单个正在运行的实例。单个物理和虚拟服务器容纳多个节点，这取决于其物理资源的能力，如RAM，存储和处理能力。</li>
<li>集群：它是一个或多个节点的集合。 集群为整个数据提供跨所有节点的集合索引和搜索功能。</li>
<li>索引：它是不同类型的文档和文档属性的集合。索引还使用分片的概念来提高性能。 例如，一组文档包含社交网络应用的数据。</li>
<li>类型/映射：共享同一索引中存在的一组公共字段的文档的集合。</li>
<li>文档：它是以JSON格式定义的特定方式的字段集合。每个文档都属于一个类型并驻留在索引中。每个文档都与唯一标识符(称为UID)相关联。</li>
<li>碎片：索引被水平细分为碎片。这意味着每个碎片包含文档的所有属性，但包含的数量比索引少。水平分隔使碎片成为一个独立的节点，可以存储在任何节点中。主碎片是索引的原始水平部分，然后这些主碎片被复制到副本碎片中。</li>
<li>副本： Elasticsearch允许用户创建其索引和分片的副本。 复制不仅有助于在故障情况下增加数据的可用性，而且还通过在这些副本中执行并行搜索操作来提高搜索的性能。</li>
</ul>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>基于Java开发的，平台兼容性</li>
<li>实时的，一秒钟后，添加的文档可以在这个引擎中搜索得到。</li>
<li>分布式的，易于在任何大型组织中扩展和集成。</li>
<li>通过使用Elasticsearch中的网关概念，创建完整备份很容易。</li>
<li>与Apache Solr相比，在Elasticsearch中处理多租户非常容易。</li>
<li>Elasticsearch使用JSON对象作为响应，这使得可以使用不同的编程语言调用Elasticsearch服务器。</li>
<li>Elasticsearch支持几乎大部分文档类型，但不支持文本呈现的文档类型。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>Elasticsearch在处理请求和响应数据方面没有多语言和数据格式支持(仅在JSON中可用)，与Apache Solr不同，Elasticsearch不可以使用CSV，XML等格式。</li>
<li>Elasticsearch也有一些伤脑的问题发生，虽然在极少数情况下才会发生。</li>
</ul>
<h2 id="ES和RDBMS之间的比较"><a href="#ES和RDBMS之间的比较" class="headerlink" title="ES和RDBMS之间的比较"></a>ES和RDBMS之间的比较</h2><p><img src="https://i.loli.net/2020/11/19/Ur4yMzp5sev6Idx.jpg" alt="Elasticsearch和RDBMS之间的比较.jpg"></p>
<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><ol>
<li><p>安装jdk，要求版本7及以上</p>
</li>
<li><p>下载Elasticsearch</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/local/elasticsearch</span><br><span class="line">tar zxvf elasticsearch-7.4.2-linux-x86_64.tar.gz -C /usr/local/elasticsearch/</span><br><span class="line">cd /usr/local/elasticsearch/</span><br></pre></td></tr></table></figure></li>
<li><p>windows-解压zip包</p>
</li>
<li><p>进入到ES主目录和bin文件夹，windows运行elasticsearch.bt文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">cd</span> elasticsearch-x.x.x/bin</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">elasticsearch</span></span><br></pre></td></tr></table></figure></li>
<li><p>Elasticsearch Web界面的默认端口是<code>9200</code>，或者可以通过更改<code>bin</code>目录中的<code>elasticsearch.yml</code>文件中的<code>http.port</code>字段值来更改。可以通过浏览<code>http:// localhost:9200</code>来检查服务器是否已启动并正在运行。如果没有问题，它将返回一个JSON对象，其中包含有关安装的Elasticsearch信息有以下方式 </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;DESKTOP-PTE31DC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;elasticsearch&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_uuid&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;tBLwR6ofTeqdakp88Y_WTw&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;number&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;7.6.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_flavor&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;zip&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_hash&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;aa751e09be0a5072e8570670309b1f12348f023b&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2020-02-29T00:15:25.529771Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_snapshot&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lucene_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;8.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minimum_wire_compatibility_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6.8.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minimum_index_compatibility_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6.0.0-beta1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tagline&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>可以再Windows cmd中使用curl 进行交互</p>
</li>
<li><p>Linux安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/elasticsearch</span><br><span class="line">tar zxvf elasticsearch-7.3.1-linux-x86_64.tar.gz -C /usr/local/elasticsearch/</span><br><span class="line">cd /usr/local/elasticsearch</span><br><span class="line">cd bin/</span><br><span class="line">./elasticsearch</span><br><span class="line"></span><br><span class="line">如果jdk版本有问题需要</span><br><span class="line">cd jdk/</span><br><span class="line">复制路径</span><br><span class="line">pwd</span><br><span class="line">cd bin/</span><br><span class="line">使用自带的jdk</span><br><span class="line">vim elasticsearch-env</span><br><span class="line">JAVA_HOME=&quot;/usr/local/elasticsearch/elasticsearch-x.x.x/jdk/&quot;</span><br><span class="line">./elasticsearch</span><br><span class="line"></span><br><span class="line">不能使用root用户启动，需要创建新的用户组和用户</span><br><span class="line">groupadd es</span><br><span class="line">useradd es -g es</span><br><span class="line">su es</span><br><span class="line">su root</span><br><span class="line">root用户来授权</span><br><span class="line">chown -Rf es:es /usr/local/elasticsearch/</span><br><span class="line">su es</span><br><span class="line">./elasticsearch</span><br><span class="line"></span><br><span class="line">复制会话查看详情</span><br><span class="line">ps -ef|grep elasticsearch</span><br><span class="line">curl http://127.0.0.1:9200</span><br><span class="line"></span><br><span class="line">问题：远程浏览器使用需要配置</span><br><span class="line">cd config/</span><br><span class="line">vim elasticsearch.yml</span><br><span class="line"></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">问题1</span><br><span class="line">vim /etc/security/limits.conf</span><br><span class="line"></span><br><span class="line">es soft nofile 65535</span><br><span class="line">es hard nofile 65535</span><br><span class="line">es soft nproc 4096</span><br><span class="line">es hard nproc 4096</span><br><span class="line">问题2</span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">vm.max_map_count = 262144</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br><span class="line">问题3</span><br><span class="line">vim config/elasticsearch.yml</span><br><span class="line"></span><br><span class="line">discovery.seed_hosts: [&quot;81.70.204.157&quot;]</span><br><span class="line">cluster.initial_master_nodes: [&quot;81.70.204.157&quot;]</span><br><span class="line"></span><br><span class="line">问题4</span><br><span class="line">vim config/jvm.options</span><br><span class="line"></span><br><span class="line">把-XX:+UseConcMarkSweepGC注释</span><br><span class="line">添加-XX:+UseG1GC</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="搭建集群环境"><a href="#搭建集群环境" class="headerlink" title="搭建集群环境"></a>搭建集群环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/local/elasticsearch/es1</span><br><span class="line"></span><br><span class="line">tar zxvf elasticsearch-7.3.1-linux-x86_64.tar.gz -C /usr/local/elasticsearch/es1/</span><br><span class="line"></span><br><span class="line">cd /usr/local/elasticsearch/es1/</span><br><span class="line"></span><br><span class="line">vim config/elasticsearch.yml</span><br><span class="line">cluster.name: es # 集群名称，同一集群要一致</span><br><span class="line">node.name: node-1 # 集群下各节点名称</span><br><span class="line">http.port: 9200 # 端口</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">跨域请求配置（为了让类似<span class="built_in">head</span>的第三方插件可以请求es）</span></span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">集群发现配置</span></span><br><span class="line">discovery.seed_hosts: [&quot;81.70.204.157&quot;, &quot;81.70.204.157&quot;, &quot;81.70.204.157&quot;]</span><br><span class="line">cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;, &quot;node-3&quot;]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接超时时间</span></span><br><span class="line">discovery.zen.ping_timeout: 60s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制es1</span><br><span class="line">cp -Rf es1 es2</span><br><span class="line">cp -Rf es1 es3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题：如果内存不够需要调整</span><br><span class="line">-Xms512m</span><br><span class="line">-Xms512m</span><br><span class="line"></span><br><span class="line">http://81.70.204.157:9200/_cluster/health?pretty</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Elasticsearch-插件安装"><a href="#Elasticsearch-插件安装" class="headerlink" title="Elasticsearch 插件安装"></a>Elasticsearch 插件安装</h1><h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><ol>
<li>head</li>
<li>cerebro</li>
<li>elasticHD</li>
</ol>
<h2 id="安装head"><a href="#安装head" class="headerlink" title="安装head"></a>安装head</h2><ol>
<li><p>安装git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install git</span><br></pre></td></tr></table></figure></li>
<li><p>安装node.js</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/local/node</span><br><span class="line">tar xvf node-v12.13.1-linux-x64.tar.xz -C /usr/local/node</span><br><span class="line"></span><br><span class="line">cd /usr/local/node/node-v12.13.1-linux-x64/</span><br><span class="line">复制路径</span><br><span class="line">pwd  </span><br><span class="line">vim etc/profile</span><br><span class="line">配置环境变量</span><br><span class="line">export NODE_HOME=/usr/local/node/node-v12.13.1-linux-x64</span><br><span class="line">export PATH=$PATH:$NODE_HOME/bin</span><br><span class="line"></span><br><span class="line">重新加载环境变量</span><br><span class="line">source /etc/profile</span><br><span class="line">查看版本</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">安装cnpm</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>安装head</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/local/elasticsearch/plugins</span><br><span class="line">cd /usr/local/elasticsearch/plugins</span><br><span class="line">git clone git://github.com/mobz/elasticsearch-head.git</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置插件</p>
<p>进入elasticsearch-head目录，修改Gruntfile.js文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/elasticsearch/plugins/elasticsearch-head/</span><br><span class="line">vim Gruntfile.js</span><br></pre></td></tr></table></figure>

<p>添加hostname: ‘*’</p>
<p><img src="https://i.loli.net/2020/12/04/8BCXVIlYyvJoGtR.png" alt="image.png"></p>
</li>
<li><p>安装和启动</p>
<p>在elasticsearch-head目录下执行 npm install 安装(或者 cnpm install )，完成后在elasticsearch-head目录下执行 npm run start 运行head插件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run start</span><br><span class="line">或者</span><br><span class="line">npm run start &amp; # 后台启动</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="状态："><a href="#状态：" class="headerlink" title="状态："></a>状态：</h3><p>green</p>
<p>yellow 有坏的分片但是能取到完整的数据</p>
<p>red 有坏的分片，不能取出完整的数据</p>
<h3 id="分片："><a href="#分片：" class="headerlink" title="分片："></a>分片：</h3><p>主分片（head中加粗的） 索引设置的分片</p>
<p>备用分片    副本树倍数的副本分片</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="新建索引："><a href="#新建索引：" class="headerlink" title="新建索引："></a>新建索引：</h3><p>es_head     test</p>
<h3 id="创建与修改document"><a href="#创建与修改document" class="headerlink" title="创建与修改document:"></a>创建与修改document:</h3><p><img src="https://i.loli.net/2020/12/04/Ly9mnG7XzMuxEgc.png" alt="image.png"></p>
<p>索引名字是：es_head，本记录的id是：1；</p>
<p>返回的信息：版本号是1，同一条记录修改一次就追加1。</p>
<p>一条记录就提交到ES中建立了索引，注意HTTP的方法是PUT，PUT需要指定 _id 插入数据，否则报错。POST无需指定 _id 插入数据，会使用随机值。</p>
<p><img src="https://i.loli.net/2020/12/04/qO2lWfm1gBHKkL7.png" alt="image.png"></p>
<p>更新接口与创建接口完全一样，ES会查询记录是否存在，如果不存在就是创建，存在就是更新操作。PUT操作必须指定 _id ，否则报错， _id 存在则为更新否则新增。POST操作无需指定 _id ，会使用随机值， _id 存在则为更新否则新增。</p>
<h3 id="查询document"><a href="#查询document" class="headerlink" title="查询document"></a>查询document</h3><p>查询全部</p>
<p><img src="https://i.loli.net/2020/12/04/9sj8UVpDTKLhAdn.png" alt="image.png"></p>
<p>根据_id查询</p>
<p><img src="https://i.loli.net/2020/12/04/9akoENCMHtlWjnR.png" alt="image.png"></p>
<p>found 值为true，表明查询到该文档， _source 字段是文档的内容。</p>
<h3 id="删除document"><a href="#删除document" class="headerlink" title="删除document"></a>删除document</h3><p><img src="https://i.loli.net/2020/12/04/rjwfHZ1MQOEpyTh.png" alt="image.png"></p>
<h2 id="Kibana使用"><a href="#Kibana使用" class="headerlink" title="Kibana使用"></a>Kibana使用</h2><p>Kibana是一个软件，不是插件。</p>
<p>Kibana是一款开源的数据分析和可视化平台，用于和ES协作。可以使用Kibana对ES索引中的数据进行搜索、查看、交互操作。可以很方便利用图表、表格及地图对数据进行多元化的分析和呈现。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载地址：<a href="https://www.elastic.co/cn/downloads/kibana">https://www.elastic.co/cn/downloads/kibana</a></p>
<p>创建文件夹并解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/local/kibana</span><br><span class="line">tar -zxvf kibana-7.4.2-linux-x86_64.tar.gz -C /usr/local/kibana/</span><br></pre></td></tr></table></figure>

<p>修改kibana.yml配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim config/kibana.yml</span><br></pre></td></tr></table></figure>

<p>修改以下三处内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端口，默认5601</span></span><br><span class="line">server.port: 5601</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许访问IP</span></span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 elasticsearch 节点及端口</span></span><br><span class="line">elasticsearch.hosts: [&quot;http://81.70.204.157:9200&quot;, &quot;http://81.70.204.157:9201&quot;, &quot;http://81.70.204.157:9202&quot;]</span><br></pre></td></tr></table></figure>

<p>启动kibana（需要先启动es）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kibana --allow-root</span><br><span class="line">nohup bin/kibana  &amp; --allow-root</span><br></pre></td></tr></table></figure>

<p>访问：<a href="http://106.15.248.56/:5601/">http://106.15.248.56/:5601/</a></p>
<p>关闭后台</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fuser -n tcp 9201</span><br><span class="line">kill 9201</span><br></pre></td></tr></table></figure>



<p><strong>关联索引库</strong> 这个索引必须要有数据才行。</p>
<p><img src="https://i.loli.net/2020/12/04/fGgkFcMXi7bdsen.png" alt="image.png"></p>
<p><strong>操作索引库</strong></p>
<p>通过Discover查询</p>
<p>通过Dev Tools查询</p>
<p><img src="https://i.loli.net/2020/12/04/DH2xXKOzB9NeIFm.png" alt="image.png"></p>
<h2 id="IK-Analysis中文分词器"><a href="#IK-Analysis中文分词器" class="headerlink" title="IK Analysis中文分词器"></a>IK Analysis中文分词器</h2><p>两种力度：ik_smart 粗粒度，ik_max_word 细粒度；</p>
<p>两种类型 </p>
<p>text 数据类型用来索引长文本：分词，建立索引，允许ES来检索词语。不能用来排序和聚合。</p>
<p>Keyword 类型用来建立电子邮箱地址、姓名、邮政编码和标签等数据，不需要进行分词，可以用来检索、过滤、排序和聚合。只能本身进行检索。</p>
<p>ES是分词分到什么，才能搜索到什么。否则搜索不到。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建ik目录</span></span><br><span class="line">mkdir -p /usr/local/elasticsearch/es1/elasticsearch-7.4.2/plugins/ik</span><br><span class="line">mkdir -p /usr/local/elasticsearch/es2/elasticsearch-7.4.2/plugins/ik</span><br><span class="line">mkdir -p /usr/local/elasticsearch/es3/elasticsearch-7.4.2/plugins/ik</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压至ik目录</span></span><br><span class="line">unzip elasticsearch-analysis-ik-7.4.2.zip -d</span><br><span class="line">/usr/local/elasticsearch/es1/elasticsearch-7.4.2/plugins/ik/</span><br><span class="line">unzip elasticsearch-analysis-ik-7.4.2.zip -d</span><br><span class="line">/usr/local/elasticsearch/es2/elasticsearch-7.4.2/plugins/ik/</span><br><span class="line">unzip elasticsearch-analysis-ik-7.4.2.zip -d</span><br><span class="line">/usr/local/elasticsearch/es3/elasticsearch-7.4.2/plugins/ik/</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -Rf es:es /usr/local/elasticsearch/</span><br></pre></td></tr></table></figure>

<p>重启ES</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>创建索引库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -XPUT http://81.70.204.157:9200/ik -H &#x27;Content-Type:application/json&#x27; -d&#x27;&#123;</span><br><span class="line">&quot;settings&quot;: &#123;</span><br><span class="line">&quot;number_of_shards&quot;: 5,</span><br><span class="line">&quot;number_of_replicas&quot;: 1 &#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>设置mapping</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -XPOST http://81.70.204.157:9200/ik/_mapping -H &#x27;Content-Type:application/json&#x27; -d&#x27;&#123;</span><br><span class="line">&quot;properties&quot;: &#123;</span><br><span class="line">&quot;content&quot;: &#123;</span><br><span class="line">&quot;type&quot;: &quot;text&quot;,</span><br><span class="line">&quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">&quot;search_analyzer&quot;: &quot;ik_smart&quot;&#125;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>导入数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -XPOST http://localhost:9200/ik/_create/1 -H &#x27;Content-Type:application/json&#x27; -d&#x27; &#123;&quot;content&quot;:&quot;美国留给伊拉克的是个烂摊子吗&quot;&#125; &#x27;</span><br><span class="line">curl -XPOST http://localhost:9200/ik/_create/2 -H &#x27;Content-Type:application/json&#x27; -d&#x27; &#123;&quot;content&quot;:&quot;公安部：各地校车将享最高路权&quot;&#125; &#x27;</span><br><span class="line">curl -XPOST http://localhost:9200/ik/_create/3 -H &#x27;Content-Type:application/json&#x27; -d&#x27; &#123;&quot;content&quot;:&quot;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船&quot;&#125; &#x27;</span><br><span class="line">curl -XPOST http://localhost:9200/ik/_create/4 -H &#x27;Content-Type:application/json&#x27; -d&#x27; &#123;&quot;content&quot;:&quot;中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首&quot;&#125; &#x27;</span><br></pre></td></tr></table></figure>

<p>测试查询</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -XGET http://localhost:9200/ik/_search?pretty -H &#x27;Content-Type:application/json&#x27; -d&#x27;&#123;</span><br><span class="line">&quot;query&quot; : &#123; &quot;term&quot; : &#123; &quot;content&quot; : &quot;中国&quot;&#125;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>高亮查询</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -XGET http://localhost:9200/ik/_search?pretty -H &#x27;Content-Type:application/json&#x27; -d&#x27;&#123;</span><br><span class="line">&quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;content&quot; : &quot;中国&quot; &#125;&#125;,</span><br><span class="line">&quot;highlight&quot; : &#123;</span><br><span class="line">&quot;pre_tags&quot; : [&quot;&lt;font color=red&gt;&quot;],</span><br><span class="line">&quot;post_tags&quot; : [&quot;&lt;/font&gt;&quot;],</span><br><span class="line">&quot;fields&quot; : &#123;</span><br><span class="line">&quot;content&quot; : &#123;&#125; &#125;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>用于ES导入MySQL数据。</p>
<p>Logstash是开源的服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到你最喜欢的ES数据库中。</p>
<h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><p>创建目录，解压至该目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/local/logstash</span><br><span class="line">tar -zxvf logstash-7.4.2.tar.gz -C /usr/local/logstash/</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/logstash/logstash-7.4.2</span><br><span class="line">bin/logstash -e &#x27;input &#123; stdin &#123;&#125; &#125; output &#123; stdout &#123;&#125; &#125;&#x27;</span><br><span class="line">使用 -e 参数在命令行中指定配置是一种方式，不过如果需要配置更多设置则需要很长的内容。这种情况，我们首先创建一个配置文件，并且指定logstash使用这个配置文件。标准配置为文件含有 input&#123;&#125;, filter&#123;&#125; 和 output&#123;&#125; 三部分。</span><br></pre></td></tr></table></figure>

<p><strong>导入MySQL数据过程，在此忽略</strong></p>
<h1 id="Elasticsearch的JavaAPI"><a href="#Elasticsearch的JavaAPI" class="headerlink" title="Elasticsearch的JavaAPI"></a>Elasticsearch的JavaAPI</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- elasticsearch 服务依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- rest-client 客户端依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- rest-high-level-client 客户端依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Java连接Elasticsearch</strong></p>
<p>ES有两种连接方式：transport、rest。</p>
<p>transport通过TCP方式访问ES（只提供Java，已被删除）</p>
<p>rest方式通过http API 访问ES（没有语言限制）</p>
<p>Java High Level REST Client ,它是基于 Java Low Level REST Client 的封装，并且API接收参数和返回值和 TransportClient 是一样的，使得代码迁移变得容易并且支持了RESTful的风格，兼容了这两种客户端的优点。</p>
<p>缺点是版本的问题。ES的小版本更新非常频繁，在最理想的情况下，客户端的版本要和ES的版本一致（至少主版本号一致），次版本号不一致的话，基本操作也许可以，但是新API就不支持了。</p>
<h2 id="Java-High-Level-REST-Client"><a href="#Java-High-Level-REST-Client" class="headerlink" title="Java High Level REST Client"></a>Java High Level REST Client</h2><p>初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">        RestClient.builder(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;81.70.204.157&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9201</span>, <span class="string">&quot;http&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.close();</span><br></pre></td></tr></table></figure>



<h2 id="ES基础操作"><a href="#ES基础操作" class="headerlink" title="ES基础操作"></a>ES基础操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticsearchTest</span> &#123;</span><br><span class="line">    <span class="comment">//ES服务器IP</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;81.70.204.157&quot;</span>;</span><br><span class="line">    <span class="comment">//ES服务器连接方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SCHEME</span> <span class="operator">=</span> <span class="string">&quot;http&quot;</span>;</span><br><span class="line">    <span class="comment">//初始化ES服务集群</span></span><br><span class="line">    <span class="comment">//参数分别为：IP，端口，连接方式（默认为http）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HttpHost[] httpHosts = &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HttpHost</span>(HOST,<span class="number">9200</span>,SCHEME)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getConnect</span><span class="params">()</span> &#123;</span><br><span class="line">        client = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(httpHosts));</span><br><span class="line">        System.out.println(<span class="string">&quot;获取客户端&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeConnect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != client) &#123;</span><br><span class="line">                client.close();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭连接&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//准备数据</span></span><br><span class="line">        Map&lt;String, Object&gt; jsonMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        jsonMap.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        jsonMap.put(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        jsonMap.put(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;first&quot;</span>);</span><br><span class="line">        <span class="comment">//指定索引库和id及数据</span></span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;ik&quot;</span>).id(<span class="string">&quot;5&quot;</span>).source(jsonMap);</span><br><span class="line">        <span class="comment">//执行请求</span></span><br><span class="line">        <span class="type">IndexResponse</span> <span class="variable">indexResponse</span> <span class="operator">=</span> client.index(indexRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(indexResponse.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Map&lt;String, Object&gt; jsonMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        jsonMap.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        jsonMap.put(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        jsonMap.put(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;second&quot;</span>);</span><br><span class="line">        <span class="comment">//指定索引库和id及数据</span></span><br><span class="line">        <span class="type">UpdateRequest</span> <span class="variable">updateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;ik&quot;</span>, <span class="string">&quot;5&quot;</span>).doc(jsonMap);</span><br><span class="line">        <span class="comment">//执行请求</span></span><br><span class="line">        <span class="type">UpdateResponse</span> <span class="variable">updateResponse</span> <span class="operator">=</span> client.update(updateRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(updateResponse.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//指定索引库和id</span></span><br><span class="line">        <span class="type">DeleteRequest</span> <span class="variable">deleteRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;ik&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="type">DeleteResponse</span> <span class="variable">deleteResponse</span> <span class="operator">=</span> client.delete(deleteRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(deleteResponse.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量增删改操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCUD</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//初始化RulkRequest</span></span><br><span class="line">        <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">        <span class="comment">//指定索引库和id及数据</span></span><br><span class="line">        <span class="comment">//批量添加</span></span><br><span class="line">        request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;ik&quot;</span>)</span><br><span class="line">                .id(<span class="string">&quot;6&quot;</span>)</span><br><span class="line">                .source(XContentType.JSON, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>));</span><br><span class="line">        request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;ik&quot;</span>)</span><br><span class="line">                .id(<span class="string">&quot;7&quot;</span>)</span><br><span class="line">                .source(XContentType.JSON, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        <span class="comment">//批量修改</span></span><br><span class="line">        request.add(<span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;ik&quot;</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line">                .doc(XContentType.JSON, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        <span class="comment">//批量删除</span></span><br><span class="line">        request.add(<span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;ik&quot;</span>, <span class="string">&quot;6&quot;</span>));</span><br><span class="line">        <span class="comment">//执行请求</span></span><br><span class="line">        <span class="type">BulkResponse</span> <span class="variable">bulkResponse</span> <span class="operator">=</span> client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(bulkResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量查询-查询所有</span></span><br><span class="line"><span class="comment">     * SearchSourceBuilder.query(QueryBuilders.matchallQuery());</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRetrieveAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//指定索引库</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;ik&quot;</span>);</span><br><span class="line">        <span class="comment">//构建查询对象</span></span><br><span class="line">        <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">        <span class="comment">//添加查询条件</span></span><br><span class="line">        searchSourceBuilder.query(QueryBuilders.matchAllQuery());</span><br><span class="line">        <span class="comment">//执行请求</span></span><br><span class="line">        searchRequest.source(searchSourceBuilder);</span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//总条数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;总条数：&quot;</span> + searchResponse.getHits().getTotalHits().value);</span><br><span class="line">        <span class="comment">//结果数据（如果不设置返回条数，大于十条默认值返回十条）</span></span><br><span class="line">        SearchHit[] hits = searchResponse.getHits().getHits();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分数：&quot;</span> + hit.getScore());</span><br><span class="line">            Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">            System.out.println(<span class="string">&quot;index -&gt; &quot;</span> + hit.getIndex());</span><br><span class="line">            System.out.println(<span class="string">&quot;id -&gt; &quot;</span> + hit.getId());</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; s : sourceAsMap.entrySet()) &#123;</span><br><span class="line">                System.out.println(s.getKey() + <span class="string">&quot; -- &quot;</span> + s.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量查询-匹配查询</span></span><br><span class="line"><span class="comment">     * 匹配</span></span><br><span class="line"><span class="comment">     * SearchSourceBuilder.query(QueryBuilders.multiMatchQuery(value,key1,key2...))</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRetrieveMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 指定索引库</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;ik&quot;</span>);</span><br><span class="line">        <span class="comment">// 构建查询对象</span></span><br><span class="line">        <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">        <span class="comment">// 添加查询条件</span></span><br><span class="line">        <span class="comment">// 指定从 content 和 goodsName 字段中查询</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">        searchSourceBuilder.query(QueryBuilders.multiMatchQuery(key, <span class="string">&quot;content&quot;</span>, <span class="string">&quot;goodsName&quot;</span>));</span><br><span class="line">        <span class="comment">// 执行请求</span></span><br><span class="line">        searchRequest.source(searchSourceBuilder);</span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//总条数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;总条数：&quot;</span> + searchResponse.getHits().getTotalHits().value);</span><br><span class="line">        <span class="comment">//结果数据（如果不设置返回条数，大于十条默认值返回十条）</span></span><br><span class="line">        SearchHit[] hits = searchResponse.getHits().getHits();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分数：&quot;</span> + hit.getScore());</span><br><span class="line">            Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">            System.out.println(<span class="string">&quot;index -&gt; &quot;</span> + hit.getIndex());</span><br><span class="line">            System.out.println(<span class="string">&quot;id -&gt; &quot;</span> + hit.getId());</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; s : sourceAsMap.entrySet()) &#123;</span><br><span class="line">                System.out.println(s.getKey() + <span class="string">&quot; -- &quot;</span> + s.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量查询-分页查询-按分数或id排序</span></span><br><span class="line"><span class="comment">     * 分页</span></span><br><span class="line"><span class="comment">     * SearchSourceBuilder.form(page),size(pagesize);</span></span><br><span class="line"><span class="comment">     * 匹配</span></span><br><span class="line"><span class="comment">     * SearchSourceBuilder.query(QueryBuilders.multiMatchQuery(value,key1,key2...));</span></span><br><span class="line"><span class="comment">     * 默认排序</span></span><br><span class="line"><span class="comment">     * SearchSourceBuilder.sort(SortBuilders.scoreSort().order(SortOrder.ASC));</span></span><br><span class="line"><span class="comment">     * 字段配许</span></span><br><span class="line"><span class="comment">     * SearchSourceBuilder.sort(SortBuilders.fieldSort(key).order(SortOrder.ASC));</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRetrievePage</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 指定索引库</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;ik&quot;</span>);</span><br><span class="line">        <span class="comment">// 构建查询对象</span></span><br><span class="line">        <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">        <span class="comment">// 添加分页条件， 从第 0 个开始， 返回 5 个</span></span><br><span class="line">        searchSourceBuilder.from(<span class="number">0</span>).size(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 添加查询条件</span></span><br><span class="line">        <span class="comment">// 指定从 goodsName 字段中查询</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">        searchSourceBuilder.query(QueryBuilders.multiMatchQuery(key, <span class="string">&quot;content&quot;</span>));</span><br><span class="line">        <span class="comment">// 按照 score 正序排序（默认倒序）</span></span><br><span class="line"><span class="comment">//        searchSourceBuilder.sort(SortBuilders.scoreSort().order(SortOrder.ASC));</span></span><br><span class="line">        <span class="comment">// 并且按照 id 倒叙排序（分数字段会失效返回 NaN）</span></span><br><span class="line">        searchSourceBuilder.sort(SortBuilders.fieldSort(<span class="string">&quot;_id&quot;</span>).order(SortOrder.DESC));</span><br><span class="line">        <span class="comment">//执行请求</span></span><br><span class="line">        searchRequest.source(searchSourceBuilder);</span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//总条数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;总条数：&quot;</span> + searchResponse.getHits().getTotalHits().value);</span><br><span class="line">        <span class="comment">//结果数据（如果不设置返回条数，大于十条默认值返回十条）</span></span><br><span class="line">        SearchHit[] hits = searchResponse.getHits().getHits();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分数：&quot;</span> + hit.getScore());</span><br><span class="line">            Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">            System.out.println(<span class="string">&quot;index -&gt; &quot;</span> + hit.getIndex());</span><br><span class="line">            System.out.println(<span class="string">&quot;id -&gt; &quot;</span> + hit.getId());</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; s : sourceAsMap.entrySet()) &#123;</span><br><span class="line">                System.out.println(s.getKey() + <span class="string">&quot; -- &quot;</span> + s.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量查询-分页查询-高亮查询</span></span><br><span class="line"><span class="comment">     * 高亮</span></span><br><span class="line"><span class="comment">     * SearchSourceBuilder.highlightBuilder(HighlightBuilder.field(key).preTags(&quot;&lt;span style=&#x27;color:red;&#x27;&gt;&quot;).postTags(&quot;&lt;/span&gt;&quot;));</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 指定索引库</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;ik&quot;</span>);</span><br><span class="line">        <span class="comment">// 构建查询对象</span></span><br><span class="line">        <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">        <span class="comment">// 添加分页条件， 从第 0 个开始， 返回 5 个</span></span><br><span class="line">        searchSourceBuilder.from(<span class="number">0</span>).size(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 构建高亮对象</span></span><br><span class="line">        <span class="type">HighlightBuilder</span> <span class="variable">highlightBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>();</span><br><span class="line">        highlightBuilder.field(<span class="string">&quot;content&quot;</span>)</span><br><span class="line">                .preTags(<span class="string">&quot;&lt;span style=&#x27;color:red;&#x27;&gt;&quot;</span>)</span><br><span class="line">                .postTags(<span class="string">&quot;&lt;/span&gt;&quot;</span>);</span><br><span class="line">        searchSourceBuilder.highlighter(highlightBuilder);</span><br><span class="line">        <span class="comment">// 添加查询条件</span></span><br><span class="line">        <span class="comment">// 指定从 goodsName 字段中查询</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">        searchSourceBuilder.query(QueryBuilders.multiMatchQuery(key, <span class="string">&quot;content&quot;</span>));</span><br><span class="line">        <span class="comment">//执行请求</span></span><br><span class="line">        searchRequest.source(searchSourceBuilder);</span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//总条数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;总条数：&quot;</span> + searchResponse.getHits().getTotalHits().value);</span><br><span class="line">        <span class="comment">//结果数据（如果不设置返回条数，大于十条默认值返回十条）</span></span><br><span class="line">        SearchHit[] hits = searchResponse.getHits().getHits();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">            <span class="comment">// 构建项目中所需的数据结果集</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> String.valueOf(hit.getHighlightFields().get(<span class="string">&quot;content&quot;</span>).fragments()[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//            Integer goodsId = Integer.valueOf((Integer) hit.getSourceAsMap().get(&quot;goodsId&quot;));</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">goodsName</span> <span class="operator">=</span> String.valueOf(hit.getSourceAsMap().get(<span class="string">&quot;content&quot;</span>));</span><br><span class="line"><span class="comment">//            BigDecimal marketPrice = new BigDecimal(String.valueOf(hit.getSourceAsMap().get(&quot;marketPrice&quot;)));</span></span><br><span class="line"><span class="comment">//            String originalImg = String.valueOf(hit.getSourceAsMap().get(&quot;originalImg&quot;));</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;goodsId -&gt; &quot; + goodsId);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;content -&gt; &quot;</span> + content);</span><br><span class="line"><span class="comment">//            System.out.println(&quot;highlightMessage -&gt; &quot; + highightMessage);</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;marketPrice -&gt; &quot; + marketPrice);</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;originalImg -&gt; &quot; + originalImg);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p>阅读官方文档的好处，可以深入理解其内在机制。</p>
<h2 id="文档导航"><a href="#文档导航" class="headerlink" title="文档导航"></a>文档导航</h2><p>理解后面每一章节所要讲述的知识内容。</p>
<ul>
<li>基础入门：数据输入输出和处理文档数据。了解分布式处理过程。</li>
<li>深入搜索：使用更高级的特性，获取最佳的结果。</li>
<li>处理人类语言： 分词和查找人类语言棘手问题。</li>
<li>聚合：讨论聚合和分析。</li>
<li>地理位置：支持两种地理位置检索方式，经纬坐标点和复杂的地理形状。</li>
<li>数据模型：如何设计索引来匹配你系统中的数据流。</li>
<li>管理、监控和部署：生产环境上线的重要配置、监控点和如何诊断以避免出现问题。</li>
</ul>
<p>有时需要在<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">Elasticsearch 参考手册</a> 获取最新的参考手册和相关文档。</p>
<p>还需要到<a href="http://elasticsearch.cn/">中文社区</a> 来学习别人的经验。</p>
<h1 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h1><h2 id="term-match-match-phase-query-string之间的区别"><a href="#term-match-match-phase-query-string之间的区别" class="headerlink" title="term,match,match_phase,query_string之间的区别"></a>term,match,match_phase,query_string之间的区别</h2><p>match：（分词部分匹配）模糊匹配，需要指定字段名，输入会进行分词，部分分词匹配到就会查询。</p>
<p>term：（精确查找分词，需要确定会有这个分词才行）需要指定字段名，输入不会分词，查询数据分词是否包含输入值。</p>
<p>match_phase：（等价于不分词，进行精确查找）需要指定字段名，输入会分词，结果包含全部分词，要求结果中包含分词且顺序是一样的。</p>
<p>query_string：（与match_phase基本相同，可以给输入值，所有字段中所有）可以不指定字段名，在所有字段中搜索，范围更广泛。</p>
<h2 id="ES的复杂查询"><a href="#ES的复杂查询" class="headerlink" title="ES的复杂查询"></a>ES的复杂查询</h2><h3 id="sql查询方式"><a href="#sql查询方式" class="headerlink" title="sql查询方式"></a>sql查询方式</h3><p>类似mysql语句</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _sql?format=csv</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;select articleid from article_ignore_case where gettime between &#x27;2010-03-04 04:14:37&#x27; and &#x27;2021-03-10 04:14:37&#x27; or  content.original like &#x27;%Free Tibet%&#x27; or title.original like &#x27;%Free Tibet%&#x27; &quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="sql转ES-json查询方式"><a href="#sql转ES-json查询方式" class="headerlink" title="sql转ES-json查询方式"></a>sql转ES-json查询方式</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _sql/translate</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;select articleid from article_ignore_case where gettime between &#x27;2010-03-04 04:14:37&#x27; and &#x27;2021-03-10 04:14:37&#x27; or  content.original = &#x27;%Free Tibet%&#x27; or title.original like &#x27;%Free Tibet%&#x27; order by gettime desc&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="复杂查询json"><a href="#复杂查询json" class="headerlink" title="复杂查询json"></a>复杂查询json</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET article_ignore_case/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;content.original&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Free Tibet&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;title.original&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Free Tibet&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span>  </span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;gettime&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2010-03-04 04:14:37&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-03-01 04:14:37&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;content.original&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;title.original&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span>  </span><br><span class="line">              <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;content.trans&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;title.trans&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span>  </span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;website.keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1tvnews.af&quot;</span></span><br><span class="line">                  <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;website.keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2008xianzhang.info&quot;</span></span><br><span class="line">                  <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;content.original&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国世界&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;title.original&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国世界&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span>  </span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;content.trans&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国世界&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;title.trans&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国世界&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span>  </span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;gettime&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;categoryAttributes&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="nested查询方式"><a href="#nested查询方式" class="headerlink" title="nested查询方式"></a>nested查询方式</h2><p>es中如何查询存放的实体对象呢。</p>
<p>如果用不同类型的存储方式，存数据。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span>            </span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="string">&quot;12&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;李四&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="string">&quot;13&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;王五&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="string">&quot;13&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果使用下列的查询方式，是可以查到数据的</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /XXX/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;user.name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;user.age&quot;</span><span class="punctuation">:</span><span class="number">13</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>对象name和age的关联性消失了。</p>
<p>需要使用nested方式存数据，查数据。才能保证数据之间的关联性。</p>
<h3 id="nested-设置-mapping"><a href="#nested-设置-mapping" class="headerlink" title="nested 设置 mapping"></a>nested 设置 mapping</h3><p>在通常指定 object 类型的地方，改成 nested 类型</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /XXX</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;text&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;text&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;keyword&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">				<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;nested&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;text&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;short&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>再用以前的方法就搜索不到了</p>
<p>nested方式搜索：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /XXX/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;nested&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span><span class="string">&quot;user&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">                                    <span class="punctuation">&#123;</span></span><br><span class="line">                                        <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                                            <span class="attr">&quot;user.name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span></span><br><span class="line">                                        <span class="punctuation">&#125;</span></span><br><span class="line">                                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                                    <span class="punctuation">&#123;</span></span><br><span class="line">                                        <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                                            <span class="attr">&quot;user.age&quot;</span><span class="punctuation">:</span><span class="number">12</span></span><br><span class="line">                                        <span class="punctuation">&#125;</span></span><br><span class="line">                                    <span class="punctuation">&#125;</span></span><br><span class="line">                                <span class="punctuation">]</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>








]]></content>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>认证中心登录流程</title>
    <url>/2023/04/25/%E5%90%8C%E5%88%9B/%E8%AE%A4%E8%AF%81%E4%B8%AD%E5%BF%83%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="认证中心登录流程"><a href="#认证中心登录流程" class="headerlink" title="认证中心登录流程"></a>认证中心登录流程</h1><ol>
<li><p>用户名密码调用认证中心登录接口</p>
</li>
<li><p>认证中心服务器操作：</p>
<ol>
<li><p>登录之前，先退出其他已登录账号</p>
<ol>
<li><p>删除登录凭证TGT和缓存的用户数据</p>
</li>
<li><p>删除凭证Cookie</p>
</li>
<li><p>删除所有TGT对应的调用凭证，并通知客户端登出注销本地Session</p>
<ol>
<li>删除TGT</li>
<li>获取jwtToken</li>
<li>把jwtToken存入黑名单</li>
<li>响应客户端，登出请求</li>
<li>删除jwtToken</li>
</ol>
</li>
</ol>
</li>
<li><p>根据用户名密码查询用户信息。</p>
</li>
<li><p>获取TGT登录凭证</p>
<ol>
<li>根据UUID随机生成TGT</li>
<li>TGT为key，将用户信息缓存Redis</li>
<li>TGT存入Cookie</li>
</ol>
</li>
<li><p>生成授权码code，跳转重定向地址</p>
<ol>
<li>根据appId获取app地址</li>
<li>根据UUID生成随机code</li>
<li>code为key，将TGT登录凭证和app地址，缓存Redis</li>
<li>将code拼接到重定向地址：业务页面地址+code</li>
</ol>
</li>
<li><p>接口响应重定向地址</p>
</li>
</ol>
</li>
<li><p>重定向业务页面</p>
</li>
<li><p>业务页面调用业务后端服务</p>
</li>
<li><p>业务后端服务器根据code调用认证中心Oauth2获取token。（认证中心Oauth2同时支持code和用户名密码两种登录获取token方式）</p>
</li>
<li><p>认证中心获取token接口</p>
<ol>
<li>验证参数与应用</li>
<li>校验授权，通过code，获取包含user等信息的AccessTokenContent对象<ol>
<li>code获取缓存TGT</li>
<li>根据TGT获取缓存用户信息</li>
<li>从用户中心获取用户角色和权限信息</li>
<li>分别缓存用户角色和权限信息</li>
</ol>
</li>
<li>生成jwtToken并返回<ol>
<li>根据TGT、用户信息、appId、业务地址</li>
<li>根据UUID随机生成accessToken调用凭证</li>
<li>accessToken为key缓存TGT、用户信息、appId、业务地址信息</li>
<li>TGT为key缓存accessToken调用凭证</li>
<li>根据UUID随机生成resfreshToken刷新调用凭证</li>
<li>resfreshToken为key缓存TGT、用户信息、appId、业务地址、accessToken</li>
<li>创建token对象（<em>accessToken</em>调用凭证，resfreshToken：当前<em>AccessToken</em>超时用于刷新<em>AccessToken</em>并延长服务端<em>session</em>时效必要参数，应用标识<em>appId</em>，用户信息<em>user</em>）</li>
<li>将token对象生成JWT<ol>
<li>String jwt = Jwts.<em>builder</em>().setClaims(claims).signWith(SignatureAlgorithm.<em>HS256</em>, secret).compact();</li>
<li>将<em>accessToken</em>为<em>key</em>，缓存jwt</li>
</ol>
</li>
<li>响应业务系统JWT</li>
<li>业务系统响应前端token<ol>
<li>业务系统通过response.getOutputStream().write(JSONObject.<em>toJSONString</em>(respResult).getBytes(StandardCharsets.<em>UTF_8</em>))响应前端token</li>
</ol>
</li>
<li>业务前端根据token调用业务系统接口</li>
<li>业务系统接口每次都会经过权限拦截，获取接口token，调用认证中心接口/checkToken，判断token是否在黑名单，不在存表示token有效。</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>同创</category>
      </categories>
      <tags>
        <tag>同创</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是持久化？</title>
    <url>/2023/04/26/%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>持久化什么意思？是不是就是存储在数据库中，或者存储为一个文件放在硬盘中？</p>
<blockquote>
<ol start="2">
<li>持久化是将程序数据在持久状态和瞬时状态间转换的机制。</li>
<li>持久化（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。</li>
<li>持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</li>
<li>JDBC就是一种持久化机制。文件IO也是一种持久化机制。</li>
</ol>
</blockquote>
<p>以上内容为百度百科。</p>
]]></content>
  </entry>
  <entry>
    <title>埋点与日志的区别是什么？</title>
    <url>/2023/04/27/%E5%9F%8B%E7%82%B9%E4%B8%8E%E6%97%A5%E5%BF%97%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<ol>
<li><p>代码里有专门打日志的代码，也有专门打埋点的。</p>
</li>
<li><p>主要作用：日志用于排查问题，埋点用于记录用户行为数据。</p>
</li>
</ol>
<h1 id="埋点"><a href="#埋点" class="headerlink" title="埋点"></a>埋点</h1><p>埋点主要是了解用户行为的重要步骤，注入特定的代码以记录关键指标用于未来提升应用性能的重要环节。</p>
<h2 id="埋点与日志的区别"><a href="#埋点与日志的区别" class="headerlink" title="埋点与日志的区别"></a>埋点与日志的区别</h2><ol>
<li><p>埋点可以看作是日志的子集。被埋点的任何数据都应该记录在日志中。</p>
</li>
<li><p>埋点承担了为聚合分析发布关键性能数据的职责。</p>
</li>
<li><p>日志则提供了用户在不同级别跟踪应用的细节信息。</p>
<blockquote>
<p>从低到高依次为:</p>
<p>Verobse:几乎提供了所有的细节，主要用于跟踪执行过程中控制流</p>
<p>Debug:表示数据主要用于调试</p>
<p>Info:表示非错误信息</p>
<p>Warning:表示可恢复的错误</p>
<p>Error：表示不可恢复的错误</p>
</blockquote>
</li>
<li><p>日志的记录会贯穿应用的整个生命周期，而埋点只应该用在某些特定阶段。</p>
</li>
<li><p>埋点数据会发送到服务器，日志是记录在本地设备。</p>
</li>
<li><p>埋点与日志不可相互替代</p>
</li>
<li><p>日志可以非常详细。埋点应该尽可能少地，因为向服务器报告时会消耗网络资源。</p>
</li>
</ol>
<p>因此，只对有需要的事件进行埋点非常重要，这些事件要包含足够多的数据以满足重要报告的需要，埋点和过度埋点之间并没有清晰的界限。一开始应仅对少量报告进行埋点，然后随着时间推移，逐步增加埋点的覆盖率。</p>
<h2 id="埋点上传机制"><a href="#埋点上传机制" class="headerlink" title="埋点上传机制"></a>埋点上传机制</h2><p>实时上报：服务端提供日志记录接口，当触发事件时，直接调用日志记录接口将日志记录在服务端。如果是频率低，数据量小，实时性要求高的数据可以不设限制。</p>
<p>延时上报：服务端提供日志上传接口，客户端将日志暂存本地，当达到一定大小或一定时间时，将日志通过上传接口压缩后上传。这个时间和数据量一般根据公司业务情况自定义。</p>
<h2 id="如何提升埋点质量"><a href="#如何提升埋点质量" class="headerlink" title="如何提升埋点质量"></a>如何提升埋点质量</h2><h3 id="关键数据后端埋点"><a href="#关键数据后端埋点" class="headerlink" title="关键数据后端埋点"></a>关键数据后端埋点</h3><p>关键行为采集使用后端埋点。比如订单支付、注册成功与否，通过后端数据采集，好处是：数据量全面和提高数据的准确性、实时性。</p>
<h3 id="完善的埋点规范"><a href="#完善的埋点规范" class="headerlink" title="完善的埋点规范"></a>完善的埋点规范</h3><p>比如我们规定埋点名称只能由字母、下划线、数字组成，并保证其的唯一性。例如，设定ck是点击、sw是展示；埋点事件命名规范是：{团队|业务|角色}{组件|页面}{具体元素}_{动作}</p>
<blockquote>
<p>示例：</p>
<p> trademark_NavBar_bar_ck 。trademark代表业务线，NavBar代表页面，bar代表功能，ck是点击</p>
<p> patent_comt_share_ck 。patent代表业务线，comt评价组件，share分享按钮，ck点击</p>
</blockquote>
<h3 id="流程规范约束"><a href="#流程规范约束" class="headerlink" title="流程规范约束"></a>流程规范约束</h3><p>埋点需求和业务功能需求一样重要，也需要经历【需求—评审—开发—测试—验收—上线】的完整生命周期，如果能按照这个流程规范一环一环做好，那么我们已经能够避免90%的风险。</p>
<p><a href="https://baijiahao.baidu.com/s?id=1709302436597846884&wfr=spider&for=pc">原文地址</a></p>
]]></content>
  </entry>
  <entry>
    <title>Navicat 链接远端Oracle数据库</title>
    <url>/2020/07/13/Oracle/Navicat%20%E9%93%BE%E6%8E%A5%E8%BF%9C%E7%AB%AFOracle%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>Oracle官网下载Oracle的客户端 install client。<br>官网地址：<a href="https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html">https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html</a></p>
<p>我下载的是：instantclient-basic-windows.x64-19.6.0.0.0dbru.zip</p>
<p>我解压到：D:\Oracle\instantclient_19_6</p>
<p>在这个目录下新建sqlnet.ora和tnsnames.ora两个文件<br>sqlnet.ora文件内容<br>　　SQLNET.AUTHENTICATION_SERVICES= (NTS)<br>　　NAMES.DIRECTORY_PATH= (TNSNAMES, EZCONNECT)<br>tnsnames.ora文件内容<br>　　orcl =<br>　　　　(DESCRIPTION =<br> 　　　　 (ADDRESS_LIST =<br>   　　　　 (ADDRESS = (PROTOCOL = TCP)(HOST = <em><strong>192.168.146.143</strong></em> )(PORT = 1521))<br>  　　　　　　)<br> 　　　　　 (CONNECT_DATA =<br>    　　　　　    (SERVICE_NAME = <strong>orcl</strong> )<br>  　　　　　　)<br>　　　　　)<br>　注：粗体部分需要按需配置，如果端口是自定义的也需要相应变更。</p>
<p>设置系统变量</p>
<ol>
<li>变量名：ORACLE_HOME<br>变量值：D:\Oracle\instantclient_19_6  </li>
<li>变量名：TNS_ADMIN<br>变量值：D:\Oracle\instantclient_19_6  </li>
<li>变量名：NLS_LANG<br>变量值：SIMPlIFIED CHINESE_CHINA.ZHS16GBK  </li>
<li>修改Path变量<br>添加D:\Oracle\instantclient_19_6   <h3 id="安装Nevicat"><a href="#安装Nevicat" class="headerlink" title="安装Nevicat"></a>安装Nevicat</h3>通过Tools（工具）-&gt;Options-&gt; Miscellaneous -&gt; OCI  将Nevicat的oci.dll更改为Oracle客户端的oci.dll</li>
</ol>
<p>一切准备完成，可以直接用Nevicat链接远端Oracle数据库了。<br>我看的是两个人不同操作，有的步骤可能多余，我也不想再仔细研究了</p>
]]></content>
  </entry>
  <entry>
    <title>Oracle的使用</title>
    <url>/2020/07/14/Oracle/Oracle%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>查看触发器</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> text <span class="keyword">from</span> all_source <span class="keyword">where</span> type <span class="operator">=</span> <span class="string">&#x27;TRIGGER&#x27;</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;TR_T00HM009_AFT_T00HZ004&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>启用/禁用触发器</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T00HM009 enable <span class="keyword">all</span> triggers; <span class="comment">-- 启用指定表</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T00HM009 disable <span class="keyword">all</span> triggers; <span class="comment">-- 禁用指定表</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">trigger</span> <span class="string">&#x27;&#x27;</span> enable; <span class="comment">-- 启用指定触发器</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">trigger</span> <span class="string">&#x27;&#x27;</span> disable; <span class="comment">-- 禁用指定触发器</span></span><br></pre></td></tr></table></figure>



<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>查看存储过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> text form user_source <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%T00HZ004_PKG%&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="Oracle数据库恢复与备份"><a href="#Oracle数据库恢复与备份" class="headerlink" title="Oracle数据库恢复与备份"></a>Oracle数据库恢复与备份</h2><h3 id="登录Oracle"><a href="#登录Oracle" class="headerlink" title="登录Oracle"></a>登录Oracle</h3><pre><code>sqlplus /nolog
conn /as sysdba
//或
sqlplus / as sysdba
</code></pre>
<h3 id="恢复impdp"><a href="#恢复impdp" class="headerlink" title="恢复impdp"></a>恢复impdp</h3><ol>
<li>在本地创建表空间<blockquote>
<p>CREATE TABLESPACE NNC_DATA01(表空间名) DATAFILE ‘E:\tablespace\nncdata01.dbf’(地址及bdf文件名) SIZE 1000M(表空间大小) AUTOEXTEND ON NEXT 50M(自动扩展空间大小) EXTENT MANAGEMENT LOCAL UNIFORM SIZE 256K;</p>
</blockquote>
</li>
<li>创建用户<blockquote>
<p>create user yonghuming(设置用户名) identified by mima(设置密码) default tablespace NNC_DATA01(创建的表空间名) temporary tablespace temp;</p>
</blockquote>
</li>
<li>给用户授权：<blockquote>
<p>grant connect,resource to yonghuming;<br>grant create session to yonghuming;<br>grant MANAGE SCHEDULER to yonghuming;<br>grant CREATE VIEW to yonghuming;<br>grant CREATE JOB to yonghuming;<br>grant UNLIMITED TABLESPACE to yonghuming;<br>grant dba to yonghuming;    //这个必须有  </p>
</blockquote>
</li>
<li>创建 导入数据库的存放目录，用于impdp，如果存在了就不用创建了。  <blockquote>
<p>select * from dba_directories;<br>create or replace directory dir as ‘D:\importdir’;  </p>
</blockquote>
</li>
<li>cmd导入库数据泵  <blockquote>
<p>impdp yonghuming(目标库用户名)/(目标库用户相应的密码)@orcl   DIRECTORY=importdir(地址目录变量)  dumpfile=OK051501BAK0628.DMP(需要导入的库文件)  remap_schema=OK051501(原库用户名):yonghuming(目标库用户名)  logfile=dtey20200628_dtey200706.log(日志文件名)  TABLE_EXISTS_ACTION=TRUNCATE;   </p>
</blockquote>
<h3 id="备份expdp"><a href="#备份expdp" class="headerlink" title="备份expdp"></a>备份expdp</h3></li>
<li>cmd导出数据库<blockquote>
<p>//–先查询一下存放的路径<br>select * from dba_directories;<br>expdp okdemo(原用户名)/okmima(原用户密码)@orcl schemas=okdemo(原用户名) dumpfile=okdemobak0714.dmp(导出数据库文件名) logfile=okdemobak0714.log(日志文件名) directory=dir(数据库文件和日志文件存放地址变量);</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>mac通过ssh免密连接云服务器</title>
    <url>/2023/12/13/mac-ssh-%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5ubuntu%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h3 id="mac通过ssh服务器密钥连接服务器"><a href="#mac通过ssh服务器密钥连接服务器" class="headerlink" title="mac通过ssh服务器密钥连接服务器"></a>mac通过ssh服务器密钥连接服务器</h3><ol>
<li><p>获取服务器密钥文件：key.pem，并把密钥文件存储在一个地方（最好放在~/.ssh/目录下）。</p>
</li>
<li><p>密钥pem文件的权限需要设置为只有拥有者读写权限(600)。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod 0600 key.pem</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行ssh命令，成功连接服务器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 当前目录</span><br><span class="line">ssh -i key.pem ubuntu@192.168.2.100</span><br><span class="line">或者</span><br><span class="line">ssh -i /目录/key.pem ubuntu@192.168.2.100</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>免密登录。如果需要长期登录远程服务器，使用ssh-add把pem文件添加到ssh高速缓存，下次直接登录。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-add -K key.pem</span><br><span class="line"></span><br><span class="line">ssh ubuntu@192.168.2.100</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用别名，快捷登录</li>
</ol>
<p>在~/.ssh下创建config，配置别名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh/</span><br><span class="line">vim config</span><br><span class="line"></span><br><span class="line">// config中的内容</span><br><span class="line">Host ubuntu</span><br><span class="line">HostName 124.221.90.34</span><br><span class="line">User ubuntu</span><br><span class="line"></span><br><span class="line">// 保存退出 esc :wq</span><br><span class="line">// ssh使用别名登录</span><br><span class="line">ssh ubuntu</span><br></pre></td></tr></table></figure>



<h3 id="mac使用ssh实现免密登录"><a href="#mac使用ssh实现免密登录" class="headerlink" title="mac使用ssh实现免密登录"></a>mac使用ssh实现免密登录</h3><p>ssh登录分两种，一种是基于口令（账号密码），另外一种是基于密钥的方式。</p>
<p>基于口令，就是每次登录输入账号和密码，显然这样做是比较麻烦的。</p>
<p>如何基于密钥实现免密登录。</p>
<ol>
<li>使用ssh-keygen生产密钥对。最好是到ssh的目录下去操作，这样会在ssh的目录下生成密钥对：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ssh-keygen -t rsa -f cvm   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t 是要使用的算法</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f 要生成的文件名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入命令后两次直接回车</span></span><br></pre></td></tr></table></figure>

<p>执行完成后，会在目录~/.ssh下生成对应的密钥对。</p>
<ol start="2">
<li>将公钥添加到要免密登录的服务器中</li>
</ol>
<p>使用ssh-copy-id命令将上一步生成的公钥(.pub结尾)上传到服务器中，期间需要输入一次服务器密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i cvm.pub root@ip</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i 指定要添加的公钥的文件名</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root  免密登陆的用户名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip	服务器的ip</span></span><br></pre></td></tr></table></figure>

<p>ssh-copy-id 会将指定的文件内容追加到服务器 <strong>~/.ssh/authorized_keys</strong> 文件中。</p>
<ol start="3">
<li>使用ssh-add命令将生成的密钥(<strong>cvm</strong>)加入到ssh高速缓存中:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-add -K cvm</span><br></pre></td></tr></table></figure>

<p>ssh-add命令是把专用密钥添加到ssh-agent的高速缓存中,从而提高ssh的认证速度。</p>
<p>执行完这两部，就可以进行免密登陆了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@ip</span><br></pre></td></tr></table></figure>



<h3 id="客户端给服务器设置别名"><a href="#客户端给服务器设置别名" class="headerlink" title="客户端给服务器设置别名"></a>客户端给服务器设置别名</h3><p>服务器的ip难记或者太多了，可以给各个免密的服务器设置一个别名，之后直接ssh 别名就可以实现登陆服务器</p>
<p>mac的～/.ssh目录下的config文件，没有的话可以手动创建，在这个配置文件里面设置别名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host cvm</span><br><span class="line">HostName ip</span><br><span class="line">User root</span><br><span class="line">IdentityFile ~/.ssh/cvm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Host	别名的名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HostName	服务的ip</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User	用户，这里是root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">IdentityFile  密钥的路径 可不填</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里还有一个Port属性 是端口，默认是22，可不填</span></span><br></pre></td></tr></table></figure>

<p>之后就可以直接使用 ssh cvm 免费登陆了</p>
<h3 id="踩坑权限扩展"><a href="#踩坑权限扩展" class="headerlink" title="踩坑权限扩展"></a>踩坑权限扩展</h3><p>ssh进行认证的过程中除了对用户目录有权限要求外，对服务器上的 .ssh 文件夹和 authorized_keys 文件同样也要限制，如果日志中提示这两个的问题，可以通过如下方式进行修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 700 ~/.ssh</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
